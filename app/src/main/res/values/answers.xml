<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="answers" formatted="false">
 <!--1--><item >1.ПОНЯТИЕ АЛГОРИТМА. ПОДХОДЫ К ОПРЕДЕЛЕНИЮ АЛГОРИТМА. СВОЙСТВО АЛГОРИТМА.\n\n
Понятие алгоритма является одним из основных понятий современных математики и информатики, но зародилось оно еще в глубокой древности. Термин алгоритм происходит от имени средневекового узбекского математика Аль Хорезми (IX в.), который сформулировал правила выполнения четырех арифметических действий в десятичной системе счисления.\n\n
В современной информатике используется следующее определение алгоритма. Алгоритмом называют систему четких однозначных указаний, которые определяют последовательность действий над некоторыми объектами и после конечного числа шагов приводят к получению требуемого результата.\n\n
Подходы к определению алгоритма:
Слово алгоритм происходит от algorithmi – латинской формы написания имени великого математика IX в. Аль Хорезми, который сформулировал правила выполнения арифметических действий. Первоначально под алгоритмами и понимали только правила выполнения четырех арифметических действий над многозначными числами. В дальнейшем это понятие стали использовать вообще для обозначения последовательности действий, приводящих к решению поставленной задачи.\n\n
Свойства алгоритма\n
1. Дискретность алгоритма предполагает, что решение задачи (т.е. алгоритм) разбито на отдельные шаги (операции, команды) и переход к следующему шагу возможен только после выполнения предыдущего.
\n
2. Определенность (точность) алгоритма предполагает, что каждая его команда должна однозначно определять действие исполнителя алгоритма (записанные в алгоритме команды должны иметь однозначную трактовку).
\n
3. Понятность алгоритма подразумевает, что он должен включать в себя только те шаги или команды, которые понятны исполнителю (в алгоритме не могут присутствовать команды, смысл которых неизвестен исполнителю).
\n
4. Результативность (конечность) предполагает, что алгоритм должен быть нацелен на получение конечного результата, т.е. исполнение алгоритма должно закончиться за конечное число шагов.
\n
5. Массовость алгоритма подразумевает, что алгоритм должен быть пригоден для решения целого класса однотипных задач (а не только для одной конкретной задачи).
\n\n
Основные способы записи алгоритмов
\n
1. Словесный способ, т.е. описание алгоритма на естественном языке (словами).\n
2. Формульно-словесный способ, в котором кроме слов могут использоваться математические формулы.\n
3. Графический способ, т.е. в виде блок-схемы.\n
4. Программный способ, т.е. в виде программы на алгоритмическом языке.\n
</item>
 <!--2--><item>2.СТРУКТУРА ПРОГРАММЫ, ЭЛЕМЕНТЫ ЯЗЫКА С++. ПОНЯТИЕ ТИПА ДАННЫХ.\n\n\n\n
Структура программы на языке С++ \n
Программа на языке C++ состоит из функций, описаний и директив препроцессора.\n
(Препроцессор — это программа, которая выполняет обработку файла исходного кода перед началом компиляции).\n
Рассмотрим простейшую программу:\n
#include &lt;Ciostream>\n
using namespace std;\n
int main()\n
{\n
cout &lt;&lt; "Hello world!" &lt;&lt; end1;\n
return 0;\n
}\n
В первой строке с помощью директивы #include подключается заголовочный файл &lt;iostream>, который содержит необходимую информацию для управления вводом/выводом.\n
Следующая директива using открывает доступ к пространству имен (англ. namespace) std, в котором определяются средства стандартной библиотеки языка C++.\n
(Пространство имён — некоторое множество, созданное для логической группировки уникальных идентификаторов).\n
Отправной точкой выполнения любой С++-программы является функция main(). Функция содержит четыре элемента:\n
•	возвращаемый тип (в нашем случае int);\n
•	имя функции (main);\n
•	список параметров, заключенный в круглые скобки (в данном случае список пуст);\n
•	заключенное в фигурные скобки, тело функции, представляющее собой блок инструкций.\n\n
Инструкцией называется часть программы, определяющая действие и не являющаяся директивой препроцессора.\n
В нашей программе тело функции содержит две инструкции:\n
•	cout  "Hello, World!";\n
•	return 0;\n
Во-первых, выводится на экран строка Hello, World, а затем возвращается в точку вызова значение 0, которое означает, что программа выполнена успешно.\n
Обратим внимание на то, что каждая инструкция в языке С++ заканчивается точкой с запятой. Существуют следующие исключения:\n
•	директивы препроцессора, начинающиеся с символа # (например, #include);\n
•	составные операторы и блоки определения функций, которые обрамлены фигурными скобками — { }.\n\n

Элементы языка С++\n
Начнем изучение языка С++ с рассмотрения состава и основных конструкций необходимых для написания программ.\n
Алфавит языка\n
Алфавит языка программирования C++ включает:\n
•	прописные и строчные латинские буквы, и знак подчеркивания;\n
•	арабские цифры от 0 до 9;\n
•	специальные знаки: " { } , | [ ] ( ) + - / % * . \ ? &lt; = > ! &amp; # - ; ' '\n
•	пробельные символы: пробел, символы табуляции, символы перехода на новую строку.\n\n
Из символов алфавита формируются лексемы языка (минимальная единица языка, имеющая самостоятельный смысл):\n
o	идентификаторы;\n
o	ключевые слова;\n
o	знаки операций;\n
o	константы;\n
o	разделители (скобки, точка, запятая, пробельные символы).\n\n

Идентификаторы\n
Идентификатор — это имя программного объекта\n
Первым символом в идентификаторе может быть буква или знак подчеркивания. Внутри идентификаторов не допускается использование пробелов.\n
Например: v1, _sum\n\n

При выборе идентификатора следует иметь в виду следующее:\n
•	идентификатор не должен совпадать с ключевыми словами и именами используемых стандартных объектов языка;\n
•	не рекомендуется начинать идентификаторы с символа подчеркивания, т. к. в этом случае они могут совпасть с именами системных функций или переменных.\n\n

Ключевые слова\n
Ключевые слова — это зарезервированные идентификаторы, которые имеют специальное значение для компилятора.\n

Таблица1. Список ключевых слов C++\n
asm auto bool break case catch char class const\n
const_cast continue default delete do double\n
dynamic_cast else enum explicit export extern\n
false float for friend goto if inline int long\n
mutable namespace new operator private protected\n
public register reinterpret_cast return short\n
signed sizeof static static__cast struct switch\n
template this throw true try typedef typeid typename\n
union unsigned using virtual void volatile wchar_t while\n\n

Знаки операций\n
Знак операции — это один или более символов, определяющих действие над операндами.
Операции делятся на унарные, бинарные и тернарную по количеству участвующих в них операндов. Один и тот же знак может интерпретироваться по-разному в зависимости от контекста.\n\n

Константы\n
Константами называют неизменяемые величины.\n
Различаются целые, вещественные, символьные и строковые константы. Компилятор, выделив константу в качестве лексемы, относит ее к одному из типов по ее внешнему виду.\n\n

Комментарии\n
Комментарии используются для пояснения отдельных частей или всей программы. Отметим, что компилятор игнорирует комментарии.\n
В языке С++ используется две формы комментариев:\n
•	комментарий начинается с двух символов «прямая косая черта» // и заканчивается символом перехода на новую строку\n
•	комментарий заключается между символами-скобками /* ... */\n\n

Внимание! Вложенные комментарии-скобки стандартом не допускаются.\n
Внутри комментария можно использовать любые допустимые на данном компьютере символы.\n\n

Типы данных С++\n
Любая программа в ходе работы обрабатывает данные. Хранение и обработка данных зависит от их типа. Каждая константа, переменная, результат вычисления выражения или функции должны иметь определенный тип.\n\n

Тип данных определяет:\n
•	представление данных в памяти компьютера;\n
•	множество значений, которые могут принимать величины данного типа;\n
•	операции и функции, которые можно применять к величинам этого типа.\n\n

Все типы языка C++ можно разделить на основные и составные.\n
Основные типы данных используются для представления целых, вещественных, символьных и логических величин. К составным типам относятся массивы, перечисления, функции, структуры, ссылки, указатели, объединения и классы.\n\n

Основные типы данных\n
Для описания основных типов данных определены следующие ключевые слова:\n
•	int (целый);\n
•	char (символьный);\n
•	wchar_t (расширенный символьный);\n
•	bool (логический);\n
•	float (вещественный);\n
•	double (вещественный с двойной точностью).\n\n

Для уточнения диапазона значений и внутреннего представления стандартных типов применяются четыре спецификатора типа:\n
•	short (короткий);\n
•	long (длинный);\n
•	signed (знаковый);\n
•	unsigned (беззнаковый).\n\n

Типичные размеры значений и диапазоны представлений\n
Тип: bool\n
Размер (байт): 1\n
Диапазон значений: true, false\n
Замечания: Внутренняя форма представления значения false - 0. Любое другое значение интерпретируется как true.\n\n

Тип: signed char\n
Размер (байт): 1\n
Диапазон значений: -128 ... 127\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: unsigned char\n
Размер (байт): 1\n
Диапазон значений: 0 ... 255\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: signed short int\n
Размер (байт): 2\n
Диапазон значений: -32768 ... 32767\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned short int\n
Размер (байт): 2\n
Диапазон значений: 0 ... 65535\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: signed long int\n
Размер (байт): 4\n
Диапазон значений: -2 147 483 648 ... 2 147 483 647\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned long int\n
Размер (байт): 4\n
Диапазон значений: 0 ... 4 294 967 295\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: float\n
Размер (байт): 4\n
Диапазон значений: 3.4e-38 ... 3.4e+38\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: double\n
Размер (байт): 8\n
Диапазон значений: 1.7e-308 ... 1.7e+308\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: long double\n
Размер (байт):8\n
Диапазон значений: 3.4e-4932 ... 3.4e+4932\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Константам, встречающимся в программе, компилятор приписывает тот или иной тип в соответствии с их видом. Можно явно указать требуемый тип с помощью соответствующих суффиксов:\n
•	Для целых типов:\n
L, l (long) и u, U (unsigned). Например, 50L будет иметь тип long. Суффиксы L и U можно использовать одновременно, например: 105LU.\n
•	Для вещественных типов:\n
F, f (float) и L, l (long). Например, константа 3e+5L будет иметь тип long double, а константа 1.82f — тип float.\n\n

Тип void\n
К основным типам языка С++ относится также тип void. Множество значений этого типа пусто. Он применяется для определения функций, которые не возвращают значения, для указания пустого списка аргументов функции, как базовый тип для указателей и в операции приведения типов.
</item>
 <!--3--><item>3.ОПЕРАЦИИ (АРИФМЕТИЧЕСКИЕ, ЛОГИЧЕСКИЕ) НА ТИПАХ. СТАНДАРТНЫЕ ФУНКЦИИ. ВЫРАЖЕНИЯ.\n\n
Операции. Арифметические операции\n
1. Какие арифметические операции используются в языке C/C++?\n
В языке C++ поддерживаются следующие арифметические операции:\n
+ – сложение;\n
- – вычитание;\n
* – умножение;\n
/ – деление;\n
% – остаток от деления.\n
Все эти операции являются бинарными. Это означает, что для получения результата, нужно 2 операнда. Общий вид арифметической операции:\n
операнд1 операция операнд2\n
где операция – одна из операций +, —, *, %, /.\n\n
            2. Для каких типов данных можно применять арифметические операции?\n
Арифметические операции можно применять для:\n
•  целочисленных типов: short int, unsigned short int, int, unsigned int, long, unsigned long;\n
•  типов с плавающей запятой (вещественных типов): float, double, long double;\n
•  типов (классов), которые содержат «перегруженные» арифметические операции.\n
В арифметических операциях один из операндов может иметь целочисленный тип, а второй быть типом с плавающей запятой. В этом случае результат имеет тип с плавающей запятой.\n\n
3. Как осуществляется приведение типов в операциях +, —, *?\n
В выражениях, где используются операции +, —, *, действуют следующие правила приведения типа результата:\n
•  если оба операнда имеют целый тип, то результат также будет целого типа;\n
•  если хотя бы один из операндов имеет вещественный (с плавающей запятой) тип а другой целый тип, то результат также будет вещественного типа;\n
•  если один из операндов имеет тип float, а другой тип double, то результат будет типа double. Это связано с тем, что тип double требует больше памяти чем тип float. В этом случае происходит расширение типа float к типу double.\n\n
4. Какой приоритет и ассоциативность арифметических операций?\n
Арифметические операции имеют приоритет и ассоциативность, как изображено в следующей таблице.
Знаки операций Наименование   Ассоциативность\n
*   /   %  Бинарные, мультипликативные    Слева направо\n
+   —  Бинарные, аддитивные   Слева направо\n\n
5. Какое отличие между бинарными и унарными операциями сложения (+) и вычитания (—)?\n
Операции сложения (+) и вычитания (—) могут быть как бинарными, так и унарными.\n
Бинарные операции + и — используются в выражениях при проведении вычислений.\n
Унарные операции + и — используются для обозначения знака числа (положительное число или отрицательное число).\n
Пример.\n
int a, b;\n
a = -8; // унарная операция \'-\', обозначает знак числа\n
b = +9; // унарная операция \'+\', b = 9\n
a = b-5; // бинарная операция \'-\', используется для вычисления выражения\n\n
6. Какие особенности использования операции % (остаток от деления)?\n
Операция % используется над целыми операндами. Операция % позволяет получить остаток от деления целых операндов.\n
Пример.\n
// Операция % - взятие остатка от деления\n
int a, b;\n
int c;\n
a = 3;\n
b = 5;\n
c = a % b;   // c = 3\n
a = 8;\n
b = 4;\n
c = a % b;   // c = 0\n
c = 12 % 35; // c = 12\n
c = 35 % 12; // c = 11\n
c = -5 % -3; // c = -2\n\n
7. Какие особенности использования операции / (деление)?\n
Операция деления имеет свои особенности, которые состоят в следующем:\n
•  если два операнда имеют целочисленный тип, то результат возвращается целого типа. В этом случае происходит деление нацело. Остаток от деления урезается;\n
•  если один из операндов имеет тип с плавающей запятой, тогда результат имеет также тип с плавающей запятой.\n
Пример.\n
// Операция деления \'/\'\n
int a, b;\n
int c;\n
float x;\n
a = 8;\n
b = 3;\n
c = a / b; // c = 2\n
x = a / b; // x = 2.0\n
x = a / (float)b; // x = 2.666667\n
x = 17.0 / 3; // x = 5.666667\n
x = 17 / 3;   // x = 5.0\n\n
C++. Логические операции. Поразрядные логические операции. Операции сдвига. Операция XOR\n
1. Для каких типов можно применять логические операции, поразрядные логические операции и операции сдвига?\n
Логические операции, поразрядные логические операции и операции сдвига можно использовать только для операндов целых типов.\n
2. Какие логические операции используются в C++?\n
В языке программирования C++ используются следующие логические операции:\n
•  &amp;&amp; – логическое «И»;\n
•  || – логическое «ИЛИ»;\n
•  ! – логическое «НЕТ».\n
Результатом логических операций есть значение false или true. В языке C++ принято, что значение false считается равным 0, а значение true считается равным 1.\n
Отсюда можно сделать вывод, что false &lt; true. Например:\n
// логические операции\n
bool res;\n
res = false &lt; true; // res = true\n\n
3. Таблица истинности логических операций\n
Таблица истинности логических операций &amp;&amp; (логическое «И»), || (логическое «ИЛИ»), ! (логическое «НЕТ») имеет следующий вид:\n
a b a&amp;&amp;b a||b !a !b\n
false false false false true true\n
false true false true true false\n
true false false true false true\n
true true true true false false\n

В языке C++ принимается, что значение false равно 0, а значение true не равно 0 (любое ненулевое целочисленное значение).\n\n
4. Примеры использования логических операций в C++\n
Пример 1. Логическая операция в сочетании с логическим выражением\n
// логические операции\n
bool res;\n
int a, b;\n
// операция &amp;&amp; (AND)\n
a = 8;\n
b = 5;\n
res = a &amp;&amp; b; // res = True\n
a = 0;\n
res = a &amp;&amp; b; // res = False\n
// операция || (OR)\n
a = 0;\n
b = 0;\n
res = a || b; // res = False\n
b = 7;\n
res = a || b; // res = True\n\n
// операция ! (логическое "НЕТ")\n
a = 0;\n
res = !a; // res = True\n
a = 15;\n
res = !a; // res = False\n\n
Пример 2. Логическая операция в условных выражениях. Приведен фрагмент кода, в котором логическая операция используется в операторе условного перехода if.\n
// логические операции в условных выражениях\n
int a, b;\n
bool res;\n
a = 0;\n
b = 3;\n
res = false;\n
if (a &amp;&amp; b)\n
res = true; // res = false\n
a = 0;\n
b = 7;\n
if (a || b)\n
res = true; // res = true\n\n
5. Какие поразрядные логические операции используются в C++?\n
Язык С++ поддерживает следующие поразрядные логические операции:\n
•  &amp; – поразрядное логическое И (AND);\n
•  ^ – поразрядное сложение по модулю 2 (XOR — исключающее ИЛИ);\n
•  | – поразрядное логическое ИЛИ (OR);\n
•  ~ – поразрядная инверсия (NOT).\n
Операции &amp;, ^, | есть бинарными. Это означает, что они требуют двух операндов. Биты любого операнда сравниваются между собой по следующему правилу: бит в позиции 0 первого операнда сравнивается с битом в позиции 0 второго операнда. Затем бит в позиции 1 первого операнда сравнивается с битом в позиции 1 второго операнда. Так сравниваются все биты целочисленных операндов.\n\n
6. Таблица истинности поразрядных логических операций\n
Каждый бит результата определяется на основе двух операндов, которые являются битами, так как показано в таблице.\n
бит1 бит2 &amp; || ^ ~бит1 ~бит2\n
0 0 0 0 0 1 1\n
0 1 0 1 1 1 0\n
1 0 0 1 1 0 1\n
1 1 1 1 0 0 0\n

Инверсия требует единого операнда справа от знака ~. Результат получается поразрядной инверсией всех битов операнда.\n\n
7. Пример работы с логическими побитовыми операциями\n
Пусть даны два числа 17 и 45 типа unsigned short int. Каждое из чисел занимает в памяти 1 байт или 8 бит. Ниже приведен пример того, как происходит вычисление для каждой побитовой операции\n
  128 64 32 16 8 4 2 1\n
17 =       0 0 0 1 0 0 0 1\n
45 =       0 0 1 0 1 1 0 1\n
17&amp;45 = 0 0 0 0 0 0 0 1 = 1\n
17|45 =  0 0 1 1 1 1 0 1 = 61\n
17^45 = 0 0 1 1 1 1 0 0 = 60\n
~17 =     1 1 1 0 1 1 1 0 = 238\n

Как видно из примера, происходит выполнение заданной операции над каждым битом.\n\n
8. Какие операции сдвига используются в C++?\n
Язык С++ включают две операции поразрядного сдвига:\n
•  &lt;&lt; – сдвиг влево значения операнда на заданное количество бит. Операнд размещается слева от знака операции. Число сдвигаемых бит указывается справа от знака операции;\n
•  >> – сдвиг вправо значения операнда на заданное количество бит. Операнд размещается слева от знака операции (&lt;&lt;). Количество сдвигаемых бит размещается справа от знака операции.\n
Выдвижные биты теряются, а «входят» нулевые биты. Сдвиг операндов влево на 1, 2, 3 и более разрядов – наиболее быстрый способ умножения на 2, 4, 8, … Сдвиг операндов вправо на 1, 2, 3 и более разрядов – наиболее быстрый способ деления на 2, 4, 8, …\n
Если в программе нужно, чтобы операция умножения целочисленных операндов на 2, 4, 8 и т.д. происходила максимально быстро, то целесообразно использовать операцию сдвига влево.\n
Это касается и случаев, когда нужно максимально быстро поделить целочисленный операнд на 2, 4, 8 и т.д. В этих случаях рекомендуется использовать сдвиг вправо.\n\n
9. Примеры использования операций сдвига в программе
\\// Операции сдвига\n
int a;\n
int b;\n
int c;\n
a = 15;\n
b = -5;\n

// сдвиг влево - умножение\n
c = a &lt;&lt; 1; // c = a * 2^1 = 30\n
c = b &lt;&lt; 2; // c = b * 2^2 = -20\n

// сдвиг вправо - деление\n
c = a >> 3; // c = a / 2^3 = 1\n
c = b >> 1; // c = b / 2^1 = -3\n\n
10. Какое отличие между логическими операциями и поразрядными логическими операциями?\n
В логических операциях сравнивается значение двух операндов целиком. Каждый из операндов может иметь значение true или false. Язык C++ допускает сравнение операндов, которые являются целыми числами. В этом случае целочисленное значение 0 соответствует значению false, а ненулевое (любое другое) значение соответствует значению true.\n
Поразрядные логические операции работают строго с битами любого операнда. Бит может иметь 2 значения: 0 или 1. Поэтому, вычислению подлежат соответствующие биты каждого операнда а не значение операнда в целом.\n\n
11. Как в C++ реализовать логическую операцию XOR?\n
Как известно, язык C++ не содержит встроенной логической операции XOR (исключающее «ИЛИ»).\n
Ниже приведен фрагмент кода, который реализует операцию XOR с помощью использования операций &amp;&amp; (AND), || (OR), ! (NOT).\n
// реализация операции XOR через операции &amp;&amp; (AND), || (OR), ! (NOT)\n
bool x, y;\n
bool res;\n

...\n

res = (x || y) &amp;&amp; !(x &amp;&amp; y);\n

...\n
В вышеприведенном программном коде:\n
•  x, y – переменные, для которых вычисляется операция XOR;\n
•  res – переменная, которая есть результатом вычисления.\n

</item>
 <!--4--><item>4.УСЛОВНЫЙ ОПЕРАТОР. ОПЕРАТОР МНОЖЕСТВЕННОГО ВЕТВЛЕНИЯ (ВЫБОРА).\n\n\n
Условные операторы if и switch в C++\n
Одна из основных конструкций алгоритма — разветвляющийся процесс. Он реализован в языке C++ двумя условными операторами: if и switch. Рассмотрим каждый из них.\n\n

Условный оператор if\n
Для организации вычислений в зависимости от какого-либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом:\n
if (условие) оператор_1; else оператор_2;\n
Здесь условие — это логическое выражение, переменная или константа.\n
Работает условный оператор следующем образом. Сначала вычисляется значения выражения, записанного в виде условия. Если оно имеет значение истина (true), выполняется оператор_1. В противном случае (значение ложное (false) ) оператор_2.\n
Например, чтобы сравнить значения переменных a и b нужно написать следующую часть программного кода:\n

int a, b;\n
cin>>a;\n
cin>>b;\n
if (a==b) cout&lt;&lt;"a equal b";\n
else cout&lt;&lt;"a not equal b";\n
Не путайте знак проверки равенства == и оператор присваивания =\n
Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.\n
if (условие) { оператор_1; оператор_2; … }\n
else { оператор_1; оператор_2; … }\n
Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.\n\n
Оператор варианта switch\n
Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
default: операторы; break;\n
}\n
Оператор работает следующем образом. Вычисляется значение выражения. Затем выполняются операторы, помеченные значением, совпадающим со значением выражения. То есть если, выражение принимает значение_1, то выполняются операторы_1 и т.д.. Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.\n
Ветвь default может отсутствовать, тогда оператор имеет вид:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
}\n
Оператор break необходим для того, чтобы осуществить выход из операторы switch. Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.\n
Некоторые вещи могут быть непонятны, и поэтому для ясности давайте рассмотрим пример несложной задачи.\n\n
Задача\n
Необходимо вывести на название дня недели, соответствующее заданному числу D, при условии, что в месяце 31 день и 1-е число — понедельник.\n
Для решения задачи воспользуемся операцией %, позволяющей вычислить остаток от деления двух чисел. Программа будет выводить название дня недели в зависимости от заданного нами числа.\n

#include "stdafx.h"\n
#include &lt;iostream>\n
using namespace std;\n
int main ()\n
{\n
unsigned int D, R; //описанны целые положительные числа\n
cout&lt;&lt;"D=";\n
cin>>D;\n
R=D%7;\n
switch (R)\n
{\n
case 1: cout&lt;&lt;"Monday \n"; break;\n
case 2: cout&lt;&lt;"Theusday \n"; break;\n
case 3: cout&lt;&lt;"Wednesday \n"; break;\n
case 4: cout&lt;&lt;"Thursday \n"; break;\n
case 5: cout&lt;&lt;"Friday \n"; break;\n
case 6: cout&lt;&lt;"Saturday \n"; break;\n
case 0: cout&lt;&lt;"Sunday \n"; break;\n
}\n
system ("pause");\n
return 0;\n
}\n
</item>
 <!--5--><item>5.ЦИКЛИЧЕСКИЕ ОПЕРАТОРЫ.\n\n\n\n\n
Циклы в C++\n
Иногда необходимо повторять одно и то же действие несколько раз подряд. Для этого используют циклы. В этом уроке мы научимся программировать циклы на C++, после чего посчитаем сумму всех чисел от 1 до 1000.\n
Цикл for\n
Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит примерно так:\n
for (действие до начала цикла;\n
     условие продолжения цикла;\n
     действия в конце каждой итерации цикла) {\n
         инструкция цикла;\n
         инструкция цикла 2;\n
         инструкция цикла N;\n
}\n
Итерацией цикла называется один проход этого цикла\n
Существует частный случай этой записи, который мы сегодня и разберем:\n
for (счетчик = значение; счетчик &lt; значение; шаг цикла) {\n
    тело цикла;\n
}\n
Счетчик цикла — это переменная, в которой хранится количество проходов данного цикла.\n
Описание синтаксиса\n
•	Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.\n
•	Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.\n
•	Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.\n
Пример кода\n
Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    int i; // счетчик цикла\n
    int sum = 0; // сумма чисел от 1 до 1000.\n
    setlocale(0, "");\n
    for (i = 1; i &lt;= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.\n
    {\n
        sum = sum + i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную работу за нас.\n
Заметьте, что конечное значение счетчика я задал нестрогим неравенством ( &lt;= — меньше либо равно), поскольку, если бы я поставил знак меньше, то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. Это довольно важный момент, т.к. здесь новички часто допускают ошибки, особенно при работе с массивами (о них будет рассказано в следующем уроке). Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1.\n
В теле цикла, при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент — в начале программы я присвоил переменной sum значение нуля. Если бы я этого не сделал, программа вылетела вы в сегфолт. При объявлении переменной без ее инициализации что эта переменная будет хранить «мусор».\n
Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, такие как gcc, инициализирует переменную нулем при ее объявлении.\n
Цикл while\n
Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.\n
while (Условие) {\n
    Тело цикла;\n
}\n
Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно.\n
Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    while (i &lt; 1000)\n
    {\n
        i++;\n
        sum += i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
После компиляции программа выдаст результат, аналогичный результату работы предыдущей программы. Но поясним несколько важных моментов. Я задал строгое неравенство в условии цикла и инициализировал счетчик i нулем, так как в цикле while происходит на одну итерацию больше, потому он будет выполняться, до тех пор, пока значение счетчика перестает удовлетворять условию, но данная итерация все равно выполнится. Если бы мы поставили нестрогое неравенство, то цикл бы закончился, когда переменная i стала бы равна 1001 и выполнилось бы на одну итерацию больше.\n
Теперь давайте рассмотрим по порядку исходный код нашей программы. Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел.
В данном случае мы обязательно должны присвоить счетчику цикла какое-либо значение, т.к. в предыдущей программе мы это значение присваивали внутри цикла for, здесь же, если мы не инициализируем счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется — сегфолт практически неизбежен.\n
Затем мы описываем условие цикла — «пока переменная i меньше 1000 — выполняй цикл». При каждой итерации цикла значение переменной-счетчика i увеличивается на единицу внутри цикла.\n
Когда выполнится 1000 итераций цикла, счетчик станет равным 999 и следующая итерация уже не выполнится, поскольку 1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i.
После окончания выполнения цикла, выводим сообщение с ответом.\n
Цикл do while\n
Цикл do while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do while один проход цикла будет выполнен независимо от условия. Решение задачи на поиск суммы чисел от 1 до 1000, с применением цикла do while.\n
#include &lt;iostream>\n
using namespace std;\n

int main ()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    do {// выполняем цикл.\n
        i++;\n
        sum += i;\n
    } while (i &lt; 1000); // пока выполняется условие.\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Принципиального отличия нет, но если присвоить переменной i значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход.
</item>
 <!--6--><item>6.СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ (СУБД).\n\n\n\n\n
Система управления базами данных сокр. СУБД (англ. Database Management System, сокр. DBMS) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.\n
СУБД — комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.\n\n
Основные функции СУБД\n
1.	управление данными во внешней памяти (на дисках);\n
2.	управление данными в оперативной памяти с использованием дискового кэша;\n
3.	журнализация изменений, резервное копирование и восстановление базы данных после сбоев;\n
4.	поддержка языков БД (язык определения данных, язык манипулирования данными).\n\n
Состав СУБД\n
Обычно современная СУБД содержит следующие компоненты:\n
•	ядро, которое отвечает за управление данными во внешней и оперативной памяти и журнализацию;\n
•	процессор языка базы данных, обеспечивающий оптимизацию запросов на извлечение и изменение данных и создание, как правило, машинно-независимого исполняемого внутреннего кода;\n
•	подсистему поддержки времени исполнения, которая интерпретирует программы манипуляции данными, создающие пользовательский интерфейс с СУБД;\n
•	сервисные программы (внешние утилиты), обеспечивающие ряд дополнительных возможностей по обслуживанию информационной системы.\n\n
Классификации СУБД\n
По модели данных\n
Примеры:\n
•	Иерархические\n
•	Сетевые\n
•	Реляционные\n
•	Объектно-ориентированные\n
•	Объектно-реляционные\n\n
По степени распределённости\n
•	Локальные СУБД (все части локальной СУБД размещаются на одном компьютере)\n
•	Распределённые СУБД (части СУБД могут размещаться не только на одном, но на двух и более компьютерах).\n
По способу доступа к БД\n
•	Файл-серверные\n
В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок.\n
Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера.\n
Недостатки: потенциально высокая загрузка локальной сети; затруднённость или невозможность централизованного управления; затруднённость или невозможность обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.\n
На данный момент файл-серверная технология считается устаревшей, а её использование в крупных информационных системах — недостатком.\n
Примеры: Microsoft Access, Paradox, dBase, FoxPro, Visual FoxPro.\n
•	Клиент-серверные\n
Клиент-серверная СУБД располагается на сервере вместе с БД и осуществляет доступ к БД непосредственно, в монопольном режиме. Все клиентские запросы на обработку данных обрабатываются клиент-серверной СУБД централизованно.\n
Недостаток клиент-серверных СУБД состоит в повышенных требованиях к серверу.\n
Достоинства: потенциально более низкая загрузка локальной сети; удобство централизованного управления; удобство обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность.\n
Примеры: Oracle Database, Firebird, Interbase, IBM DB2, Informix, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Caché, ЛИНТЕР.\n
•	Встраиваемые\n
Встраиваемая СУБД — СУБД, которая может поставляться как составная часть некоторого программного продукта, не требуя процедуры самостоятельной установки. Встраиваемая СУБД предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети.\n
Физически встраиваемая СУБД чаще всего реализована в виде подключаемой библиотеки. Доступ к данным со стороны приложения может происходить через SQL либо через специальные программные интерфейсы.\n
Примеры: OpenEdge, SQLite, BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact, ЛИНТЕР.\n
Стратегии работы с внешней памятью\n
СУБД с непосредственной записью\n
В таких СУБД все изменённые блоки данных незамедлительно записываются во внешнюю память при поступлении сигнала подтверждения любой транзакции. Такая стратегия используется только при высокой эффективности внешней памяти.\n
СУБД с отложенной записью\n
В таких СУБД изменения аккумулируются в буферах внешней памяти до наступления любого из следующих событий:\n
•	Контрольная точка.\n
•	Нехватка пространства во внешней памяти, отведенного под журнал. СУБД создаёт контрольную точку и начинает писать журнал сначала, затирая предыдущую информацию.\n
•	Останов. СУБД ждёт, когда всё содержимое всех буферов внешней памяти будет перенесено во внешнюю память, после чего делает отметки, что останов базы данных выполнен корректно.\n
•	Нехватка оперативной памяти для буферов внешней памяти.\n
Такая стратегия позволяет избежать частого обмена с внешней памятью и значительно увеличить эффективность работы СУБД.\n

</item>
 <!--7--><item>7.ПРОЕКТИРОВАНИЕ СТРУКТУРЫ БАЗЫ ДАННЫХ.\n\n\n\n
Проектирование баз данных — процесс создания схемы базы данных и определения необходимых ограничений целостности.\n

Основные задачи проектирования баз данных\n
Основные задачи:\n
•	Обеспечение хранения в БД всей необходимой информации.\n
•	Обеспечение возможности получения данных по всем необходимым запросам.\n
•	Сокращение избыточности и дублирования данных.\n
•	Обеспечение целостности базы данных.\n\n

Основные этапы проектирования баз данных\n
Концептуальное (инфологическое) проектирование\n

Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель», «концептуальная модель» и «инфологическая модель» являются синонимами. Кроме того, в этом контексте равноправно могут использоваться слова «модель базы данных» и «модель предметной области» (например, «концептуальная модель базы данных» и «концептуальная модель предметной области»), поскольку такая модель является как образом реальности, так и образом проектируемой базы данных для этой реальности.\n
Конкретный вид и содержание концептуальной модели базы данных определяется выбранным для этого формальным аппаратом. Обычно используются графические нотации, подобные ER-диаграммам.\n
Чаще всего концептуальная модель базы данных включает в себя:\n
•	описание информационных объектов или понятий предметной области и связей между ними.\n
•	описание ограничений целостности, то есть требований к допустимым значениям данных и к связям между ними.\n
Логическое (даталогическое) проектирование\n
Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных, например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.\n
Преобразование концептуальной модели в логическую модель, как правило, осуществляется по формальным правилам. Этот этап может быть в значительной степени автоматизирован.\n
На этапе логического проектирования учитывается специфика конкретной модели данных, но может не учитываться специфика конкретной СУБД.\n
Физическое проектирование\n
Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т. п. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и т. д.\n
Результатом физического проектирования логической схемы выше на языке SQL может являться следующий скрипт:\n
CREATE TABLE IF NOT EXISTS Department ( -- Факультет\n
  id INT NOT NULL,\n
  name VARCHAR(45),\n
  PRIMARY KEY (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Group (\n
  id INT NOT NULL,\n
  name VARCHAR(45) ,\n
  depart_id INT NOT NULL,\n
  UNIQUE INDEX depart_id_UNIQUE (depart_id ASC),\n
  PRIMARY KEY (id, depart_id),\n
  CONSTRAINT depart_fk\n
    FOREIGN KEY (depart_id)\n
    REFERENCES Department (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Student (\n
  first_name VARCHAR(16) NOT NULL,\n
  last_name VARCHAR(45) NOT NULL,\n
  email VARCHAR(255),\n
  group_id INT NOT NULL,\n
  PRIMARY KEY (last_name, first_name, group_id),\n
  INDEX group_fk_idx (group_id ASC),\n
  CONSTRAINT group_fk\n
    FOREIGN KEY (group_id) REFERENCES Group (id)\n
);\n\n
Нормализация\n
При проектировании реляционных баз данных обычно выполняется так называемая нормализация.\n
Модели «сущность-связь»\n
Модель «сущность-связь» (англ. “Entity-Relationship model”), или ER-модель, предложенная П. Ченом в 1976 г., является наиболее известным представителем класса семантических (концептуальных, инфологических) моделей предметной области. ER-модель обычно представляется в графической форме, с использованием оригинальной нотации П. Чена, называемой ER-диаграмма, либо с использованием других графических нотаций (Crow’s Foot, Information Engineering и др.).\n
Основные преимущества ER-моделей:\n
•	наглядность;\n
•	модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;\n
•	ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).\n
Основные элементы ER-моделей:\n
•	объекты (сущности);\n
•	атрибуты объектов;\n
•	связи между объектами.\n
Сущность — объект предметной области, имеющий атрибуты.\n
Связь между сущностями характеризуется:\n
•	типом связи (1:1, 1:N, N:М);\n
•	классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.\n
Семантические модели\n
Семантическая модель (концептуальная модель, инфологическая модель) — модель предметной области, предназначенная для представления семантики предметной области на самом высоком уровне абстракции. Это означает, что устранена или минимизирована необходимость использовать понятия «низкого уровня», связанные со спецификой физического представления и хранения данных.\n
Семантическое моделирование стало предметом интенсивных исследований с конца 1970-х годов. Основным побудительным мотивом подобных исследований (то есть проблемой, которую пытались разрешить исследователи) был следующий факт. Дело в том, что системы баз данных обычно обладают весьма ограниченными сведениями о смысле хранящихся в них данных. Чаще всего они позволяют лишь манипулировать данными определенных простых типов и определяют некоторые простейшие ограничения целостности, наложенные на эти данные. Любая более сложная интерпретация возлагается на пользователя. Однако было бы замечательно, если бы системы могли обладать немного более широким объемом сведений и несколько интеллектуальнее отвечать на запросы пользователя, а также поддерживать более сложные (то есть более высокоуровневые) интерфейсы пользователя.\n
Идеи семантического моделирования могут быть полезны как средство проектирования базы данных даже при отсутствии их непосредственной поддержки в СУБД.\n
Наиболее известным представителем класса семантических моделей является модель «сущность-связь» (ER-модель).\n

</item>
 <!--8--><item>8.ВИДЫ МОДЕЛЕЙ ДАННЫХ.\n\n\n\n\n\n
Виды моделей данных БД\n
Модели организации данных. Сетевые, реляционные, иерархические модели.\n
Ядром любой базы данных является модель данных. С помощью модели данных могут быть представлены объекты предметной области и взаимосвязи между ними.\n
Модель данных - это совокупность структур данных и операций их обработки. Рассмотрим три основных типа моделей данных: иерархическую, сетевую и реляционную.\n
Виды моделей данных БД\n
Иерархическую модель БД изображают в виде дерева. Элементы дерева вершины представляют совокупность данных, например логические записи.\n
Иерархическая модель представляет собой совокупность элементов, расположенных в порядке их подчинения от общего к частному и образующих перевернутое по структуре дерево (граф).\n
К основным понятиям иерархической структуры относятся уровень, узел и связь. Узел – это совокупность атрибутов данных, описывающих некоторый объект. На схеме иерархического дерева узлы представляются вершинами графа. Каждый узел на более низком уровне связан только с одним узлом, находящимся на более высоком уровне. Иерархическое дерево имеет только одну вершину, не подчиненную никакой другой вершине и находящуюся на самом верхнем - первом уровне. Зависимые (подчиненные) узлы находятся на втором, третьем и т. д. уровнях. Количество деревьев в базе данных определяется числом корневых записей. К каждой записи базы данных существует только один иерархический путь от корневой записи.\n
Сетевые модели БД соответствуют более широкому классу объектов управления, хотя требуют для своей организации и дополнительных затрат.\n
В сетевой структуре при тех же основных понятиях (уровень, узел, связь) каждый элемент может быть связан с любым другим элементом.\n
Реляционная модель БД представляет объекты и взаимосвязи между ними в виде таблиц, а все операции над данными сводятся к операциям над этими таблицами. На этой модели базируются практически все современные СУБД. Эта модель более понятна, "прозрачна" для конечного пользователя организации данных.\n
Реляционная модель данных объекты и связи между ними представляет в виде таблиц, при этом связи тоже рассматриваются как объекты. Все строки, составляющие таблицу в реляционной базе данных, должны иметь первичный ключ. Все современные средства СУБД поддерживают реляционную модель данных.\n
Эта модель характеризуются простотой структуры данных, удобным для пользователя табличным представлением и возможностью использования формального аппарата алгебры отношений и реляционного исчисления для обработки данных.\n
Каждая реляционная таблица представляет собой двумерный массив и обладает следующими свойствами:\n
1. Каждый элемент таблицы соответствует одному элементу данных.\n
2. Все столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину.\n
3. Каждый столбец имеет уникальное имя.\n
4. Одинаковые строки в таблице отсутствуют.\n
5. Порядок следования строк и столбцов может быть произвольным.\n
В последние годы все большее признание и развитие получают объектно-ориентированные базы данных (ООБД), толчок к появлению которых дали объектно-ориентированное программирование и использование персональных компьютеров для обработки и представления практически всех форм информации, воспринимаемых человеком. В ООБД модель данных более близка сущностям реального мира. Объекты можно сохранить и использовать непосредственно, не раскладывая их по таблицам.\n
</item>
 <!--9--><item>9.СОЗДАНИЕ БАЗЫ ДАННЫХ. ПРИМЕРЫ В СРЕДЕ ACCESS.\n\n\n\n\n
Создание базы данных в MS Access: пошаговая инструкция\n
СОДЕРЖАНИЕ\n
•	Описание MS Access\n
•	Определения основных понятий\n
•	Создание БД\n
•	Создание и заполнение таблиц\n
•	Создание и редактирование схем данных\n
•	Выполнение запросов\n
•	Создание формы\n
•	Формирование отчета\n
В современном мире нужны инструменты, которые бы позволяли хранить, систематизировать и обрабатывать большие объемы информации, с которыми сложно работать в Excel или Word.\n
Подобные хранилища используются для разработки информационных сайтов, интернет-магазинов и бухгалтерских дополнений. Основными средствами, реализующими данный подход, являются MS SQL и MySQL.\n
Продукт от Microsoft Office представляет собой упрощенную версию в функциональном плане и более понятную для неопытных пользователей. Давайте рассмотрим пошагово создание базы данных в Access.\n\n

Описание MS Access\n
Microsoft Access – это система управления базами данных (СУБД), реализующая полноценный графический интерфейс пользователя, принцип создания сущностей и связей между ними, а также структурный язык запросов SQL. Единственный минус этой СУБД – невозможность работать в промышленных масштабах. Она не предназначена для хранения огромных объемов данных. Поэтому MS Access используется для небольших проектов и в личных некоммерческих целях.\n
Но прежде чем показывать пошагово создание БД, нужно ознакомиться с базовыми понятиями из теории баз данных.\n\n
Определения основных понятий\n
Без базовых знаний об элементах управления и объектах, использующихся при создании и конфигурации БД, нельзя успешно понять принцип и особенности настройки предметной области. Поэтому сейчас я постараюсь простым языком объяснить суть всех важных элементов. Итак, начнем:\n
•	Предметная область – множество созданных таблиц в базе данных, которые связаны между собой с помощью первичных и вторичных ключей.\n
•	Сущность – отдельная таблица базы данных.\n
•	Атрибут – заголовок отдельного столбца в таблице.\n
•	Кортеж – это строка, принимающая значение всех атрибутов.\n
•	Первичный ключ – это уникальное значение (id), которое присваивается каждому кортежу.\n
•	Вторичный ключ таблицы «Б» – это уникальное значение таблицы «А», использующееся в таблице «Б».\n
•	SQL запрос – это специальное выражение, выполняющее определенное действие с базой данных: добавление, редактирование, удаление полей, создание выборок.\n
Теперь, когда в общих чертах есть представление о том, с чем мы будем работать, можно приступить к созданию БД.\n\n
Создание БД\n
Для наглядности всей теории создадим тренировочную базу данных «Студенты-Экзамены», которая будет содержать 2 таблицы: «Студенты» и «Экзамены». Главным ключом будет поле «Номер зачетки», т.к. данный параметр является уникальным для каждого студента. Остальные поля предназначены для более полной информации об учащихся.\n
Итак, выполните следующее:\n
•	Запустите MS Access.\n
•	Нажмите на кнопку «Новая база данных».\n
•	В появившемся окне введите название БД и выберите «Создать».\n

Все, теперь осталось только создать, заполнить и связать таблицы. Переходите к следующему пункту.\n\n
Создание и заполнение таблиц\n
После успешного создания БД на экране появится пустая таблица. Для формирования ее структуры и заполнения выполните следующее:\n
1.	Нажмите ПКМ по вкладке «Таблица1» и выберите «Конструктор».\n

2.	Теперь начинайте заполнять названия полей и соответствующий им тип данных, который будет использоваться.\n

Внимание! Первым полем принято устанавливать уникальное значение (первичный ключ). Для него предпочтительно числовое значение.\n
1.	После создания необходимых атрибутов сохраните таблицу и введите ее название.\n
2.	Снова нажмите ПКМ по вкладке с уже новым название и выберите «Режим таблицы».\n

3.	Заполните таблицу необходимыми значениями.\n

Совет! Для тонкой настройки формата данных перейдите на ленте во вкладку «Режим таблицы» и обратите внимание на блок «Форматирование и тип данных». Там можно кастомизировать формат отображаемых данных.\n\n
Создание и редактирование схем данных\n
Перед тем, как приступить к связыванию двух сущностей, по аналогии с предыдущим пунктом нужно создать и заполнить таблицу «Экзамены». Она имеет следующие атрибуты: «Номер зачетки», «Экзамен1», «Экзамен2», «Экзамен3».\n
Для выполнения запросов нужно связать наши таблицы. Иными словами, это некая зависимость, которая реализуется с помощью ключевых полей. Для этого нужно:\n
1.	Перейти во вкладку «Работа с базами данных».\n
2.	Нажать на кнопку «Схема данных».\n
3.	Если схема не была создана автоматически, нужно нажать ПКМ на пустой области и выбрать «Добавить таблицы».\n

4.	Выберите каждую из сущностей, поочередно нажимая кнопку «Добавить».\n
5.	Нажмите кнопку «ОК».\n
Конструктор должен автоматически создать связь, в зависимости от контекста. Если же этого не случилось, то:\n
3.	Перетащите общее поле из одной таблицы в другую.\n
4.	В появившемся окне выберите необходимы параметры и нажмите «ОК».\n

5.	Теперь в окне должны отобразиться миниатюры двух таблиц со связью (один к одному).\n

Выполнение запросов\n
Что же делать, если нам нужны студенты, которые учатся только в Москве? Да, в нашей БД только 6 человек, но что, если их будет 6000? Без дополнительных инструментов узнать это будет сложно.\n
Именно в этой ситуации к нам на помощь приходят SQL запросы, которые помогают изъять лишь необходимую информацию.\n\n
Виды запросов\n
SQL синтаксис реализует принцип CRUD (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить»). Т.е. с помощью запросов вы сможете реализовать все эти функции.\n\n
На выборку\n
В этом случае в ход вступает принцип «прочесть». Например, нам нужно найти всех студентов, которые учатся в Харькове. Для этого нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL.\n

4.	В текстовое поле введите команду: SELECT * FROM Студенты WHERE Адрес = «Харьков»; где «SELECT *» означает, что выбираются все студенты, «FROM Студенты» — из какой таблицы, «WHERE Адрес = «Харьков»» — условие, которое обязательно должно выполняться.\n
5.	Нажмите кнопку «Выполнить».\n

6.	На выходе мы получаем результирующую таблицу.\n

А что делать, если нас интересуют студенты из Харькова, стипендии у которых больше 1000? Тогда наш запрос будет выглядеть следующим образом:\n
SELECT * FROM Студенты WHERE Адрес = «Харьков» AND Стипендия > 1000;\n
а результирующая таблица примет следующий вид:\n\n

На создание сущности\n
Кроме добавления таблицы с помощью встроенного конструктора, иногда может потребоваться выполнение этой операции с помощью SQL запроса. В большинстве случаев это нужно во время выполнения лабораторных или курсовых работ в рамках университетского курса, ведь в реальной жизни необходимости в этом нет. Если вы, конечно, не занимаетесь профессиональной разработкой приложений. Итак, для создания запроса нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL, после чего в текстовое поле введите команду:\n
CREATE TABLE Преподаватели\n
(КодПреподавателя INT PRIMARY KEY,\n
Фамилия CHAR(20),\n
Имя CHAR (15),\n
Отчество CHAR (15),\n
Пол CHAR (1),\n
Дата_рождения DATE,\n
Основной_предмет CHAR (200));\n
где «CREATE TABLE» означает создание таблицы «Преподаватели», а «CHAR», «DATE» и «INT» — типы данных для соответствующих значений.\n

1.	Кликните по кнопке «Выполнить».\n
2.	Откройте созданную таблицу.\n

Внимание! В конце каждого запроса должен стоять символ «;». Без него выполнение скрипта приведет к ошибке.\n
На добавление, удаление, редактирование\n
Здесь все гораздо проще. Снова перейдите в поле для создания запроса и введите следующие команды:\n
1.	для заполнения кортежа:\n
INSERT INTO Преподаватели\n
VALUES (1, ‘Иванова’, ‘Иванна’, ‘Ивановна’, ‘Ж’, ’05-06-1981′, ‘География’);\n
2.	для редактирования записи:\n
UPDATE Преподаватели SET Имя = ‘Анна’;\n

3.	для удаления:\n
DELETE * FROM Преподаватели WHERE Имя=’Анна’;.\n\n

Создание формы\n
При огромном количестве полей в таблице заполнять базу данных становится сложно. Можно случайно пропустить значение, ввести неверное или другого типа. В данной ситуации на помощь приходят формы, с помощью которых можно быстро заполнять сущности, а вероятность допустить ошибку минимизируется. Для этого потребуются следующие действия:\n
4.	Откройте интересующую таблицу.\n
5.	Перейдите во вкладку «Создание».\n
6.	Нажмите на необходимый формат формы из блока «Формы».\n

Совет! Рекомендуется использовать «Разделенную форму» – кроме самого шаблона, в нижней части будет отображаться миниатюра таблицы, которая сделает процесс редактирования еще более наглядным.\n
7.	С помощью навигационных кнопок переходите к следующей записи и вносите изменения.\n

Все базовые функции MS Access 2007 мы уже рассмотрели. Остался последний важный компонент – формирование отчета.\n\n
Формирование отчета\n
Отчет – это специальная функция MS Access, позволяющая оформить и подготовить для печати данные из базы данных. В основном это используется для создания товарных накладных, бухгалтерских отчетов и прочей офисной документации.\n
Если вы никогда не сталкивались с подобной функцией, рекомендуется воспользоваться встроенным «Мастером отчетов». Для этого сделайте следующее:\n
•	Перейдите во вкладку «Создание».\n
•	Нажмите на кнопку «Мастер отчетов» в блоке «Отчеты».\n

•	Выберите интересующую таблицу и поля, нужные для печати.\n

•	Добавьте необходимый уровень группировки.\n

•	Выберите тип сортировки каждого из полей.\n

•	Настройте вид макета для отчета.\n

•	Выберите подходящий стиль оформления.\n

Внимание! В официальных документах допускается только стандартный стиль оформления.\n
•	Просмотрите созданный отчет.\n

Если отображение вас не устраивает, его можно немного подкорректировать. Для этого:\n
1.	Нажмите ПКМ на вкладке отчета и выберите «Конструктор».\n
2.	Вручную расширьте интересующие столбцы.\n
3.	Сохраните изменения.\n
</item>
 <!--10--><item>10.МОДЕЛИ И ИХ СВОЙСТВА. ДАТА MINING.\n\n\n\n\n\n\n\n
Основные понятия\n
Знания есть не только у человека, но и у накопленных данных, которые подвергаются анализу. Такие знания содержатся в огромной объеме информации, которую человек не в силах исследовать самостоятельно. В связи с этим существует вероятность пропустить гипотезы, которые могут принести значительную выгоду.\n
Для обнаружения «скрытых» знаний применяется специальные методы автоматического анализа, при помощи которых приходиться практически добывать знания из «завалов» информации. За этим направлением закрепился термин «добыча данных (DataMining)» или «интеллектуальный анализ данных».\n
Существует множество определений DataMining, которые друг друга дополняют. Вот некоторые из них.\n
DataMining – это процесс обнаружения в базах данных нетривиальных и практически полезных закономерностей. (BaseGroup)\n
DataMining – это процесс выделения, исследования и моделирования больших объемов данных для обнаружения неизвестных до этого структур(patterns) с целью достижения преимуществ в бизнесе. (SAS Institute)\n
DataMining – это процесс, цель которого – обнаружить новые значимые корреляции, образцы и тенденции в результате просеивания большого объема хранимых данных с использованием методик распознавания образцов плюс применение статистических и математических методов. (GartnerGroup)\n
DataMining – это исследование и обнаружение «машиной» (алгоритмами, средствами искусственного интеллекта) в сырых данных скрытых знаний, которые ранее не были известны, нетривиальны, практически полезны, доступны для интерпретации человеком. (А.Баргесян «Технологии анализа данных»)\n
DataMining – это процесс обнаружения полезных знаний о бизнесе. (Н.М.Абдикеев «КБА»)\n
Свойства обнаруживаемых знаний\n
Рассмотрим свойства обнаруживаемых знаний.\n
1.	Знания должны быть новые, ранее неизвестные. Затраченные усилия на открытие знаний, которые уже известны пользователю, не окупаются. Поэтому ценность представляют именно новые, ранее неизвестные знания.\n
2.	Знания должны быть нетривиальны. Результаты анализа должны отражать неочевидные, неожиданные закономерности в данных, составляющие так называемые скрытые знания. Результаты, которые могли бы быть получены более простыми способами (например, визуальным просмотром), не оправдывают привлечение мощных методов DataMining.\n
3.	Знания должны быть практически полезны. Найденные знания должны быть применимы, в том числе и на новых данных, с достаточно высокой степенью достоверности. Полезность заключается в том, чтобы эти знания могли принести определенную выгоду при их применении.\n
4.	Знания должны быть доступны для понимания человеку. Найденные закономерности должны быть логически объяснимы, в противном случае существует вероятность, что они являются случайными. Кроме того, обнаруженные знания должны быть представлены в понятном для человека виде.\n
В DataMining для представления полученных знаний служат модели. Виды моделей зависят от методов их создания. Наиболее распространенными являются: правила, деревья решений, кластеры и математические функции.\n\n
Задачи DataMining\n
Напомним, что в основу технологии DataMining положена концепция шаблонов, представляющих собой закономерности. В результате обнаружения этих, скрытых от невооруженного глаза закономерностей решаются задачи DataMining. Различным типам закономерностей, которые могут быть выражены в форме, понятной человеку, соответствуют определенные задачи DataMining.\n
Единого мнения относительно того, какие задачи следует относить к DataMining, нет. Большинство авторитетных источников перечисляют следующие: классификация,
кластеризация, прогнозирование, ассоциация, визуализация, анализ и обнаружение отклонений, оценивание, анализ связей, подведение итогов.\n
Цель описания, которое следует ниже, - дать общее представление о задачах DataMining, сравнить некоторые из них, а также представить некоторые методы, с помощью которых эти задачи решаются. Наиболее распространенные задачи DataMining - классификация,кластеризация, ассоциация, прогнозирование и визуализация. Таким образом, задачи подразделяются по типам производимой информации, это наиболее общая классификация задач DataMining.\n\n
Классификация (Classification)\n
Задача разбиения множества объектов или наблюдений на априорно заданные группы, называемые классами, внутри каждой из которых они предполагаются похожими друг на друга, имеющими примерно одинаковые свойства и признаки. При этом решение получается на основе анализа значений атрибутов (признаков).\n
Классификация является одной из важнейших задач DataMining. Она применяется в маркетинге при оценке кредитоспособности заемщиков, определении лояльности клиентов, распознавании образов, медицинской диагностике и многих других приложениях. Если аналитику известны свойства объектов каждого класса, то когда новое наблюдение относится к определенному классу, данные свойства автоматически распространяются и на него.\n
Если число классов ограничено двумя, то имеет место бинарная классификация, к которой могут быть сведены многие более сложные задачи. Например, вместо определения таких степеней кредитного риска, как «Высокий», «Средний» или «Низкий», можно использовать всего две - «Выдать» или «Отказать».\n
Для классификации в DataMining используется множество различных моделей: нейронные сети, деревья решений, машины опорных векторов, метод k-ближайших соседей, алгоритмы покрытия и др., при построении которых применяется обучение с учителем, когда выходная переменная (метка класса) задана для каждого наблюдения. Формально классификация производится на основе разбиения пространства признаков на области, в пределах каждой из которых многомерные векторы рассматриваются как идентичные. Иными словами, если объект попал в область пространства, ассоциированную с определенным классом, он к нему и относится.\n\n
Кластеризация (Clustering)\n
Краткое описание. Кластеризация является логическим продолжением идеи классификации. Это задача более сложная, особенность кластеризации заключается в том, что классы объектов изначально не предопределены. Результатом кластеризации является разбиение объектов на группы.\n
Пример метода решения задачи кластеризации: обучение "без учителя" особого вида нейронных сетей - самоорганизующихся карт Кохонена.\n\n
Ассоциация (Associations)\n
Краткое описание. В ходе решения задачи поиска ассоциативных правил отыскиваются закономерности между связанными событиями в наборе данных.
Отличие ассоциации от двух предыдущих задач DataMining: поиск закономерностей осуществляется не на основе свойств анализируемого объекта, а между несколькими событиями, которые происходят одновременно. Наиболее известный алгоритм решения задачи поиска ассоциативных правил – алгоритм Apriori.\n\n
Последовательность (Sequence) или последовательная ассоциация (sequentialassociation)\n
Краткое описание. Последовательность позволяет найти временные закономерности между транзакциями. Задача последовательности подобна ассоциации, но ее целью является установление закономерностей не между одновременно наступающими событиями, а между событиями, связанными во времени (т.е. происходящими с некоторым определенным интервалом во времени). Другими словами, последовательность определяется высокой вероятностью цепочки связанных во времени событий. Фактически, ассоциация является частным случаем последовательности с временным лагом, равным нулю. Эту задачу DataMining также называют задачей нахождения последовательных шаблонов (sequentialpattern).\n
Правило последовательности: после события X через определенное время произойдет событие Y.\n
Пример. После покупки квартиры жильцы в 60% случаев в течение двух недель приобретают холодильник, а в течение двух месяцев в 50% случаев приобретается телевизор. Решение данной задачи широко применяется в маркетинге и менеджменте, например, при управлении циклом работы с клиентом (CustomerLifecycleManagement).\n\n

Регрессия, прогнозирование (Forecasting)\n
Краткое описание. В результате решения задачи прогнозирования на основе особенностей исторических данных оцениваются пропущенные или же будущие значения целевых численных показателей.\n
Для решения таких задач широко применяются методы математической статистики, нейронные сети и др.\n\n

Дополнительные задачи\n
Определение отклонений или выбросов (DeviationDetection), анализ отклонений или выбросов\n
Краткое описание. Цель решения данной задачи - обнаружение и анализ данных, наиболее отличающихся от общего множества данных, выявление так называемых нехарактерных шаблонов.\n\n
Оценивание (Estimation)\n
Задача оценивания сводится к предсказанию непрерывных значений признака.\n
Анализ связей (LinkAnalysis)\n
Задача нахождения зависимостей в наборе данных.\n
Визуализация (Visualization, GraphMining)\n
В результате визуализации создается графический образ анализируемых данных. Для решения задачи визуализации используются графические методы, показывающие наличие закономерностей в данных.\n
Пример методов визуализации - представление данных в 2-D и 3-D измерениях.\n\n
Подведение итогов (Summarization)\n
Задача, цель которой - описание конкретных групп объектов из анализируемого набора данных.\n
Достаточно близким к вышеупомянутой классификации является подразделение задач DataMining на следующие: исследования и открытия, прогнозирования и классификации, объяснения и описания.\n
Автоматическое исследование и открытие (свободный поиск)\n
Пример задачи: обнаружение новых сегментов рынка.\n
Для решения данного класса задач используются методы кластерного анализа.\n
Прогнозирование и классификация\n
Пример задачи: предсказание роста объемов продаж на основе текущих значений.\n
Методы: регрессия, нейронные сети, генетические алгоритмы, деревья решений.\n
Задачи классификации и прогнозирования составляют группу так называемого индуктивного моделирования, в результате которого обеспечивается изучение анализируемого объекта или системы. В процессе решения этих задач на основе набора данных разрабатывается общая модель или гипотеза.\n\n
Объяснение и описание\n
Пример задачи: характеристика клиентов по демографическим данным и историям покупок.\n
Методы: деревья решения, системы правил, правила ассоциации, анализ связей.\n
Если доход клиента больше, чем 50 условных единиц, и его возраст - более 30 лет, тогда класс клиента - первый.\n
Сравнение кластеризации и классификации\n
Характеристика	Классификация	Кластеризация\n
Контролируемость обучения	Контролируемое	Неконтролируемое\n
Стратегии	Обучение с учителем	Обучение без учителя\n
Наличие метки класса Обучающее множество сопровождается меткой, указывающей класс, к которому относится наблюдение	Метки класса обучающего
множества неизвестны\n
Основание для классификации	Новые данные классифицируются на основании обучающего множества	Дано множество данных с целью
установления существования классов или кластеров данных\n\n

Сферы применения DataMining\n
Следует отметить, что на сегодняшний день наибольшее распространение технология DataMining получила при решении бизнес-задач. Возможно, причина в том, что именно в этом направлении отдача от использования инструментов DataMining может составлять, по некоторым источникам, до 1000% и затраты на ее внедрение могут достаточно быстро окупиться.\n
Мы будем рассматривать четыре основные сферы применения технологии DataMining подробно: наука, бизнес, исследования для правительства и Web-направление.\n
Применение DataMining для решения бизнес-задач. Основные направления: банковское дело, финансы, страхование, CRM, производство, телекоммуникации, электронная коммерция, маркетинг, фондовый рынок и другие.\n
1.	Выдавать ли кредит клиенту\n
2.	Сегментация рынка\n
3.	Привлечение новых клиентов\n
4.	Мошенничество с кредитными карточками\n
Применение DataMining для решения задач государственного уровня. Основные направления: поиск лиц, уклоняющихся от налогов; средства в борьбе с терроризмом.\n
Применение DataMining для научных исследований. Основные направления: медицина, биология, молекулярная генетика и генная инженерия, биоинформатика, астрономия, прикладная химия, исследования, касающиеся наркотической зависимости, и другие.\n
Применение DataMining для решения Web-задач. Основные направления: поисковые машины (search engines), счетчики и другие.\n\n
Электронная коммерция\n
В сфере электронной коммерции DataMining применяется для формирования рекомендательных систем и решения задач классификации посетителей Web-сайтов.\n
Такая классификация позволяет компаниям выявлять определенные группы клиентов и проводить маркетинговую политику в соответствии с обнаруженными интересами и потребностями клиентов. Технология DataMining для электронной коммерции тесно связана с технологией WebMining.\n\n
Основные задачи DataMining в промышленном производстве:\n
· комплексный системный анализ производственных ситуаций;\n
· краткосрочный и долгосрочный прогноз развития производственных ситуаций;\n
· выработка вариантов оптимизационных решений;\n
· прогнозирование качества изделия в зависимости от некоторых параметров технологического процесса;\n
· обнаружение скрытых тенденций и закономерностей развития производственныхпроцессов;\n
· прогнозирование закономерностей развития производственных процессов;\n
· обнаружение скрытых факторов влияния;\n
· обнаружение и идентификация ранее неизвестных взаимосвязей между производственными параметрами и факторами влияния;\n
· анализ среды взаимодействия производственных процессов и прогнозирование изменения ее характеристик;\n
· выработку оптимизационных рекомендаций по управлению производственнымипроцессами;\n
· визуализацию результатов анализа, подготовку предварительных отчетов и проектов допустимых решений с оценками достоверности и эффективности возможных реализаций.\n\n
Маркетинг\n
В сфере маркетинга DataMining находит очень широкое применение.\n
Основные вопросы маркетинга "Что продается?", "Как продается?", "Кто является потребителем?"\n
В лекции, посвященной задачам классификации и кластеризации, подробно описано использование кластерного анализа для решения задач маркетинга, как, например, сегментация потребителей.\n
Другой распространенный набор методов для решения задач маркетинга - методы и алгоритмы поиска ассоциативных правил.\n
Также успешно здесь используется поиск временных закономерностей.\n\n
Розничная торговля\n
В сфере розничной торговли, как и в маркетинге, применяются:\n
· алгоритмы поиска ассоциативных правил (для определения часто встречающихся наборов товаров, которые покупатели покупают одновременно). Выявление таких правил помогает размещать товары на прилавках торговых залов, вырабатывать стратегии закупки товаров и их размещения на складах и т.д.\n
· использование временных последовательностей, например, для определения необходимых объемов запасов товаров на складе.\n
· методы классификации и кластеризации для определения групп или категорий клиентов, знание которых способствует успешному продвижению товаров.\n\n
Фондовый рынок\n
Вот список задач фондового рынка, которые можно решать при помощи технологии DataMining: · прогнозирование будущих значений финансовых инструментов и индикаторов по их прошлым значениям;\n
· прогноз тренда (будущего направления движения - рост, падение, флэт) финансового инструмента и его силы (сильный, умеренно сильный и т.д.);\n
· выделение кластерной структуры рынка, отрасли, сектора по некоторому набору характеристик;\n
· динамическое управление портфелем;\n
· прогноз волатильности;\n
· оценка рисков;\n
· предсказание наступления кризиса и прогноз его развития;\n
· выбор активов и др.\n
Кроме описанных выше сфер деятельности, технология DataMining может применяться в самых разнообразных областях бизнеса, где есть необходимость в анализе данных и накоплен некоторый объем ретроспективной информации.\n\n
Применение DataMining в CRM\n
Одно из наиболее перспективных направлений применения DataMining – использование данной технологии в аналитическом CRM.\n
CRM (CustomerRelationshipManagement) - управление отношениями с клиентами.\n
При совместном использовании этих технологий добыча знаний совмещается с "добычей денег" из данных о клиентах.\n
Важным аспектом в работе отделов маркетинга и отдела продаж является составление целостного представления о клиентах, информация об их особенностях, характеристиках, структуре клиентской базы. В CRM используется так называемое профилирование клиентов, дающее полное представление всей необходимой информации о клиентах.\n
Профилирование клиентов включает следующие компоненты: сегментация клиентов, прибыльность клиентов, удержание клиентов, анализ реакции клиентов. Каждый из этих компонентов может исследоваться при помощи DataMining, а анализ их в совокупности, как компонентов профилирования, в результате может дать те знания, которые из каждой отдельной характеристики получить невозможно.\n\n
WebMining\n
WebMining можно перевести как "добыча данных в Web".\n
Интеллект готов "открыть новую главу" в стремительном развитии электронного бизнеса. Способность определять интересы и предпочтения каждого посетителя, наблюдая за его поведением, является серьезным и критичным преимуществом конкурентной борьбы на рынке электронной коммерции.\n
Системы WebMining могут ответить на многие вопросы, например, кто из посетителей является потенциальным клиентом Web-магазина, какая группа клиентов Web-магазина приносит наибольший доход, каковы интересы определенного посетителя или группы посетителей.\n\n
</item>
 <!--11--><item>11.РЕЛЯЦИОННЫЕ ХРАНИЛИЩА ДАННЫХ (ROLAP).\n\n\n\n\n
ROLAP (реляционная OLAP) — OLAP-системы, которые имеют прямой доступ к существующим базам данных или используют данные, выгруженные в собственные локальные таблицы.\n
Общие сведения\n
Аналитические запросы в ROLAP строятся над виртуальным многомерным представлением данных, и их выполнение происходит на уровне реляционной базы данных, то есть выполняются SQL-запросы над реляционной системой. Основными составляющими архитектуры баз данных являются таблица фактов (fact table) и таблицы измерений (dimension tables). Таблица фактов является основной таблицей базы данных. В ней обычно содержатся сведения об объектах или событиях, совокупность которых будет подвергнута анализу. Таблицы измерений содержат постоянные либо редко изменяемые данные. Они содержат как минимум одно описательное поле и целочисленное ключевое поле для однозначной идентификации измеряемой величины. Таблица измерений обязательно должна находиться в отношении «один ко многим» с таблицей фактов; если каждое измерение находится в одной таблице измерений, то такая схема называется «звезда» (star schema). Если же хотя бы одно из измерений находится в нескольких взаимосвязанных таблицах, то такая схема построения называется «снежинка» (snowflake schema).\n
Условия применения\n
Если многомерная модель реализуется в виде реляционной базы данных, необходимо ее представлять как длинные и «узкие» таблицы фактов и сравнительно небольшие и «широкие» таблицы измерений. Таблицы фактов содержат числовые значения ячеек гиперкуба, а остальные таблицы определяют содержащую их многомерную совокупность измерений. Часть информации можно получать с помощью динамической агрегации данных, распределенных по нормализованным структурам, отличающимся по своей архитектуре от «звезды», но в этом случае включающие агрегацию запросы при высоконормализованной структуре БД могут выполняться довольно медленно. Представление многомерной информации с помощью звездообразных реляционных моделей устраняет проблему оптимизации хранения разреженных матриц, остро стоящую перед многомерными СУБД , в которых проблема разреженности решается специальным выбором схемы. Хотя для хранения каждой ячейки используется целая запись, включающая, кроме непосредственно значений, вторичные ключи — ссылки на таблицы измерений, несуществующие значения просто не включаются в таблицу фактов.\n
Оценка качества\n
ROLAP-системы имеют свои преимущества и недостатки в сравнении с многомерными системами.\n
Достоинства\n
•	реляционные СУБД могут работать с очень большими БД и имеют развитые функции администрирования. При использовании ROLAP размер хранилища не является настолько важным параметром, как в случае с MOLAP\n
•	при оперативной аналитической обработке содержимого хранилища данных инструменты ROLAP позволяют производить анализ непосредственно над хранилищем, ведь обычно корпоративные хранилища данных реализуются с помощью реляционных СУБД\n
•	при изменяющейся размерности задачи, когда изменения в структуру измерений вносятся достаточно часто, ROLAP системы с динамическим представлением размерности предстают наилучшим решением, так как в них такие манипуляции не требуют физической реорганизации БД.\n
•	Системы ROLAP могут функционировать на гораздо менее мощных клиентских станциях, поскольку основная вычислительная нагрузка приходится на сервер, где выполняются сложные аналитические SQL-запросы, формируемые системой\n
•	реляционные СУБД обеспечивают значительно более высокий уровень защиты данных и хорошие возможности разграничения прав доступа\n
Недостатки\n
•	Ограниченные возможности расчета значений функционального типа.\n
•	Меньшая производительность, чем у MOLAP. Для обеспечения сравнимой с MOLAP производительности реляционные системы требуют тщательной проработки схемы БД и специальной настройки индексов. Но в результате такой работы производительность хорошо настроенных реляционных систем при использовании схемы «звезда» сравнима с производительностью систем на основе многомерных БД.\n

</item>
 <!--12--><item>12.ТЕХНОЛОГИЯ OLAP. СУЩНОСТЬ МНОГОМЕРНОГО ПРЕДСТАВЛЕНИЯ ДАННЫХ.\n\n\n\n
OLAP (англ. online analytical processing, интерактивная аналитическая обработка) — технология обработки данных, заключающаяся в подготовке суммарной (агрегированной) информации на основе больших массивов данных, структурированных по многомерному принципу. Реализации технологии OLAP являются компонентами программных решений класса Business Intelligence.\n
Основоположник термина OLAP — Эдгар Кодд, предложил в 1993 году «12 правил аналитической обработки в реальном времени» (по аналогии с ранее сформулированными «12 правил для реляционных баз данных»).\n\n

Действие OLAP \n
Причина использования OLAP для обработки запросов — скорость. Реляционные базы данных хранят сущности в отдельных таблицах, которые обычно хорошо нормализованы. Эта структура удобна для операционных баз данных (системы OLTP), но сложные многотабличные запросы в ней выполняются относительно медленно.
OLAP-структура, созданная из рабочих данных, называется OLAP-куб. Куб создаётся из соединения таблиц с применением схемы звезды или схемы снежинки. В центре схемы звезды находится таблица фактов, которая содержит ключевые факты, по которым делаются запросы. Множественные таблицы с измерениями присоединены к таблице фактов. Эти таблицы показывают, как могут анализироваться агрегированные реляционные данные. Количество возможных агрегирований определяется количеством способов, которыми первоначальные данные могут быть иерархически отображены.\n
Например, все клиенты могут быть сгруппированы по городам или регионам страны (Запад, Восток, Север и так далее), таким образом, 50 городов, восемь регионов и две страны составят три уровня иерархии с 60-ю членами. Также клиенты могут быть объединены по отношению к продукции; если существуют 250 продуктов по 20 категориям, три группы продукции и три производственных подразделения, то количество агрегатов составит 16 560. При добавлении измерений в схему количество возможных вариантов быстро достигает десятков миллионов и более.\n
OLAP-куб содержит базовые данные и информацию об измерениях (агрегаты). Куб потенциально содержит всю информацию, которая может потребоваться для ответов на любые запросы. При огромном количестве агрегатов зачастую полный расчёт происходит только для некоторых измерений, для остальных же производится «по требованию».\n
Существуют три типа OLAP:\n
o	многомерная OLAP (Multidimensional OLAP — MOLAP);\n
o	реляционная OLAP (Relational OLAP — ROLAP);\n
o	гибридная OLAP (Hybrid OLAP — HOLAP).\n
MOLAP — классическая форма OLAP, так что её часто называют просто OLAP. Она использует суммирующую базу данных и создаёт требуемую многомерную схему данных с сохранением как базовых данных, так и агрегатов.\n
ROLAP работает напрямую с реляционной базой данных, факты и таблицы с измерениями хранятся в реляционных таблицах, и для хранения агрегатов создаются дополнительные реляционные таблицы.\n
HOLAP использует реляционные таблицы для хранения базовых данных и многомерные таблицы для агрегатов.\n
Особым случаем ROLAP является «ROLAP реального времени» (Real-time ROLAP — R-ROLAP). В отличие от ROLAP в R-ROLAP для хранения агрегатов не создаются дополнительные реляционные таблицы, а агрегаты рассчитываются в момент запроса. При этом многомерный запрос к OLAP-системе автоматически преобразуется в SQL-запрос к реляционным данным.\n
Каждый тип хранения имеет определённые преимущества, хотя есть разногласия в их оценке у разных производителей. MOLAP лучше всего подходит для небольших наборов данных, он быстро рассчитывает агрегаты и возвращает ответы, но при этом генерируются огромные объёмы данных. ROLAP считается более масштабируемым решением, притом более экономичным к пространству хранения, но с ограничениями по возможностям аналитической обработки. HOLAP находится посреди этих двух подходов, он достаточно хорошо масштабируется, и позволяет преодолеть ряд ограничений. Архитектура R-ROLAP позволяет производить многомерный анализ OLTP-данных в режиме реального времени.\n
Сложность в применении OLAP состоит в создании запросов, выборе базовых данных и разработке схемы, в результате чего большинство продуктов OLAP поставляются вместе с огромным количеством предварительно настроенных запросов. Другая проблема — в базовых данных, они должны быть полными и непротиворечивыми.\n
Реализации OLAP\n
Исторически первой многомерной системой управления базами данных, по существу являющейся OLAP-реализацией, считается система Express, разработанная в 1970-м году компанией IRI (позднее права на продукт были приобретены корпорацией Oracle и превращён в OLAP-опцию для Oracle Database). Термин OLAP ввёл Эдгар Кодд в публикации в журнале Computerworld в 1993 году, в которой он предложил 12 принципов аналитической обработки, по аналогии с 12 правилами для реляционных баз данных, сформулированными им же десятилетием ранее, в качестве референтного продукта, удовлетворяющего предложенным принципам, Кодд указал систему Essbase компании Arbor (поглощённой в 1997 году компанией Hyperion, которую, в свою очередь, в 2007-м году купила Oracle). Примечательно, что впоследствии публикация была изъята из архивов Computerworld из-за возможного конфликта интересов, так как Кодд позднее оказывал консультационные услуги для Arbor.\n
С точки зрения реализации, делятся на «физическую OLAP» и «виртуальную» (реляционную, англ. Relational OLAP, ROLAP). «Физическая», в свою очередь, в зависимости от реализации подразделяется на многомерную (англ. Multidimensional OLAP, MOLAP) и гибридную — (англ. Hybrid OLAP, HOLAP).\n
В первом случае наличествует программа, выполняющая на этапе предварительной загрузки данных в OLAP предварительный расчёт агрегатов (вычислений по нескольким исходным значениям, например «итог за месяц»), которые затем сохраняются в специальную многомерную базу данных, обеспечивающую быстрое извлечение и экономичное хранение.\n
Гибридная реализация является комбинацией: сами данные хранятся в реляционной базе данных, а агрегаты — в многомерной.\n
В ROLAP-реализациях все данные хранятся и обрабатываются в реляционных системах управления базами данных, а агрегаты могут не существовать вообще или создаваться по первому запросу к базе данных или кэше аналитического программного обеспечения.\n
С точки зрения пользователя, все варианты выглядят похожими по возможностям. Наибольшее применение OLAP находит в продуктах для финансового планирования, хранилищах данных, решениях класса Business Intelligence.\n
Среди коммерческих продуктов выделяют: Microsoft SQL Server Analysis Services, Essbase, PowerPlay, BusinessObjects, MicroStrategy, SAP BW, Cartesis Magnitude, Oracle Database OLAP Option, TM1. Существует несколько свободных решений, среди них отмечаются Mondrian и Palo.\n

</item>
 <!--13--><item>13.АЛГОРИТМЫ ИНТЕЛЛЕКТУАЛЬНОГО АНАЛИЗА ДАННЫХ.\n\n\n\n
Алгоритм интеллектуального анализа данных представляет собой механизм, создающий модель интеллектуального анализа данных. Чтобы создать модель, алгоритм сначала анализирует набор данных, осуществляя поиск определенных закономерностей и трендов. Алгоритм использует результаты этого анализа для определения параметров модели интеллектуального анализа данных. Затем эти параметры применяются ко всему набору данных, чтобы выявить пригодные к использованию закономерности и получить подробную статистику.\n
Ниже перечислены алгоритмы интеллектуального анализа данных, реализованные в Microsoft SQL Server 2008 R2 (указание на Майкрософт говорит о том, что это ее реализации алгоритмов, а приводимые английские названия понадобятся нам в дальнейшем):\n\n
1.	Упрощенный алгоритм Байеса (Майкрософт) - MicrosoftNaiveBayes;\n
Упрощенный алгоритм Байеса является алгоритмом классификации на основе Байеса теоремах и может использоваться как для произвольного, так и для прогнозного моделирования. Слово «упрощенный» в его названии указывает на то, что алгоритм использует методы Байеса, но не учитывает возможные зависимости.\n
Данный алгоритм требует меньшего количества вычислений, чем другие алгоритмы Microsoft, и может применяться для быстрого формирования моделей интеллектуального анализа данных для обнаружения отношений между входными и прогнозируемыми столбцами. Этот алгоритм можно использовать для первоначального исследования данных, а затем применить результаты для создания дополнительных моделей интеллектуального анализа с другими алгоритмами, требующими большего количества вычислений и являющимися более точными.\n\n
2.	Алгоритм дерева принятия решений (Майкрософт) - MicrosoftDecisionTrees;\n
Алгоритм дерева принятия решений (Microsoft) представляет собой алгоритм регрессии и классификации для использования в прогнозном моделировании дискретных и непрерывных атрибутов.\n
Для дискретных атрибутов алгоритм осуществляет прогнозирования на основе связи между входными столбцами в наборе данных. Он использует значения этих столбцов (известные как состояния) для прогнозирования состояний столбца, который обозначается как прогнозируемый. Алгоритм идентифицирует входные столбцы, которые коррелированы с прогнозируемым столбцом. Например, в сценарии для прогнозирования того, какие заказчики, скорее всего, приобретут велосипед, если девять из десяти молодых заказчиков покупают велосипед, но только двое из более старших заказчиков делают это, то алгоритм заключает, что возраст является хорошим прогнозом приобретения велосипеда. Дерево решений осуществляет прогнозирование на основе этой тенденции в направлении конкретного результата.\n
Для непрерывных атрибутов алгоритм использует линейную регрессию для определения места разбиения дерева решений.\n
Если несколько столбцов установлены как прогнозируемые или если входные данные содержат вложенную таблицу, которая задана как прогнозируемая, то алгоритм строит отдельное дерево решений для каждого прогнозируемого столбца\n\n
3.	Алгоритм временных рядов (Майкрософт) - MicrosoftTimeSeries;\n
Алгоритм временных рядов ( Microsoft ) предоставляет несколько алгоритмов, оптимизированных для прогноза непрерывных значений, таких как продажи продуктов, во времени. В отличие от других алгоритмов Microsoft , таких как деревья принятия решений, модель временных рядов не требует дополнительных столбцов новых сведений, чтобы прогнозировать тренд. С помощью модели временных рядов можно прогнозировать тенденции на основе только исходного набора данных, использованного для создания модели. При прогнозировании можно вводить в модель новые данные и автоматически задействовать их при анализе тенденций.\n
Сочетание исходных данных и прогнозируемых данных называется рядом.\n
Важной характеристикой алгоритма временных рядов ( Microsoft ) является его способность выполнять перекрестный прогноз. При обучении алгоритма двумя отдельными, но связанными друг с другом рядами можно использовать итоговую модель для прогнозирования исхода одного ряда на основе поведения другого ряда. Например, наблюдаемые продажи одного продукта могут оказать влияние на прогнозируемые продажи другого продукта. Перекрестные прогнозы также полезны при создании общей модели, которую можно применить к нескольким рядам. Например, прогнозы для определенного региона нестабильны, так как в ряду недостаточно данных хорошего качества. Общую модель можно обучить на среднем значении всех четырех регионов, а затем применить модель к отдельным рядам, чтобы подготовить более стабильные прогнозы для каждого региона.\n\n
4.Алгоритм кластеризации (Майкрософт) - MicrosoftClustering;\n
Алгоритм кластеризации Microsoft является алгоритмом сегментации или кластеризации , который выполняет итерацию вариантов в наборе данных, чтобы сгруппировать их в кластеры, содержащие подобные характеристики. Такие группирования полезно использовать для просмотра данных, выявления в них аномалий и создания прогнозов.\n
Модели кластеризации определяют связи в наборе данных, который невозможно логически получить с помощью случайного наблюдения. Например, можно логически догадаться, что люди, добирающиеся на работу на велосипеде, не обязательно живут далеко от работы. Алгоритм может найти другие не очевидные характеристики велосипедистов. На следующей диаграмме кластер А соответствует людям, добирающимся до работы на машине, а кластер Б — людям, добирающимся до работы на велосипеде.\n
Алгоритм кластеризации отличается от других алгоритмов интеллектуального анализа данных, например алгоритма дерева принятия решений Microsoft , в котором не требуется назначать прогнозируемый столбец, необходимый для создания модели кластеризации. Алгоритм кластеризации обучает модель строго на основе связей, существующих в данных и на основе кластеров, идентифицированных алгоритмом.\n\n
5.Алгоритм кластеризации последовательностей (Майкрософт) - MicrosoftSequenceClustering;\n
Алгоритм кластеризации последовательностей Microsoft — это уникальный алгоритм сочетающий в себе анализ последовательностей и кластеризацию. Данный алгоритм можно использовать для просмотра данных, содержащих события, которые могут быть связаны в последовательность. Алгоритм находит самые распространенные последовательности и выполняет кластеризацию для поиска идентичных последовательностей. Ниже описаны типы последовательностей, которые можно использовать в качестве данных для машинного обучения, чтобы получить сведения о стандартных проблемах или бизнес-сценариях:\n
•	Сведения о посещениях и схемах щелчков, которые создаются, когда пользователи переходят по веб-сайту или просматривают его.\n
•	Журналы, в которых перечислены события, предшествовавшие инциденту, такие как сбой жесткого диска или взаимоблокировка сервера.\n
•	Записи транзакций, описывающие порядок, в котором клиент добавляет в корзину товары, выбранные в интернет-магазине.\n
•	Записи, следящие за взаимодействием с клиентом или пациентом во времени для прогнозирования отмены услуг или других нежелательных итогов.\n
Этот алгоритм во многом напоминает алгоритм кластеризации Microsoft . Однако вместо поиска кластеров вариантов, содержащих похожие атрибуты, алгоритм кластеризации последовательностей Microsoft находит кластеры вариантов, содержащие похожие пути в последовательности.\n\n
6.Алгоритм взаимосвязей Майкрософт - MicrosoftAssociationRules;\n
Алгоритм взаимосвязей Microsoft часто используется для механизмов выработки рекомендаций. Механизм рекомендаций рекомендует продукты пользователям на основе элементов, которые они уже купили или к которым проявили интерес. Алгоритм взаимосвязей Microsoft удобно использовать для анализа потребительской корзины.
Модели взаимосвязей построены на наборах данных, содержащих идентификаторы для отдельных вариантов и элементов этих вариантов. Группа элементов в варианте называется набор элементов. Модель взаимосвязей состоит из рядов наборов элементов и правил, описывающих, как эти элементы группируются в вариантах. Правила, определяемые алгоритмом, могут использоваться для прогнозирования вероятных будущих покупок покупателей на основе элементов, уже имеющихся в корзине покупателя. На следующей диаграмме представлен ряд правил в наборе элементов.\n
Алгоритм взаимосвязей Microsoft потенциально может находить множество правил внутри набора данных. Для описания набора элементов и формируемых ими правил алгоритм использует два параметра: мощность несущего множества и вероятность. Например, если X и Y представляют два элемента, которые могут находиться в корзине для покупок, то параметр несущего множества будет равен количеству вариантов в наборе данных, содержащих сочетание элементов X и Y. Используя параметр несущего множества в сочетании с пользовательскими параметрами MINIMUM_SUPPORT и MAXIMUM_SUPPORT , алгоритм управляет количеством создаваемых наборов элементов. Параметр вероятности, называемый также достоверностью, представляет часть вариантов в наборе данных, содержащих X и Y. Используя параметр вероятности в сочетании с параметром MINIMUM_PROBABILITY , этот алгоритм управляет количеством сформированных правил.\n\n
7.	Алгоритм нейронной сети (Майкрософт) - MicrosoftNeuralNetwork;\n
Алгоритм нейронной сети Microsoft представляет собой реализацию архитектуры распространенной и адаптируемой нейронной сети для машинного обучения. Алгоритм работает путем тестирования каждого возможного состояния входного атрибута с каждым возможным состоянием прогнозируемого атрибута и использует обучающие данные для вычисления вероятностей каждого сочетания. Эти вероятности можно использовать для задач классификации или регрессии, а также для прогнозирования исхода на основе входных атрибутов. Нейронную сеть можно также использовать для анализа взаимосвязей.\n
При создании модели интеллектуального анализа данных с помощью алгоритма нейронной сети Microsoft можно включить несколько выходных данных, а алгоритм создаст несколько сетей. Количество сетей, содержащихся в одной модели интеллектуального анализа данных, зависит от числа состояний (или значений атрибута) во входных столбцах, а также от числа прогнозируемых столбцов, используемых в модели интеллектуального анализа данных, и числа состояний в этих столбцах.\n\n
8.	Алгоритм линейной регрессии (Майкрософт) - MicrosoftLinearRegression;\n
Алгоритм линейной регрессии Microsoft является разновидностью алгоритма дерева принятия решений Microsoft, помогающего рассчитать линейную связь между зависимой и независимой переменной, а затем использовать эту связь при прогнозировании.\n
Связь принимает вид формулы линии, представляющей ряд данных. Например, линия на следующей диаграмме является наилучшим линейным представлением данных.\n
Каждой точке на диаграмме соответствует ошибка, связанная с ее расстоянием от линии регрессии. Коэффициенты a и b в уравнении регрессии регулируют угол и положение линии регрессии. Регрессивное уравнение можно получать с помощью подбора коэффициентов a и b до тех пор, пока сумма ошибок, связанных с этими точками, не станет минимальной.\n
Существуют другие типы регрессии, в которых используется несколько переменных, а также нелинейные методы регрессии. Однако линейная регрессия является полезным и широко известным методом моделирования ответа на изменение в каком-либо базовом факторе.\n\n
9.	Алгоритм логистической регрессии (Майкрософт) - MicrosoftLogisticRegression.\n
Логистическая регрессия является известным статистическим методом, применяемым для моделирования двоичных результатов.\n
Существуют различные варианты внедрения логистической регрессии в статистических исследованиях. Такие варианты различаются по методам обучения, реализованным в них. Алгоритм логистической регрессии Microsoft реализован на основе вариации алгоритма нейронной сети Microsoft . Этот алгоритм обладает многими качествами нейронных сетей, но более прост в обучении.\n
Одним из преимуществ логистической регрессии является гибкость алгоритма, способного принимать входные данные любого рода и поддерживать несколько различных аналитических задач.\n
•	Использование демографических данных для составления прогнозов о результатах, например оценка риска некоторого заболевания.\n
•	Исследование и взвешивание факторов, влияющих на результат. Например, поиск факторов, побуждающих клиентов совершить повторное посещение магазина.\n
•	Классификация документов, электронной почты и других объектов, имеющих множество атрибутов.\n
</item>
 <!--14--><item>14.	ПРОЦЕССЫ ЖИЗНЕННОГО ЦИКЛА ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
1.Основные процессы жизненного цикла.\n
1.1.Процесс заказа.\n
Процесс заказа определяет работы и задачи заказчика. Процесс заказа состоит из определения потребностей заказчика в системе, программном продукте или программной услуге, подготовки и выпуска заявки на подряд, выбора поставщика и управления процессом заказа до завершения приемки системы, программного продукта или программной услуги.\n
1.2.Процесс поставки.\n
Процесс поставки определяет работы и задачи поставщика. Процесс поставки начинается с решения о подготовке предложения в ответ на заявку на подряд, присланную заказчиком, или с подписания договора с заказчиком на поставку системы, ПП или программной услуги. Затем определяются процедуры и ресурсы, необходимые для управления и обеспечения проекта, включая разработку проектных планов и их выполнение.\n
1.3.Процесс разработки.\n
Процесс разработки определяет работы и задачи разработчика. Данный процесс включает работы по анализу требований, проектированию, программированию, сборке, тестированию, вводу в действие и приемке программного продукта или системы.\n
1.4.Процесс эксплуатации.\n
Процесс эксплуатации определяет работы и задачи оператора. Данный процесс включает эксплуатацию программного продукта и поддержку пользователей в процессе эксплуатации.\n
1.5.Процесс сопровождения.\n
Процесс сопровождения определяет работы и задачи персонала сопровождения и реализуется при модификациях программного продукта. Цель процесса – изменение существующего ПП при сохранении его целостности. Процесс охватывает вопросы переносимости и снятия ПП с эксплуатации.\n\n
2.Вспомогательные процессы жизненного цикла.\n
2.1	Процесс документирования.\n
Процесс документирования является процессом формализованного описания информации, созданной в процессе или работе жизненного цикла. Он включает планирование, проектирование, разработку, выпуск, редактирование, распространение и сопровождение документов по программному продукту.\n
2.2 Процесс управления конфигурацией.\n
Процесс управления конфигурацией является процессом применения административных и технических процедур на всем протяжении ЖЦ ПС для определения состояния (базовой линии) программных объектов в системе, управления их изменениями и выпуском.\n
2.3	Процесс обеспечения качества\n
Процесс обеспечения качества является процессом обеспечения гарантий того, что программные продукты и процессы в жизненном цикле проекта соответствуют требованиям и планам. Данный процесс должен быть независимым от субъектов, участвующих в проекте. Это позволяет достичь объективности процесса. При обеспечении качества могут использоваться результаты процессов верификации, аттестации, совместного анализа, аудита и решения проблем\n
2.4	Процесс верификации.\n
Процесс верификации является процессом определения того, что программные продукты функционируют в полном соответствии с требованиями и условиями, реализованными в предшествующих работах.\n
Данное определение является не совсем понятным для лиц, некомпетентных в области верификации. Кроме того, оно сужает применимость верификации только до программных продуктов. Для пояснения данного определения следует рассмотреть само понятие верификации. Термин верификация (verification) обозначает подтверждение с помощью экспертизы и представления объективных доказательств того, что конкретные требования полностью реализованы. В процессе разработки верификация связана с экспертизой результатов данной работы с целью определения их соответствия установленным на входе данной работы требованиям. Таким образом, верификация может применяться не только к программным продуктам, но и к любым другим результатам работы. Например, верификации могут подвергаться требования, системная и программная архитектура, документация, методы, планы и т.п.\n
В этой связи более понятным и близким к истине является следующее определение процесса верификации. Процесс верификации – это процесс определения того, что результаты работы соответствуют требованиям или условиям, установленным на входе данной работы.\n
Процесс верификации может включать анализ, проверку и тестирование.\n
Объектами анализа и проверки могут являться, например, документация и исходные тексты программных модулей. Объектами тестирования могут являться исполнимые коды программных модулей, компонентов, промежуточных и конечного программных продуктов.\n
Данный процесс называется процессом независимой верификации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.5	Процесс аттестации и его структура.\n
Процесс аттестации является процессом определения полноты соответствия установленных требований, созданной системы или программного продукта их функциональному назначению. Чтобы пояснить это определение, следует рассмотреть понятие аттестации.\n
Термин аттестация (validation) обозначает подтверждение экспертизой и представлением объективных доказательств того, что конкретные требования к конкретным объектам полностью реализованы. В процессе разработки аттестация связана с экспертизой продукта в целях определения его соответствия потребностям пользователя (то есть исходным требованиям к проекту).\n
Аттестации (проверке на соответствие исходным требованиям) могут подвергаться любые промежуточные продукты процесса разработки. Аттестация может проводиться на начальных этапах работы и как часть работы по обеспечению приемки ПС.\n
Данный процесс называется процессом независимой аттестации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.6	Процесс совместного анализа.\n
Процесс совместного анализа является процессом оценки состояний и результатов работ по проекту. Совместные анализы проводятся в течение всего договора и применяются как на уровне управления проектом, так и на уровне его технической реализации. Данный процесс может выполняться двумя любыми сторонами, участвующими в договоре, когда одна сторона (анализирующая) проверяет другую (анализируемую).\n
2.7	Процесс аудита.\n
Процесс аудита является процессом определения соответствия требованиям, планам и условиям договора. Данный процесс может выполняться двумя сторонами, участвующими в договоре, когда одна сторона (ревизующая) проверяет другую сторону (ревизуемую).\n
2.8	Процесс решения проблем.\n
Процесс решения проблем является процессом анализа и решения проблем (включая обнаруженные несоответствия), которые обнаружены в ходе выполнения разработки, эксплуатации, сопровождения или других процессов.\n\n
3. Организационные процессы жизненного цикла.\n
3.1 Процесс управления.\n
Процесс управления состоит из общих работ и задач, которые могут быть использованы любой стороной, управляющей соответствующим процессом. За управление продуктом, проектом, работами и задачами основных и вспомогательных процессов отвечает администратор.\n
3.2 Процесс создания инфраструктуры\n
Процесс создания инфраструктуры является процессом установления и сопровождения инфраструктуры, необходимой для любого другого процесса. Инфраструктура содержит технические и программные средства, инструментальные средства, методики, стандарты и условия для разработки, эксплуатации или сопровождения.\n
3.3 Процесс обучения\n
Процесс обучения является процессом обеспечения первоначального и продолженного обучения персонала работам по заказу, поставке, разработке, эксплуатации или сопровождению программного проекта.\n
3.4 Процесс усовершенствования\n
Процесс усовершенствования является процессом установления, оценки, измерения, контроля и улучшения любого процесса жизненного цикла программных средств.\n</item>
 <!--15--><item>15.ПРОЕКТИРОВАНИЕ ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
Проектирование программных средств\n
Проектирование ПС в основном рассматривается как двух-шаговый процесс:\n
– Архитектурное проектирование – декомпозиция структуры (статической) и организации (динамической) компонент;\n
– Детализация архитектуры – описывает специфическое поведение и характеристики отдельных компонент.\n
Выходом этого процесса является набор моделей и артефактов, содержащих результаты решений, принятых по способам реализации требований в программном коде.\n
Принципы проектирования\n
В качестве основных принципов проектирования выделим следующие:\n
Абстракция\n
Абстракция – отвлечение в процессе познания от несущественных сторон, свойств, связей объекта (предмета или явления) с целью выделения их существенных, закономерных признаков; абстрагирование; теоретическое обобщение как результат такого отвлечения.\n
Абстракция – модель, упрощающая поставленную проблему до рамок, значимых для заданного контекста.\n
В контексте проектирования программных систем существует два механизма абстракции – параметризация и детализация. При этом, абстракция через детализацию может быть: процедурной (связанной с поведением), абстракцией данных (связанной с информацией) и абстракцией контроля (связанной с управлением системой и обрабатываемой ею информацией).\n
Связанность и соединение\n
Связанность – определяет силу взаимосвязи между модулями. Соединение – определяет взаимосвязь элементов внутри модуля, внутренние связи.\n
Декомпозиция и разбиение на модули\n
Декомпозиция и разбиение на модули сложных программных систем производится с целью получения более мелких и относительно независимых программных компонентов, каждый из которых несет различную функциональность.\n
Инкапсуляция\n
Предполагает группировку и упаковку элементов и внутренних деталей абстракции в отношении реализации с тем, чтобы эти детали были недоступны пользователям элементов. В качестве «пользователя» одного компонента может выступать другой компонент. Более того, при использовании объектно-ориентированного подхода, наследники компонентов могут не иметь доступа ко внутренним деталям реализации компонента, который является их предком.\n
Разделение интерфейса и реализации\n
Данная техника предполагает отделение компонента через специфицирование интерфейса, известного и доступного клиентам (или другим компонентам), от непосредственных деталей реализации.\n
Достаточность, полнота и простота\n
Создаваемые программные компоненты должны обладать всеми необходимыми характеристиками, определенными абстракцией (моделью), но не должны включать функциональность, отсутствующую в модели.\n
Структура и архитектура программного обеспечения\n
Архитектура программного обеспечения (англ. software architecture) – это структура программы или вычислительной системы, которая включает программные компоненты, видимые снаружи свойства этих компонентов, а также отношения между ними.\n
Архитектура ПО является реализацией нефункциональных требований к системе, в то время как проектирование ПО является реализацией функциональных требований.\n
Архитектура ПО обычно содержит несколько видов, которые аналогичны различным типам чертежей в строительстве зданий. В онтологии, установленной ANSI / IEEE 1471—2000, виды являются экземплярами точки зрения, где точка зрения существует для описания архитектуры с точки зрения заданного множества заинтересованных лиц.\n
Примеры видов:\n
- Функциональный/логический вид\n
- Вид код/модуль\n
- Вид разработки (development)/структурный\n
- Вид параллельности выполнения/процесс/поток\n
- Физический вид/вид развертывания\n
- Вид с точки зрения действий пользователя\n
- Вид с точки зрения данных\n
На сегодняшний день сформировался взгляд на архитектуру, как на приложение общих принципов организации программных компонент, что привело к накоплению множества подходов и созданию различных архитектурных «фреймворков», то есть систематизированных комплексов методов, практик и инструментов, призванных формализовать имеющийся в индустрии опыт.\n
Фреймворк (англ. framework — каркас, структура) – структура программной системы или программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта. В отличие от библиотек, которые объединяют набор подпрограмм близкой функциональности, фреймворк содержит в себе большое количество разных по назначению библиотек. Некоторые авторы используют слово «каркас» в качестве основного. С их точки зрения можно говорить о каркасном подходе как о подходе к построению программ, где любая конфигурация программы строится из двух частей: первая, постоянная часть – каркас, не меняющийся от конфигурации к конфигурации и несущая в себе гнезда, в которых размещается вторая, переменная часть – сменные модули (или точки расширения).\n
Фреймворк реализуется как множество конкретных и абстрактных классов, а также определений способов их взаимоотношения. Конкретные классы обычно реализуют взаимные отношения между классами. Абстрактные классы представляют собой точки расширения, в которых каркасы могут быть использованы или адаптированы. Точка расширения — это та часть фреймворка, для которого не приведена реализация. Соответственно каркас концептуальной модели состоит из концептуальных классов, а каркас программной системы из классов языка программирования общего назначения. Процесс создания фреймворка заключается в выборе подмножества задач проблемы и их реализаций. В ходе реализаций общие средства решения задач заключаются в конкретных классах, а изменяемые средства выносятся в точки расширения.\n
Примеры такой систематизации в форме фреймворков:\n
TOGAF [TOGAF81, 2003] – The Open Group Architecture Framework (на момент первичного написания данной главы доступен в версии 8.1, впервые опубликованной в декабре 2003 года; в 2009 году вышла версия TOGAF 9)\n
Модель Захмана – Zachman Framework.\n
Руководство по архитектуре электронного правительства E-Gov Enterprise Architecture Guidance [E-Gov, 2002]\n
Архитектурные структуры и точки зрения\n
Принцип сужения предметной области с использованием точки зрения [пособие по ТССА] широко используется в программной инженерии. Система может рассматриваться с разных точек зрения – поведенческой, структурной, логической, физической и т.п. Следовательно, можно получить множество различных архитектурных представлений. Архитектурное представление может быть определено, как частные аспекты программной архитектуры, рассматривающие специфические свойства программной системы. Дизайн системы – комплекс архитектурных представлений, достаточный для реализации системы и удовлетворения требований, предъявляемых к системе.\n
Архитектурная структура – применение архитектурной точки зрения и представления к конкретной системе и описания тех деталей, которые необходимы для реализации системы, но отсутствуют в используемом представлении. Таким образом, представление, концентрируясь на заданном подмножестве свойств является составной частью и/или результатом точки зрения, а архитектурная структура – дальнейшей детализацией в отношении проектируемой системы. В качестве примера архитектурных точек зрения можно рассматривать модель Захмана.\n
Архитектурные стили\n
Архитектурный стиль – это мета-модель или шаблон проектирования макро-архитектуры – на уровне модулей, «крупноблочного» взгляда. Архитектурный стиль – набор ограничений, определяющих семейство архитектур, которые удовлетворяют этим ограничениям.\n
Шаблоны проектирования\n
Архитектурный стиль определяет макро-архитектуру системы, а шаблоны проектирования задают микроархитектуру, то есть определяют частные аспекты деталей архитектуры.\n
Чаще всего говорят о следующих группах шаблонов проектирования:\n
– Шаблоны создания (Creational patterns) - builder, factory, prototype, singleton\n
– Структурные шаблоны (Structural patterns) - adapter, bridge, composite, decorator, facade, flyweight, proxy\n
– Шаблоны поведения (Behavioral patterns) - command, interpreter, iterator, mediator, memento, observer, state, strategy, template, visitor\n

</item>
 <!--16--><item>Уругвай</item>
 <!--17--><item>17.ТЕСТИРОВАНИЕ И ОТЛАДКИ ПРОГРАММНОГО СРЕДСТВА.\n\n\n\n\n
Основные понятия.\n
Отладка ПС - это деятельность, направленная на обнаружение и исправление ошибок в ПС с использованием процессов выполнения его программ. Тестирование ПС - это процесс выполнения его программ на некотором наборе данных, для которого заранее известен результат применения или известны правила поведения этих программ. Указанный набор данных называется тестовым или просто тестом. Таким образом, отладку можно представить в виде многократного повторения трех процессов: тестирования, в результате которого может быть констатировано наличие в ПС ошибки, поиска места ошибки в программах и документации ПС и редактирования программ и документации с целью устранения обнаруженной ошибки. Другими словами:\n
Отладка = Тестирование + Поиск ошибок + Редактирование.\n\n

Принципы и виды отладки.\n
Успех отладки в значительной степени предопределяет рациональная организация тестирования. При отладке отыскиваются и устраняются, в основном, те ошибки, наличие которых в ПС устанавливается при тестировании. Как было уже отмечено, тестирование не может доказать правильность ПС, в лучшем случае оно может продемонстрировать наличие в нем ошибки. Другими словами, нельзя гарантировать, что тестированием ПС практически выполнимым набором тестов можно установить наличие каждой имеющейся в ПС ошибки. Поэтому возникает две задачи. Первая: подготовить такой набор тестов и применить к ним ПС, чтобы обнаружить в нем по возможности большее число ошибок. Однако, чем дольше продолжается процесс тестирования (и отладки в целом), тем большей становится стоимость ПС. Отсюда вторая задача: определить момент окончания отладки ПС (или отдельной его компоненты). Признаком возможности окончания отладки является полнота охвата пропущенными через ПС тестами (т.е. тестами, к которым применено ПС) множества различных ситуаций, возникающих при выполнении программ ПС, и относительно редкое проявление ошибок в ПС на последнем отрезке процесса тестирования. Последнее определяется в соответствии с требуемой степенью надежности ПС, указанной в спецификации его качества.\n
Для оптимизации набора тестов, т.е. для подготовки такого набора тестов, который позволял бы при заданном их числе (или при заданном интервале времени, отведенном на тестирование) обнаруживать большее число ошибок, необходимо, во-первых, заранее планировать этот набор и, во-вторых, использовать рациональную стратегию планирования (проектирования) тестов. Проектирование тестов можно начинать сразу же после завершения этапа внешнего описания ПС. Возможны разные подходы к выработке стратегии проектирования тестов, которые можно условно графически разместить между следующими двумя крайними подходами. Левый крайний подход заключается в том, что тесты проектируются только на основании изучения спецификаций ПС (внешнего описания, описания архитектуры и спецификации модулей). Строение модулей при этом никак не учитывается, т.е. они рассматриваются как черные ящики. Фактически такой подход требует полного перебора всех наборов входных данных, так как при использовании в качестве тестов только части этих наборов некоторые участки программ ПС могут не работать ни на каком тесте и, значит, содержащиеся в них ошибки не будут проявляться. Однако тестирование ПС полным множеством наборов входных данных практически неосуществимо. Правый крайний подход заключается в том, что тесты проектируются на основании изучения текстов программ с целью протестировать все пути выполнения каждой программ ПС. Если принять во внимание наличие в программах циклов с переменным числом повторений, то различных путей выполнения программ ПС может оказаться также чрезвычайно много, так что их тестирование также будет практически неосуществимо.\n
Оптимальная стратегия проектирования тестов расположена внутри интервала между этими крайними подходами, но ближе к левому краю. Она включает проектирование значительной части тестов по спецификациям, исходя из принципов: на каждую используемую функцию или возможность - хотя бы один тест, на каждую область и на каждую границу изменения какой-либо входной величины - хотя бы один тест, на каждый особый случай или на каждую исключительную ситуацию, указанные в спецификациях, - хотя бы один тест. Но она требует также проектирования некоторых тестов и по текстам программ, исходя из принципа (как минимум): каждая команда каждой программы ПС должна проработать хотя бы на одном тесте.\n
Оптимальную стратегию проектирования тестов можно конкретизировать на основании следующего принципа: для каждого программного документа (включая тексты программ), входящего в состав ПС, должны проектироваться свои тесты с целью выявления в нем ошибок. Во всяком случае, этот принцип необходимо соблюдать в соответствии с определением ПС и содержанием понятия технологии программирования как технологии разработки надежных ПС. В связи с этим Майерс даже определяет разные виды тестирования в зависимости от вида программного документа, на основании которого строятся тесты. В нашей стране различаются два основных вида отладки (включая тестирование): автономную и комплексную отладку. Автономная отладка означает тестирование только какой-то части программы, входящей в ПС, с поиском и исправлением в ней фиксируемых при тестировании ошибок. Она фактически включает отладку каждого модуля и отладку сопряжения модулей. Комплексная отладка означает тестирование ПС в целом с поиском и исправлением фиксируемых при тестировании ошибок во всех документах (включая тексты программ ПС), относящихся к ПС в целом. К таким документам относятся определение требований к ПС, спецификация качества ПС, функциональная спецификация ПС, описание архитектуры ПС и тексты программ ПС.\n\n
Заповеди отладки.\n
В данном разделе даются общие рекомендации по организации отладки. Но сначала следует отметить некоторый феномен, который подтверждает важность предупреждения ошибок на предыдущих этапах разработки: по мере роста числа обнаруженных и исправленных ошибок в ПС растет также относительная вероятность существования в нем необнаруженных ошибок. Это объясняется тем, что при росте числа ошибок, обнаруженных в ПС, уточняется и наше представление об общем числе допущенных в нем ошибок, а значит, в какой-то мере, и о числе необнаруженных еще ошибок. Этот феномен подтверждает важность раннего обнаружения ошибок и необходимость тщательного контроля принимаемых решений на каждом этапе разработки ПС.\n
Ниже приводятся рекомендации по организации отладки в форме заповедей.\n\n
Заповедь 1. Считайте тестирование ключевой задачей разработки ПС, поручайте его самым квалифицированным и одаренным программистам; нежелательно тестировать свою собственную программу.\n
Заповедь 2. Хорош тот тест, для которого высока вероятность обнаружить ошибку, а не тот, который демонстрирует правильную работу программы.\n
Заповедь 3. Готовьте тесты как для правильных, так и для неправильных данных.\n
Заповедь 4. Избегайте невоспроизводимых тестов, документируйте их пропуск через компьютер; детально изучайте результаты каждого теста.\n
Заповедь 5. Каждый модуль подключайте к программе только один раз; никогда не изменяйте программу, чтобы облегчить ее тестирование.\n
Заповедь 6. Пропускайте заново все тесты, связанные с проверкой работы какой-либо программы ПС или ее взаимодействия с другими программами, если в нее были внесены изменения (например, в результате устранения ошибки).\n\n
Автономная отладка модуля.
При автономной отладке каждый модуль на самом деле тестируется в некотором программном окружении, кроме случая, когда отлаживаемая программа состоит только из одного модуля. Это окружение состоит из других модулей, часть которых является модулями отлаживаемой программы, которые уже отлажены, а часть - модулями, управляющими отладкой (отладочными модулями, см. ниже). Таким образом, при автономной отладке тестируется всегда некоторая программа, построенная специально для тестирования отлаживаемого модуля. Эта программа лишь частично совпадает с отлаживаемой программой, кроме случая, когда отлаживается последний модуль отлаживаемой программы. По мере продвижения отладки программы все большую часть окружения очередного отлаживаемого модуля будут составлять уже отлаженные модули этой программы, а при отладке последнего модуля этой программы окружение отлаживаемого модуля будет целиком состоять из всех остальных (уже отлаженных) модулей отлаживаемой программы (без каких-либо) отладочных модулей, т.е. в этом случае тестироваться будет сама отлаживаемая программа. Такой процесс наращивания отлаживаемой программы отлаженными и отлаживаемыми модулями называется интеграцией программы.\n
Отладочные модули, входящие в окружение отлаживаемого модуля, зависят от порядка, в каком отлаживаются модули этой программы, от того, какой модуль отлаживается и, возможно, от того, какой тест будет пропускаться.\n
При восходящем тестировании это окружение всегда будет содержать только один отладочный модуль (кроме случая, когда отлаживается последний модуль отлаживаемой программы), который будет головным в тестируемой программе и который называют ведущим (или драйвером). Ведущий отладочный модуль подготавливает информационную среду для тестирования отлаживаемого модуля (т. е. формирует ее состояние, требуемое для тестирования этого модуля, в частности, может осуществлять ввод некоторых тестовых данных), осуществляет обращение к отлаживаемому модулю и после окончания его работы выдает необходимые сообщения. При отладке одного модуля для разных тестов могут составляться разные ведущие отладочные модули.\n
При нисходящем тестировании окружение отлаживаемого модуля в качестве отладочных модулей содержит имитаторы всех модулей, к которым может обращаться отлаживаемый модуль, а также имитаторы тех модулей, к которым могут обращаться отлаженные модули отлаживаемой программы (включенные в это окружение), но которые еще не отлажены. Некоторые из этих имитаторов при отладке одного модуля могут изменяться для разных тестов.\n
На самом деле в окружении отлаживаемого модуля во многих случаях могут содержаться отладочные модули обоих типов по ниже следующим соображениям. Как восходящее, так и нисходящее тестирование имеет свои достоинства и свои недостатки.\n\n
К достоинствам восходящего тестирования относятся\n
•	простота подготовки тестов\n
•	возможность полной реализации плана тестирования модуля.\n
Это связано с тем, что тестовое состояние информационной среды готовится непосредственно перед обращением к отлаживаемому модулю (ведущим отладочным модулем). Недостатками восходящего тестирования являются следующие его особенности:\n
•	тестовые данные готовятся, как правило, не в той форме, которая рассчитана на пользователя (кроме случая, когда отлаживается последний, головной, модуль отлаживаемой программ);\n
•	большой объем отладочного программирования (при отладке одного модуля часто приходится составлять для разных тестов много ведущих отладочных модулей);\n
•	необходимость специального тестирования сопряжения модулей.\n\n
К достоинствам нисходящего тестирования относятся следующие его особенности:\n
•	большинство тестов готовится в форме, рассчитанной на пользователя;\n
•	во многих случаях относительно небольшой объем отладочного программирования (имитаторы модулей, как правило, весьма просты и каждый пригоден для большого числа, нередко - для всех, тестов);\n
•	отпадает необходимость тестирования сопряжения модулей.\n
Недостатком нисходящего тестирования является то, что тестовое состояние информационной среды перед обращением к отлаживаемому модулю готовится косвенно - оно является результатом применения уже отлаженных модулей к тестовым данным или данным, выдаваемым имитаторами. Это, во-первых, затрудняет подготовку тестов, требует высокой квалификации исполнителя-тестировщика, а во-вторых, делает затруднительным или даже невозможным реализацию полного плана тестирования отлаживаемого модуля. Указанный недостаток иногда вынуждает разработчиков применять восходящее тестирование даже в случае нисходящей разработки. Однако чаще применяют некоторые модификации нисходящего тестирования, либо некоторую комбинацию нисходящего и восходящего тестирования.\n
Исходя из того, что нисходящее тестирование, в принципе, является предпочтительным, остановимся на приемах, позволяющих в какой-то мере преодолеть указанные трудности. Прежде всего необходимо организовать отладку программы таким образом, чтобы как можно раньше были отлажены модули, осуществляющие ввод данных, - тогда тестовые данные можно готовить в форме, рассчитанной на пользователя, что существенно упростит подготовку последующих тестов. Далеко не всегда этот ввод осуществляется в головном модуле, поэтому приходится в первую очередь отлаживать цепочки модулей, ведущие к модулям, осуществляющим указанный ввод. Пока модули, осуществляющие ввод данных, не отлажены, тестовые данные поставляются некоторыми имитаторами: они либо включаются в имитатор как его часть, либо вводятся этим имитатором.\n
При нисходящем тестировании некоторые состояния информационной среды, при которых требуется тестировать отлаживаемый модуль, могут не возникать при выполнении отлаживаемой программы ни при каких входных данных. В этих случаях можно было бы вообще не тестировать отлаживаемый модуль, так как обнаруживаемые при этом ошибки не будут проявляться при выполнении отлаживаемой программы ни при каких входных данных. Однако так поступать не рекомендуется, так как при изменениях отлаживаемой программы (например, при сопровождении ПС) не использованные для тестирования отлаживаемого модуля состояния информационной среды могут уже возникать, что требует дополнительного тестирования этого модуля (а этого при рациональной организации отладки можно было бы не делать, если сам данный модуль не изменялся). Для осуществления тестирования отлаживаемого модуля в указанных ситуациях иногда используют подходящие имитаторы, чтобы создать требуемое состояние информационной среды. Чаще же пользуются модифицированным вариантом нисходящего тестирования, при котором отлаживаемые модули перед их интеграцией предварительно тестируются отдельно (в этом случае в окружении отлаживаемого модуля появляется ведущий отладочный модуль, наряду с имитаторами модулей, к которым может обращаться отлаживаемый модуль). Однако, представляется более целесообразной другая модификация нисходящего тестирования: после завершения нисходящего тестирования отлаживаемого модуля для достижимых тестовых состояний информационной среды следует его отдельно протестировать для остальных требуемых состояний информационной среды.\n
Часто применяют также комбинацию восходящего и нисходящего тестирования, которую называют методом сандвича. Сущность этого метода заключается в одновременном осуществлении как восходящего, так и нисходящего тестирования, пока эти два процесса тестирования не встретятся на каком-либо модуле где-то в середине структуры отлаживаемой программы. Этот метод позволяет при разумном подходе воспользоваться достоинствами как восходящего, так и нисходящего тестирования и в значительной степени нейтрализовать их недостатки. Этот эффект является проявлением более общего принципа: наибольшего технологического эффекта можно добиться, сочетая нисходящие и восходящие методы разработки программ ПС. Именно для поддержки этого метода и предназначен архитектурный подход к разработке программ: слой квалифицированно разработанных и тщательно оттестированных модулей существенно облегчает реализацию семейства программ в соответствующей предметной области и их последующую модернизацию.
Весьма важным при автономной отладке является тестирование сопряжения модулей. Дело в том, что спецификация каждого модуля программы, кроме головного, используется в этой программы в двух ситуациях: во-первых, при разработке текста (иногда говорят: тела) этого модуля и, во-вторых, при написании обращения к этому модулю в других модулях программы. И в том, и в другом случае в результате ошибки может быть нарушено требуемое соответствие заданной спецификации модуля. Такие ошибки требуется обнаруживать и устранять. Для этого и предназначено тестирование сопряжения модулей. При нисходящем тестировании тестирование сопряжения осуществляется попутно каждым пропускаемым тестом, что считают самым сильным достоинством нисходящего тестирования. При восходящем тестировании обращение к отлаживаемому модулю производится не из модулей отлаживаемой программы, а из ведущего отладочного модуля. В связи с этим существует опасность, что последний модуль может приспособиться к некоторым "заблуждениям" отлаживаемого модуля. Поэтому приступая (в процессе интеграции программы) к отладке нового модуля приходится тестировать каждое обращение к ранее отлаженному модулю с целью обнаружения несогласованности этого обращения с телом соответствующего модуля (и не исключено, что виноват в этом ранее отлаженный модуль). Таким образом, приходится частично повторять в новых условиях тестирование ранее отлаженного модуля, при этом возникают те же трудности, что и при нисходящем тестировании.\n\n
Автономное тестирование модуля целесообразно осуществлять в четыре последовательно выполняемых шага.\n
Шаг 1. На основании спецификации отлаживаемого модуля подготовьте тест для каждой возможности и каждой ситуации, для каждой границы областей допустимых значений всех входных данных, для каждой области изменения данных, для каждой области недопустимых значений всех входных данных и каждого недопустимого условия.\n
Шаг 2. Проверьте текст модуля, чтобы убедиться, что каждое направление любого разветвления будет пройдено хотя бы на одном тесте. Добавьте недостающие тесты.\n
Шаг 3. Убедитесь по тексту модуля, что для каждого цикла существует тест, для которого тело цикла не выполняется, тест, для которого тело цикла выполняется один раз, и тест, для которого тело цикла выполняется максимальное число раз. Добавьте недостающие тесты.\n
Шаг 4. Проверьте по тексту модуля его чувствительность к отдельным особым значениям входных данных - все такие значения должны входить в тесты. Добавьте недостающие тесты.\n\n
Комплексная отладка программного средства.\n
Как уже было сказано выше, при комплексной отладке тестируется ПС в целом, причем тесты готовятся по каждому из документов ПС. Тестирование этих документов производится, как правило, в порядке, обратном их разработке (исключение составляет лишь тестирование документации по применению, которая разрабатывается по внешнему описанию параллельно с разработкой текстов программ; это тестирование лучше производить после завершения тестирования внешнего описания). Тестирование при комплексной отладке представляет собой применение ПС к конкретным данным, которые в принципе могут возникнуть у пользователя (в частности, все тесты готовятся в форме, рассчитанной на пользователя), но, возможно, в моделируемой (а не в реальной) среде. Например, некоторые недоступные при комплексной отладке устройства ввода и вывода могут быть заменены их программными имитаторами.\n\n
Тестирование архитектуры ПС. Целью тестирования является поиск несоответствия между описанием архитектуры и совокупностью программ ПС. К моменту начала тестирования архитектуры ПС должна быть уже закончена автономная отладка каждой подсистемы. Ошибки реализации архитектуры могут быть связаны прежде всего с взаимодействием этих подсистем, в частности, с реализацией архитектурных функций (если они есть). Поэтому хотелось бы проверить все пути взаимодействия между подсистемами ПС. Но так как их может быть слишком много, то желательно бы протестировать хотя бы все цепочки выполнения подсистем без повторного вхождения последних. Если заданная архитектура представляет ПС в качестве малой системы из выделенных подсистем, то число таких цепочек будет вполне обозримо.\n
Тестирование внешних функций. Целью тестирования является поиск расхождений между функциональной спецификацией и совокупностью программ ПС. Несмотря на то, что все эти программы автономно уже отлажены, указанные расхождения могут быть, например, из-за несоответствия внутренних спецификаций программ и их модулей (на основании которых производилось автономное тестирование) внешней функциональной спецификации ПС. Как правило, тестирование внешних функций производится так же, как и тестирование модулей на первом шаге, т.е. как черного ящика.
Тестирование качества ПС. Целью тестирования является поиск нарушений требований качества, сформулированных в спецификации качества ПС. Это наиболее трудный и наименее изученный вид тестирования. Ясно лишь, что далеко не каждый примитив качества ПС может быть испытан тестированием (об оценке качества ПС см. следующую лекцию). Завершенность ПС проверяется уже при тестировании внешних функций. На данном этапе тестирование этого примитива качества может быть продолжено если требуется получить какую-либо вероятностную оценку степени надежности ПС. Однако, методика такого тестирования еще требует своей разработки. Точность, устойчивость, защищенность, временная эффективность, в какой-то мере - эффективность по памяти, эффективность по устройствам, расширяемость и, частично, независимость от устройств могут тестироваться. Каждый из этих видов тестирования имеет свою специфику и заслуживает отдельного рассмотрения. Мы здесь ограничимся лишь их перечислением. Легкость применения ПС (критерий качества, включающий несколько примитивов качества, см. лекцию 4) оценивается при тестировании документации по применению ПС.\n\n
Тестирование документации по применению ПС. Целью тестирования является поиск несогласованности документации по применению и совокупностью программ ПС, а также неудобств применения ПС. Этот этап непосредственно предшествует подключению пользователя к завершению разработки ПС (тестированию требований к ПС и аттестации ПС), поэтому весьма важно разработчикам сначала самим воспользоваться ПС так, как это будет делать пользователь. Все тесты на этом этапе готовятся исключительно на основании только документации по применению ПС. Прежде всего, должны тестироваться возможности ПС как это делалось при тестировании внешних функций, но только на основании документации по применению. Должны быть протестированы все неясные места в документации, а также все примеры, использованные в документации. Далее тестируются наиболее трудные случаи применения ПС с целью обнаружить нарушение требований относительности легкости применения ПС.\n
Тестирование определения требований к ПС. Целью тестирования является выяснение, в какой мере ПС не соответствует предъявленному определению требований к нему. Особенность этого вида тестирования заключается в том, что его осуществляет организация-покупатель или организация-пользователь ПС как один из путей преодоления барьера между разработчиком и пользователем. Обычно это тестирование производится с помощью контрольных задач - типовых задах, для которых известен результат решения. В тех случаях, когда разрабатываемое ПС должно прийти на смену другому варианту ПС, который решает хотя бы часть задач разрабатываемого ПС, тестирование производится путем решения общих задач с помощью как старого, так и нового ПС с последующим сопоставлением полученных результатов. Иногда в качестве формы такого тестирования используют опытную эксплуатацию ПС - ограниченное применение нового ПС с анализом использования результатов в практической деятельности. По существу, этот вид тестирования во многом перекликается с испытанием ПС при его аттестации, но выполняется до аттестации, а иногда и вместо аттестации.\n
</item>
 <!--18--><item>18.ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ\n\n\n\n\n\n\n
Объектно-ориентированное программирование (ООП) — это парадигма разработки программных систем, в которой приложения состоят из объектов.\n
Основная задача ООП — сделать сложный код проще. Для этого программу разбивают на независимые блоки, которые мы называем объектами.
Объект — это не какая-то космическая сущность. Объекты — это сущности, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса.\n
Это всего лишь набор данных и функций — таких же, как в традиционном функциональном программировании. Можно представить, что просто взяли кусок программы и положили его в коробку и закрыли крышку. Вот эта коробка с крышками — это объект.
Программисты договорились, что данные внутри объекта будут называться свойствами, а функции — методами. Но это просто слова, по сути, это те же переменные и функции.\n
Объект можно представить как независимый электроприбор у вас на кухне. Чайник кипятит воду, плита греет, блендер взбивает, мясорубка делает фарш. Внутри каждо-го устройства куча всего: моторы, контроллеры, кнопки, пружины, предохранители — но вы о них не думаете. Вы нажимаете кнопки на панели каждого прибора, и он дела-ет то, что от него ожидается. И благодаря совместной работе этих приборов у вас получается ужин.\n
Объекты характеризуются четырьмя словами: инкапсуляция, абстракция, наследование и полиморфизм.\n\n
Инкапсуляция — объект независим: каждый объект устроен так, что нужные для него данные живут внутри этого объекта, а не где-то снаружи в программе. Например, если у меня есть объект «Пользователь», то у меня в нём будут все данные о пользователе: и имя, и адрес, и всё остальное. И в нём же будут методы «Проверить адрес» или «Подписать на рассылку».\n\n
Абстракция — у объекта есть «интерфейс»: у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интер-фейс.\n
В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет про-исходить удаление: ООП позволяет нам не думать об этом в момент обращения.\n
Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить()». Ему неважно, как другой программист будет реализовывать отме-ну: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.\n\n
Наследование — способность к копированию. ООП позволяет создавать много объектов по образу и подобию другого объекта. Это позволяет не копипастить код по двести раз, а один раз нормально написать и потом много раз использовать.\n
Например, у вас может быть некий идеальный объект «Пользователь»: в нём вы прописываете всё, что может происходить с пользователем. У вас могут быть свойства: имя, возраст, адрес, номер карты. И могут быть методы «Дать скидку», «Проверить заказ», «Найти заказы», «Позвонить».\n
На основе этого идеального пользователя вы можете создать реального «Покупателя Ивана». У него при создании будут все свойства и методы, которые вы задали у иде-ального покупателя, плюс могут быть какие-то свои, если захотите.\n
Идеальные объекты программисты называют классами.\n\n
Полиморфизм — единый язык общения. В ООП важно, чтобы все объекты общались друг с другом на понятном им языке. И если у разных объектов есть метод «Удалить», то он должен делать именно это и писаться везде одинаково. Нельзя, чтобы у одного объекта это было «Удалить», а у другого «Стереть».\n
При этом внутри объекта методы могут быть реализованы по-разному. Например, удалить товар — это выдать предупреждение, а потом пометить товар в базе данных как удалённый. А удалить пользователя — это отменить его покупки, отписать от рассылки и заархивировать историю его покупок. События разные, но для программиста это неважно. У него просто есть метод «Удалить()», и он ему доверяет.\n
Такой подход позволяет программировать каждый модуль независимо от остальных. Главное — заранее продумать, как модули будут общаться друг с другом и по каким правилам. При таком подходе вы можете улучшить работу одного модуля, не затрагивая остальные — для всей программы неважно, что внутри каждого блока, если пра-вила работы с ним остались прежними.\n\n
Плюсы и минусы ООП\n
У объектно-ориентированного программирования много плюсов, и именно поэтому этот подход использует большинство современных программистов.\n
•	Визуально код становится проще, и его легче читать. Когда всё разбито на объекты и у них есть понятный набор правил, можно сразу понять, за что отвечает каждый объ-ект и из чего он состоит.\n
•	Меньше одинакового кода. Если в обычном программировании одна функция считает повторяющиеся символы в одномерном массиве, а другая — в двумерном, то у них большая часть кода будет одинаковой. В ООП это решается наследованием.\n
•	Сложные программы пишутся проще. Каждую большую программу можно разложить на несколько блоков, сделать им минимальное наполнение, а потом раз за разом подробно наполнить каждый блок.\n
•	Увеличивается скорость написания. На старте можно быстро создать нужные компоненты внутри программы, чтобы получить минимально работающий прототип.\n\n
А теперь про минусы:\n
•	Сложно понять и начать работать. Подход ООП намного сложнее обычного функционального программирования — нужно знать много теории, прежде чем будет написана хоть одна строчка кода.\n
•	Требует больше памяти. Объекты в ООП состоят из данных, интерфейсов, методов и много другого, а это занимает намного больше памяти, чем простая переменная.\n
•	Иногда производительность кода будет ниже. Из-за особенностей подхода часть вещей может быть реализована сложнее, чем могла бы быть. Поэтому бывает такое, что ООП-программа работает медленнее, чем функциональная (хотя с современными мощностями процессоров это мало кого волнует).
</item>
 <!--19--><item>19.ОСНОВНЫЕ ПРИНЦИПЫ АРХИТЕКТУРЫ ПО.\n\n\n\n\n\n
Архитектура программного обеспечения (англ. software architecture) — совокупность важнейших решений об организации программной системы. Архитектура включает:\n
•	выбор структурных элементов и их интерфейсов, с помощью которых составлена система, а также их поведения в рамках сотрудничества структурных элементов;\n
•	соединение выбранных элементов структуры и поведения во всё более крупные системы;\n
•	архитектурный стиль, который направляет всю организацию — все элементы, их интерфейсы, их сотрудничество и их соединение.\n
Документирование архитектуры программного обеспечения (ПО) упрощает процесс коммуникации между разработчиками, позволяет зафиксировать принятые проектные решения и предоставить информацию о них эксплуатационному персоналу системы, повторно использовать компоненты и шаблоны проекта в других.\n
Общепринятого определения «архитектуры программного обеспечения» не существует. Так, сайт Software Engineering Institute приводит более 150 определений этого понятия.\n
 Область компьютерных наук с момента своего образования столкнулась с проблемами, связанными со сложностью программных систем. Ранее проблемы сложности решались разработчиками путём правильного выбора структур данных, разработки алгоритмов и применения концепции разграничения полномочий. Хотя термин «архитектура программного обеспечения» является относительно новым для индустрии разработки ПО, фундаментальные принципы этой области неупорядоченно применялись пионерами разработки ПО начиная с середины 1980-х. Первые попытки осознать и объяснить программную архитектуру системы были полны неточностей и страдали от недостатка организованности, часто это была просто диаграмма из блоков, соединенных линиями. В 1990-е годы наблюдается попытка определить и систематизировать основные аспекты данной дисциплины. Первоначальный набор шаблонов проектирования, стилей проектирования, передового опыта (best practices), языков описания и формальная логика были разработаны в течение этого времени.\n
Основополагающей идеей дисциплины программной архитектуры является идея снижения сложности системы путём абстракции и разграничения полномочий. На сегодняшний день до сих пор нет согласия в отношении чёткого определения термина «архитектура программного обеспечения».\n
Являясь в настоящий момент своего развития дисциплиной без четких правил о «правильном» пути создания системы, проектирование архитектуры ПО все ещё является смесью науки и искусства. Аспект «искусства» заключается в том, что любая коммерческая система подразумевает наличие применения или миссии. С точки зрения пользователя программной архитектуры, программная архитектура дает направление для движения и решения задач, связанных со специальностью каждого такого пользователя, например, заинтересованного лица, разработчика ПО, группы поддержки ПО, специалиста по сопровождению ПО, специалиста по развертыванию ПО, тестера, а также конечных пользователей. В этом смысле архитектура программного обеспечения на самом деле объединяет различные точки зрения на систему. Тот факт, что эти несколько различных точек зрения могут быть объединены в архитектуре программного обеспечения, является аргументом в защиту необходимости и целесообразности создания архитектуры ПО ещё до этапа разработки ПО.\n\n
История\n
Начало архитектуре программного обеспечения как концепции было положено в научно-исследовательской работе Эдсгера Дейкстры в 1968 году и Дэвида Парнаса в начале 1970-х. Эти ученые подчеркнули, что структура системы ПО имеет важное значение, и что построение правильной структуры — критически важно. Популярность изучения этой области возросла с начала 1990-х годов вместе с научно-исследовательской работой по исследованию архитектурных стилей (шаблонов), языков описания архитектуры, документирования архитектуры, и формальных методов.\n
В развитии архитектуры программного обеспечения как дисциплины играют важную роль научно-исследовательские учреждения. Мэри Шоу и Дэвид Гэрлан из университета Carnegie Mellon написали книгу под названием «Архитектура программного обеспечения: перспективы новой дисциплины в 1996 году», в которой выдвинули концепции архитектуры программного обеспечения, такие как компоненты, соединители (connectors), стили и так далее. В калифорнийском университете институт Ирвайна по исследованию ПО в первую очередь исследует архитектурные стили, языки описания архитектуры и динамические архитектуры.\n
Первым стандартом программной архитектуры является стандарт IEEE 1471: ANSI / IEEE 1471—2000: Рекомендации по описанию преимущественно программных систем. Он был принят в 2007 году, под названием ISO ISO / IEC 42010:2007.\n\n
Языки описания архитектуры\n
Языки описания архитектуры (ADLS) используются для описания архитектуры программного обеспечения. Различными организациями было разработано несколько различных ADLS, в том числе AADL (стандарт SAE), Wright (разработан в университете Carnegie Mellon), Acme (разработан в университете Carnegie Mellon), xADL (разработан в UCI), Darwin (разработан в Imperial College в Лондоне), DAOP-ADL (разработан в Университете Малаги), а также ByADL (Университет L’Aquila, Италия). Общими элементами для всех этих языков являются понятия компонента, коннектора и конфигурации. Также, помимо специализированных языков, для описания архитектуры часто используется унифицированный язык моделирования UML.\n\n
Виды (views)\n
Архитектура ПО обычно содержит несколько видов, которые аналогичны различным типам чертежей в строительстве зданий. В онтологии, установленной ANSI / IEEE 1471—2000, виды являются экземплярами точки зрения, где точка зрения существует для описания архитектуры с точки зрения заданного множества заинтересованных лиц.\n
Архитектурный вид состоит из 2 компонентов:\n
•	Элементы\n
•	Отношения между элементами\n\n
Архитектурные виды можно поделить на 3 основных типа:\n
1.	Модульные виды (англ. module views) — показывают систему как структуру из различных программных блоков.\n
2.	Компоненты-и-коннекторы (англ. component-and-connector views) — показывают систему как структуру из параллельно запущенных элементов (компонентов) и способов их взаимодействия (коннекторов).\n
3.	Размещение (англ. allocation views) — показывает размещение элементов системы во внешних средах.\n\n
Примеры модульных видов:\n
•	Декомпозиция (англ. decomposition view) — состоит из модулей в контексте отношения «является подмодулем»\n
•	Использование (англ. uses view) — состоит из модулей в контексте отношения «использует» (т.е. один модуль использует сервисы другого модуля)\n
•	Вид уровней (англ. layered view) — показывает структуру, в которой связанные по функциональности модули объединены в группы (уровни)\n
•	Вид классов/обобщений (англ. class/generalization view) — состоит из классов, связанные через отношения «наследуется от» и «является экземпляром»\n\n
Примеры видов компонентов-и-коннекторов:\n
•	Процессный вид (англ. process view) — состоит из процессов, соединённых операциями коммуникации, синхронизации и/или исключения\n
•	Параллельный вид (англ. concurrency view) — состоит из компонентов и коннекторов, где коннекторы представляют собой «логические потоки»\n
•	Вид обмена данными (англ. shared-data (repository) view) — состоит из компонентов и коннекторов, которые создают, сохраняют и получают постоянные данные\n
•	Вид клиент-сервер (англ. client-server view) — состоит из взаимодействующих клиентов и серверов, а также коннекторов между ними (например, протоколов и общих сообщений)\n\n
Примеры видов размещения:\n
•	Развертывание (англ. deployment view) — состоит из программных элементов, их размещения на физических носителях и коммуникационных элементов\n
•	Внедрение (англ. implementation view) — состоит из программных элементов и их соответствия файловым структурам в различных средах (разработческой, интеграционной и т.д.)\n
•	Распределение работы (англ. work assignment view) — состоит из модулей и описания того, кто ответственен за внедрение каждого из них
Хотя было разработано несколько языков для описания архитектуры программного обеспечения, в настоящий момент нет согласия по поводу того, какой набор видов должен быть принят в качестве эталона. В качестве стандарта «для моделирования программных систем (и не только)» был создан язык UML.\n\n
Архитектурные шаблоны\n
Для удовлетворения проектируемой системы различным атрибутам качества применяются различные архитектурные шаблоны (паттерны). Каждый шаблон имеет свои задачи и свои недостатки.\n\n
Примеры архитектурных шаблонов:\n
•	Многоуровневый шаблон (Layered pattern). Система разбивается на уровни, которые на диаграмме изображаются один над другим. Каждый уровень может вызывать только уровень на 1 ниже него. Таким образом разработку каждого уровня можно вести относительно независимо, что повышает модифицируемость системы. Недостатками данного подхода являются усложнение системы и снижение производительности.\n
•	Шаблон посредника (Broker pattern). Когда в системе присутствует большое количество модулей, их прямое взаимодействие друг с другом становится слишком сложным. Для решения проблемы вводится посредник (например, шина данных), по которой модули общаются друг с другом. Таким образом, повышается функциональная совместимость модулей системы. Все недостатки вытекают из наличия посредника: он понижает производительность, его недоступность может сделать недоступной всю систему, он может стать объектом атак и узким местом системы.\n
•	Шаблон «Модель-Представление-Контроллер» (Model-View-Controller pattern). Т.к. требования к интерфейсу меняются чаще всего, то возникает потребность часто его модифицировать, при этом сохраняя корректное взаимодействие с данными (чтение, сохранение). Для этого в шаблоне Model-View-Controller (MVC) интерфейс отделён от данных. Это позволяет менять интерфейсы, равно как и создавать их разные варианты. В MVC система разделена на:\n
o	Модель, хранящую данные\n
o	Представление, отображающее часть данных и взаимодействующее с пользователем\n
o	Контроллер, являющийся посредником между видами и моделью\n
Однако, концепция MVC имеет и свои недостатки. В частности, из-за усложнения взаимодействия падает скорость работы системы.\n
•	Клиент-серверный шаблон (Client-Server pattern). Если есть ограниченное число ресурсов, к которым требуется ограниченный правами доступ большого числа потребителей, то удобно реализовать клиент-серверную архитектуру. Такой подход повышает масштабируемость и доступность системы. Но при этом сервер может стать узким местом системы, при его недоступности становится недоступна вся система.\n\n
Базовые фреймворки для архитектуры ПО\n
Существуют следующие фреймворки (англ. software architecture frameworks), относящиеся к области архитектуры ПО:\n
•	4+1\n
•	RM-ODP (Reference Model of Open Distributed Processing)\n
•	Service-Oriented Modeling Framework (SOMF)\n
Такие примеры архитектур, как фреймворк Захмана (Zachman Framework), DoDAF и TOGAF, относятся к области архитектуры предприятия (enterprise architectures).\n
</item>
 <!--20--><item>Уругвай</item>
 <!--21--><item>Уругвай</item>
 <!--22--><item>Уругвай</item>
 <!--23--><item>23.РАЗВИТИЕ ЯЗЫКОВ WEB-ПРОГРАММИРОВАНИЯ.\n\n\n\n\n\n
Веб-программирование — раздел программирования, ориентированный на разработку веб-приложений (программ, обеспечивающих функционирование динамических сайтов Всемирной паутины).\n
Языки веб-программирования — это языки, которые в основном предназначены для работы с веб-технологиями. Языки веб-программирования можно условно разделить на две пересекающиеся группы: клиентские и серверные.\n\n
 Клиентские языки\n
Как следует из названия, программы на клиентских языках обрабатываются на стороне пользователя, как правило, их выполняет браузер. Это и создает главную проблему клиентских языков — результат выполнения программы (скрипта) зависит от браузера пользователя. То есть, если пользователь запретил выполнять клиентские программы, то они исполняться не будут, как бы ни желал этого программист. Кроме того, может произойти такое, что в разных браузерах или в разных версиях одного и того же браузера один и тот же скрипт будет выполняться по-разному. С другой стороны, если программист возлагает надежды на серверные программы, то он может упростить их работу и снизить нагрузку на сервер за счет программ, исполняемых на стороне клиента, поскольку они не всегда требуют перезагрузку (генерацию) страницы.\n\n
Серверные языки\n
Когда пользователь дает запрос на какую-либо страницу (переходит на неё по ссылке или вводит адрес в адресной строке своего браузера), то вызванная страница сначала обрабатывается на сервере, то есть выполняются все программы, связанные со страницей, и только потом возвращается к посетителю по сети в виде файла. Этот файл может иметь расширения HTML, PHP, ASP, ASPX, Perl, SSI, XML, DHTML, XHTML.\n
Работа программ уже полностью зависима от сервера, на котором расположен сайт, и от того, какая версия того или иного языка поддерживается. К серверным языкам программирования можно отнести PHP, Perl, Python, Ruby, любой .NET язык программирования (технология ASP.NET), Java, Groovy, Javascript.\n
Важной стороной работы серверных языков является возможность организации непосредственного взаимодействия с системой управления базами данных (или СУБД) — сервером базы данных, в которой упорядоченно хранится информация, которая может быть вызвана в любой момент.\n\n
История появления\n
С середины годов, 1990-х веб-разработка была одной из наиболее динамично развивающихся отраслей в мире. В 1995 году меньше, было чем 1000 веб-разработки компании в Соединенных Штатах, но к 2005 году насчитывалось более 30000 таких компаний, только США. в Сети развития промышленности ожидается рост на 20% к 2010 году. Рост этой отрасли толкают крупных желающих компаний, продавать товары и услуги для своих клиентов и автоматизировать. Вместо стоимости в десятки тысяч долларов, как это в было случае раннего создания веб-сайтов, теперь можно разработать простой веб-сайт для менее тысячи долларов, в зависимости от сложности и содержания. объема веб-компании. Малые разработки сайта теперь имеют возможность сделать веб-дизайн доступным небольшим компаниям и частным лицам и дают толчок росту индустрии веб-разработки. что касается веб-разработки инструментов и платформ, существует множество систем для получения доступной бесплатной помощи. Известным примером является LAMP (Linux, Apache, MySQL, PHP), которая обычно распространяется бесплатно. Уже одно это обстоятельство является фактором создания новых сайтов ежедневно, тем самым способствуя увеличению популярности развития Веб. Другим фактором стало использование WYSIWYG Web.\n
С использованием таких программ практически каждый может разработать веб-страницу в считанные минуты. HyperText Markup Language (HTML), или другие Языки программирования не требуются, но рекомендуется в профессиональном программировании.\n
Примерами глубоких преобразований в области связи с торговлей на базе веб-разработки является электронная торговля. Интернет-аукцион сайтов, таких как eBay изменили образ потребителя потреблять и приобретать товары услуги. Интернет-реселлеры, такие как Amazon.com и Buy.com (среди многих, многих других), превратили торговые сделки в простую операцию для многих потребителей. Другой хороший пример трансформационной связи, связанный с развития веб-блогов, это работа веб-приложений, таких как MovableType, WordPress. Open Source Content систем, такие как Alfresco, Typo3, Xoops, Joomla!, Drupal распространили в веб-разработке новые формы взаимодействия и общения.\n
Кроме того, разработка сайтов перешла на новый этап в Интернете. в сайты. Компьютерные Сети уже не просто инструмент для работы и торговли, но и площадка для общения. Сайты, тем или иным предоставляют пользователям платформу для свободного общения.\n\n
Язык HTML\n
Язык HTML был разработан британским учёным Тимом Бернерсом-Ли приблизительно в 1986--1991 годах в стенах Европейского Центра ядерных исследований в Женеве (Швейцария).\n
HTML создавался как язык для обмена научной и технической документацией, пригодный для использования людьми, не являющимися специалистами в области вёрстки. HTML успешно справлялся с проблемой сложности SGML путём определения небольшого набора структурных и семантическихэлементов -- дескрипторов.\n\n

Данный язык прост в освоении и является классическим языком. С помощью него написаны многие сайты можно даже сказать что 90% сайтов написано с его использованием. С годами данный язык совершенствовался и совершенствуется по сей день.\n
HTML 2.0 - Стандарт был утвержден в ноябре 1944 г. организацией IETF (Internet Engineering Task Force ). В нем были расширены возможности предыдущей версии языка и он получил широкое распространение как у профессионалов, так и любителей.\n
HTML 3.0 - Проект версии языка был опубликован в марте 1995 г. В нем были произведены радикальные изменения предыдущих версий включены дополнительные возможности, включая таблицы, математические выражения и т.д. Это стало причиной того, что он не стал официальной спецификацией и был заменен спецификациейHTML 3.2.\n
HTML 3.2 (кодовое наименование проекта: “Wilbur”) - Был опубликован и начал широко использоватья с мая 1996 г., получил официальное утвержден в 1997 г. Получил популярность из-за совместимости с HTML 2.0.\n
HTML 4.0 (кодовое наименование проекта: “Cougar ”) - последняя версия языка. В нем реализованы многие распространенные концепции Web -дизайна и приняты некоторые средства HTML 3.2. Самым значительным отличием HTML 4.0 от предыдущих версий является кодировка Unicode , тег “ Object”, позволяющий работать с мультимедиа ( в т.ч. с видеоклипами и звуком) и др.\n
HTML5 вводит несколько новых элементов и атрибутов, которые отражают типичное использование разметки на современных веб-сайтах. Некоторые из них -- семантические замены для использования универсальных блочных (&lt;div>) и строчных (&lt;span>) элементов, например, &lt;nav> (блок навигации по сайту), &lt;footer>(обычно относится к нижней части страницы или последней строке HTML кода) или &lt;audio> и &lt;video> вместо &lt;object>\n
На данный момент последней версией является HTML 5.\n\n

Язык JavaScript
JavaScript является языком сценариев (скриптов), который применяют в основном для создания на Web-страницах интерактивных элементов. Его можно использовать для построения меню, проверки правильности заполнения форм, смены изображений или для чего-то еще, что можно сделать на Web-странице. Если взглянуть на Google Maps или службу GMail компании Google, то можно понять, на что способен сегодня язык JavaScript.\n
Так как JavaScript является в настоящее время единственным языком сценариев, который поддерживают все основные браузеры Web (Internet Explorer, Firefox, Netscape, Safari,Opera, Camino и т.д.), то он используется очень широко.\n
Код JavaScript обычно выполняется Web-браузером клиента, и в этом случае он называется сценарием на стороне клиента. Но код JavaScript можно выполнять также на Web-сервере для формирования документов HTML, воплощая тем самым сценарий на стороне сервера. Хотя использование JavaScript обычно ограничивается сценариями на стороне клиента, он является также очень мощным серверным языком.\n
При создании кода JavaScript требуется фактически только текстовый редактор и Web-браузер. Знание HTML и CSS будет играть определенно положительную роль, и если вы захотите использовать навыки JavaScript на Web-сайте, то понадобится также Web-сайт. Если у вас уже есть Web-сайт, то отлично! Если нет, то существует множество бесплатных серверов, которые можно использовать для размещения своих страниц. Что касается текстового редактора, то в Windows имеется редактор NotePad. Хотя этого будет достаточно для редактирования JavaScript, HTML и CSS, более мощный редактор, такой, например, как EditPlus или другой, может оказаться более удобным. Ну, а теперь можно перейти к созданию сценария JavaScript!\n
Прежде всего, необходимо узнать, как добавить сценарий JavaScript на страницу HTML. Это можно сделать одним из двух способов: поместить теги Script на Web-странице и расположить код JavaScript внутри этих тегов, или поместить весь код JavaScript в отдельный файл и связаться с ним с помощью тега Script. Любой из этих методов вполне допустим, но они имеют разное назначение. Если имеется небольшой код, который будет использоваться только на одной странице, то размещение его между тегами Script будет хорошим решением. Если, однако, имеется большой фрагмент кода, который будет использоваться на нескольких страницах, то, наверно, лучше поместить этот код JavaScript в отдельный файл и соединиться с ним. Это делается для того, чтобы не нужно было загружать этот код всякий раз при посещении различных страниц. Код загружается один раз, и браузер сохраняет его для последующего использования. Это похоже на то, как используются каскадные таблицы стилей (CSS).\n

</item>
 <!--24--><item>24.СОСТАВНЫЕ ЭЛЕМЕНТЫ HTML-ДОКУМЕНТА. ТИПЫ ДАННЫХ HTML.\n\n\n\n\n
1. Составные элементы HTML-документа\n
1.1 Элементы и теги\n
HTML — это теговый язык разметки документов. Иными словами, любой документ на языке HTML представляет собой набор элементов, причем начало и конец каждого элемента обозначается специальными пометками, называемыми тегами.\n
Элементы — это структуры, которые описывают отдельные составляющие HTML-документа. Элемент состоит из трех частей: начального тега, содержимого и конечного тега. Тег — это специальный текст, заключенный в угловые скобки "&lt;" и ">". Конечный тег имеет то же имя, что начальный тег, но начинается с косой черты "/". Например, элемент EM (выделение текста) выглядит так:\n
<EM>выделяемый текст</EM>\n
Имена элементов могут быть набраны в любом регистре, т. е. &lt;EM> и &lt;em> равнозначны.\n
Элементы должны либо следовать друг за другом, либо быть вложены один в другой. Если начальный тег <EM> расположен внутри элемента <P>…</P>, то и конечный тег </EM> должен быть расположен внутри этого элемента.\n
Конечные теги некоторых элементов могут быть опущены. Например, конечный тег элемента LI (пункт списка) не обязателен, поскольку начало очередного пункта списка означает конец предыдущего пункта:\n
&lt;UL>\n
  &lt;LI>Первый пункт списка без конечного тега\n
  &lt;LI>Второй пункт списка с необязательным конечным тегом&lt;/LI>\n
  &lt;LI>Третий пункт списка без конечного тега\n
&lt;/UL>\n
Мы, однако, рекомендуем указывать конечный тег элемента даже в тех случаях, когда стандарт позволяет его опустить. Для этого есть две причины:\n
•	при использовании каскадных таблиц стилей отсутствие конечного тега элементов часто приводит к непредсказуемым результатам;\n
•	в соответствии со стандартом XHTML, описанным ниже, каждый элемент должен иметь конечный тег.\n
Некоторые элементы, такие, как BR (новая строка), не имеют конечного тега, поскольку не имеют содержимого.\n\n
1.2. Атрибуты\n
Атрибуты элемента определяют его свойства. Например, элемент IMG (графический образ) имеет атрибут src, указывающий расположение графического файла, и атрибут alt, задающий альтернативный текст на тот случай, если обозреватель не отображает графику:\n
&lt;IMG src="mylogo.gif" alt="Юрий Лукач">\n
Атрибуты всегда включаются в начальный тег элемента и имеют вид:\n
имя_атрибута="значение_атрибута"\n
Значение атрибута может быть заключено в одинарные или двойные кавычки. Кавычки можно опустить, если значение атрибута состоит только из латинских букв (A-Za-z), цифр (0-9), дефисов ("-"), подчеркиваний ("_"), двоеточий (":") и точек (".").\n
Имена атрибутов могут быть набраны в любом регистре, но их значения могут зависеть от регистра. Мы для определенности всюду в дальнейшем пишем имена элементов прописными буквами, а именами атрибутов строчными.\n\n
1.3. Специальные символы\n
Ряд символов в языке HTML зарезервирован и должен представляться специальным образом:\n
левая угловая скобка ("&lt;")	"&amp;lt";\n
правая угловая скобка (">")	"&amp;gt";\n
амперсант ("&amp;")	"&amp;amp";\n
двойная кавычка (\") "&amp;quot;"\n
Для некоторых символов, отсутствующих на клавиатуре, также есть специальные обозначения. Например, символ авторского права © представляется как "&amp;copy";.\n
При желании авторы могут пользоваться и числовой кодировкой символов в стандарте Unicode. При этом символ может быть задан своим десятичным кодом (&amp;#код;) или шестнадцатеричным кодом (&amp;#xкод;). Например &#169; представляет символ авторского права ©, а &#x410; – русскую букву А.\n\n
1.4. Комментарии\n
HTML-документы могут содержать комментарии, которые не влияют на отображение документа, а только поясняют его содержимое при просмотре HTML-текста. Комментарии в HTML имеют довольно сложный синтаксис, поэтому мы рекомендует следовать следующим четким правилам:\n
•	начинайте комментарий с символов "&lt;!--",\n
•	завершайте комментарий символами "-->",\n
•	не используйте внутри комментария символов "--".\n\n
Пример комментариев:\n
        &lt;!-- это комментарий -->\n
        &lt;!-- а вот еще комментарий,\n
             занимающий более одной строки -->\n\n

2. Типы данных HTML\n
Значения атрибутов в языке HTML могут иметь различные типы данных. Основными типами данных являются следующие.\n\n
CDATA - Значения атрибутов типа CDATA являются цепочками символов, включая, возможно, специальные символы. Обычно (но не всегда) значения типа CDATA зависят от регистра.\n\n
ID и NAME - Значения атрибутов должны состоять только из латинских букв, цифр, дефисов, подчеркиваний, двоеточий и точек. Эти значения зависят от регистра. Они отличаются тем, что NAME может содержать специальные символы, а ID не может.\n\n
IDREF и IDREFS - Значения указывают на идентификаторы, т. е. на значения атрибута id других элементов. Значение типа IDREF — это единственный идентификатор, а значение типа IDREFS — это список идентификаторов, разделенных пробелами. IDREF и IDREFS зависят от регистра.\n\n
Число - Числовые значения атрибутов — это десятичные числа, состоящие хотя бы из одной цифры.\n\n
Текст - Текстовые значения атрибутов — это значения типа CDATA, представляющие собой осмысленный текст.\n\n
URI - Значения атрибутов типа URI(Любой ресурс в Сети имеет уникальный адрес, по которому этот ресурс может быть найден. протокол://авторизация/путь?запрос) — это унифицированные идентификаторы ресурсов (полные или относительные).\n\n
Цвет - Цветовые значения атрибутов могут задаваться либо шестнадцатеричным числом с префиксом "#" вида "#rrggbb", задающим RGB-код цвета, либо одним из 16-ти символических имен. Имена цветов не зависят от регистра.\n\n
Пиксели - Значения этого типа — целые числа, задающие количество пикселей.\n\n
Размер - Значения этого типа — либо целые числа, задающие количество пикселей, либо доли в процентах от размера по горизонтали или вертикали: например, 50% означает половину всего размера, а 50 означает 50 пикселей.\n\n
Кратный размер - Кратный размер — это либо целое число, задающее количество пикселей, либо доля в процентах от размера по горизонтали или вертикали, либо относительный размер вида i*, где i — целое число. При распределении пространства обозреватель сначала выделяет место для размеров, заданных в числах и процентах, а затем разделяет оставшееся пространство между элементами с относительными размерами. Элементу размером 3* будет выделено пространство в три раза большее, чем элементу размером 1*. Значение * эквивалентно 1* и часто означает "заполнить оставшееся пространство".\n\n
Кратные размеры - Значения этого типа — список кратных размеров, разделенных запятыми.\n\n
Тип файла - Значения атрибутов этого типа задают типы файлов MIME (audio, image, message) для связанных или вложенных ресурсов.\n\n
Типы файлов - Значения этого типа — список типов файлов, разделенных запятыми.\n\n
Код языка - Код языка не зависит от регистра и не должен содержать пробелов (атрибут lang значение ru для русского языка).\n\n
Кодировка и Кодировки - Значение типа Кодировка — это единственное имя таблицы кодировки, а значение типа Кодировки — это список имен, разделенных пробелами или запятыми. Они не зависят от регистра (параметр charset, п-р: charset=”utf-8”).\n\n
Символ - Значение символьного атрибута — это единственный символ Unicode, который может быть также специальным символом.\n\n
Дата-время - Значения атрибутов этого типа задают дату и время в формате ГГГГ-ММ-ДДТчч:мм:ссУВЗ, УВЗ — указатель временной зоны. Буква Т отделяет дату от времени. Если какой-либо из компонентов времени неизвестен, то используется00. Указатель временной зоны может принимать следующие значения:\n\n
· Z (прописная), указывающая на время по Гринвичскому меридиану (UTC, Universal Coordinated Time);\n
· +чч:мм, положительная разница с временем UTC в часах и минутах;\n
· -чч:мм, отрицательная разница с временем UTC в часах и минутах.\n\
Типы ссылок - Значения атрибутов этого типа представляют собой список типов ссылок, разделенных пробелами. Тип ссылки не зависит от регистра и не может содержать пробелов. (Например, в HTML 4.0 пропущен очень популярный тип ссылки Made, обеспечивающий контакт с автором документа: &lt;LINK rev="Made" href="mailto:somebody@somewhere.com">).\n\n
Устройства - Значения атрибутов этого типа представляют собой список имен устройств для отображения документа, разделенных пробелами. Имена устройств зависят от регистра (print – принтер, screen – графический дисплей)\n\n
Сценарий - Значения атрибутов этого типа — это сценарии клиента, которые обычно представляют собой вызов функции или несколько операторов на интерпретируемом языке. Синтаксис сценария определяется синтаксическими правилами соответствующего языка программирования.\n\n
Таблица стилей - Значения атрибутов этого типа — таблицы стилей на языке CSS.\n\n
Фрейм - Значения атрибутов этого типа задают имена фреймов. Они должны начинаться с латинской буквы (A-Za-z), за исключением следующих специальных значений (_blank - Загрузить документ в новое безымянное окно. _self - Загрузить документ в окно текущего фрейма. _parent - Загрузить документ в окно предка текущего фрейма._top - Загрузить документ в полное текущее окно, отменяя тем самым все фреймы).\n
</item>
 <!--25--><item>25.ОБЩИЕ АТРИБУТЫ ЭЛЕМЕНТОВ HTML. БЛОЧНЫЕ И СТРОЧНЫЕ ЭЛЕМЕНТЫ.\n\n\n\n
Общие атрибуты HTML\n
В этом разделе находятся атрибуты HTML-тегов, которые для большинства из них являются общими. Вообще, полностью общими для всех тегов данные атрибуты стали только с версии HTML 5, до этого каждый их них поддерживал только определенное количество атрибутов из данного списка. Поэтому, чтобы узнать, поддерживает ли конкретный тег определенный атрибут, например в HTML 4.01, — необходимо перейти на страницу его описания.\n\n
Общие атрибуты\n
•	accesskey — устанавливает клавишу быстрого доступа для фокусировки на элементе.\n
•	class — задает имя класса или классов элемента, используемых в CSS (Каскадные таблицы стилей).\n
•	dir — указывает направление текста внутри элемента.\n
•	id — задает имя идентификатора элемента, который может использоваться в качестве «якоря» для перехода к нему по ссылке (&lt;A>) или в таблицах стилей.\n
•	lang — указывает язык, на котором написан текст внутри элемента.\n
•	style — используется для применения встроенных стилей в CSS.\n
•	tabindex — устанавливает порядок табуляции между элементами (клавиша Tab).\n
•	title — выводит всплывающую подсказку при наведении курсора мыши на элемент.\n

Блочные и строчные элементы\n
Выделяют две основные категории HTML-элементов, которые соответствуют типам их содержимого и поведению в структуре веб-страницы — блочные и строчные элементы. С помощью блочных элементов можно создавать структуру веб-страницы, строчные элементы используются для форматирования текстовых фрагментов (за исключением элементов &lt;area> и &lt;img>).\n
Разделение элементов на блочные и строчные используется в спецификации HTML до версии 4.01. В HTML5 эти понятия заменены более сложным набором категорий контента, согласно которым каждый HTML-элемент должен следовать правилам, определяющим, какой контент для него допустим.\n\n
Модель визуального форматирования CSS в деталях\n\n
1. Модель визуального форматирования\n
HTML-документ организован в виде дерева элементов и текстовых узлов. Модель визуального форматирования CSS представляет собой алгоритм, который обрабатывает HTML-документ и выводит его на экран устройства.\n
Каждый блок в дереве представляет соответствующий элемент или псевдоэлемент, а текст (буквы, цифры, пробелы), находящийся между открывающим и закрывающим тегами, представляет содержимое текстовых узлов.\n
Чтобы создать дерево блоков, CSS сначала использует каскадирование и наследование, позволяющие назначить вычисленное значение для каждого css-свойства каждому элементу и текстовому узлу в исходном дереве.\n
Затем для каждого элемента CSS генерирует ноль или более блоков в соответствии со значением свойства display этого элемента. Как правило, элемент генерирует один основной блок, который представляет самого себя и содержит свое содержимое. Некоторые значение свойства display, например, display: list-item;, генерируют блок основного блока и блок дочернего маркера. Другие, например, display: none;, приводят к тому, что элемент и/или его потомки вообще не генерируют блоки.\n
Положение блоков на странице определяется следующими факторами:\n
o	размером элемента (с учётом того, заданы они явно или нет);\n
o	типом элемента (строчный или блочный);\n
o	схемой позиционирования (нормальный поток, позиционированные или плавающие элементы);\n
o	отношениями между элементами в DOM (родительский — дочерний элемент);\n
o	внутренними размерами содержащихся изображений;\n
o	внешней информацией (например, размеры окна браузера).\n\n
2. Блочные элементы и блочные контейнеры\n
Блочные элементы — элементы высшего уровня, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Значения свойства display, такие как block, list-item и table делают элементы блочными. Блочные элементы генерируют основной блок, который содержит только блок элемента. Элементы со значением display: list-item генерируют дополнительные блоки для маркеров, которые позиционируются относительно основного блока.\n
&lt;address>, &lt;article>, &lt;aside>,\n
&lt;blockquote>,\n
&lt;dd>, &lt;div>, &lt;dl>, &lt;dt>, &lt;details>,\n
&lt;fieldset>, &lt;figcaption>, &lt;figure>, &lt;footer>, &lt;form>,\n
&lt;h1>-&lt;h6>, &lt;header>, &lt;hr>,\n
&lt;li>, &lt;legend>,\n
&lt;nav>, &lt;noscript>,\n
&lt;ol>, &lt;output>, &lt;optgroup>, &lt;option>,\n
&lt;p>, &lt;pre>,\n
&lt;section>, &lt;summary>,\n
&lt;table>,\n
&lt;ul>\n
Блочные элементы могут размещаться непосредственно внутри элемента &lt;body>. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя.\n
Блочные элементы могут содержать как строчные, так и блочные элементы, но не оба типа элементов сразу. При необходимости, строки текста, принадлежащие блочному контейнеру, могут быть обёрнуты анонимными контейнерами, которые будут вести себя внутри блока как элементы со значением display: block;, а строчные элементы обёрнуты элементом &lt;p>. Блочные элементы могут содержаться только в пределах блочных элементов.\n
Элемент &lt;p> относится к блочным элементам, но он не должен содержать внутри себя другой элемент &lt;p>, а также любой другой блочный элемент.\n
Анонимные блоки уровня блока\n
Как говорилось выше, блочные элементы могут содержать только блочные или только строчные элементы. В случае смешанного контента, когда блочный элемент одновременно содержит текстовое содержимое и другой блочный элемент, алгоритм визуального форматирования добавляет дополнительную обёртку для текстового содержимого — так называемый анонимный блок. Анонимный блок не связан ни с одним элементом. Поскольку такой контейнер не имеет названия, то к нему нельзя применить CSS-стили для оформления. Анонимные блоки наследуют свойства окружающего блока, а не наследуемые свойства принимают первоначальное значение.\n\n

3. Строчные элементы и строчные контейнеры
Встроенные (строчные) элементы генерируют внутристрочные контейнеры. Они не формируют новые блоки контента. Значения свойства display, такие как inline и inline-table делают элементы строчными.\n
&lt;a>, &lt;area>,\n
&lt;b>, &lt;bdo>, &lt;bdi>,\n
&lt;cite>, &lt;code>,\n
&lt;dfn>, &lt;del>,\n
&lt;em>,\n
&lt;i>, &lt;iframe>, &lt;img>, &lt;ins>,\n
&lt;kbd>,\n
&lt;label>,\n
&lt;map>, &lt;mark>,\n
&lt;s>, &lt;samp>, &lt;small>, &lt;span>, &lt;strong>, &lt;sub>, &lt;sup>,\n
&lt;time>,\n
&lt;q>,\n
&lt;ruby>,\n
&lt;u>,\n
&lt;var>\n\n

Строчные элементы могут содержать только данные и другие строчные элементы. Исключение составляет элемент &lt;a>, который согласно спецификации HTML5 может оборачивать целые абзацы, списки, таблицы, заголовки и целые разделы при условии, что они не содержат другие интерактивные элементы — другие ссылки и кнопки.\n
Анонимные блоки уровня строки\n
Любой текст, содержащийся непосредственно внутри блочного элемента и не внутри строчного элемента, рассматривается как анонимный строчный элемент. Также как и анонимные блоки уровня блока они наследуют свойства родительского блока, а не наследуемые свойства принимают первоначальное значение.\n\n
4. Строчно-блочные элементы\n
Существует еще одна группа элементов, которые браузер обрабатывает как строчно-блочные {display: inline-block;}. Такие элементы являются встроенным, но для них можно задавать поля, отступы, ширину и высоту.\n
&lt;audio>,\n
&lt;button>,\n
&lt;canvas>,\n
&lt;embed>,\n
&lt;input>,\n
&lt;keygen>,\n
&lt;meter>,\n
&lt;object>,\n
&lt;progress>,\n
&lt;select>,\n
&lt;textarea>,\n
&lt;video>.\n
</item>
 <!--26--><item>26.	СОЗДАНИЕ ТАБЛИЦ В HTML-ДОКУМЕНТАХ. ОСНОВНЫЕ АТРИБУТЫ ТАБЛИЦ, СТРОК, ЯЧЕЕК.\n\n\n\n
HTML-таблицы упорядочивают и выводят на экран данные с помощью строк или столбцов. Таблицы состоят из ячеек, образующихся при пересечении строк и столбцов. Ячейки таблиц могут содержать любые HTML-элементы, такие как заголовки, списки, текст, изображения, элементы форм, а также другие таблицы. Каждой таблице можно добавить связанный с ней заголовок, расположив его перед таблицей или после неё.\n
Таблицы больше не используются для вёрстки веб-страниц и компоновки отдельных элементов, потому что такой приём не обеспечивает гибкость структуры и адаптивность сайта, существенно увеличивая HTML-разметку.\n
Для всех элементов таблицы доступны ‎глобальные атрибуты, а также собственные атрибуты.\n\n
Создание таблиц в HTML\n
1. Как создать таблицу\n
Таблица создаётся при помощи парного тега <table></table>. Данный тег является контейнером для элементов таблицы и все элементы должны находиться внутри него. Например, с помощью данной разметки можно создать таблицу, состоящую из двух столбцов и двух строк:\n
&lt;table>\n
\t\t\t\t&lt;tr>&lt;th>текст заголовка&lt;/th>&lt;th>текст заголовка&lt;/th>&lt;/tr> &lt;!--ряд с ячейками заголовков-->\n
\t\t\t\t&lt;tr>&lt;td>данные&lt;/td>&lt;td>данные&lt;/td>&lt;/tr> &lt;!--ряд с ячейками тела таблицы-->\n
&lt;/table>\n\n

По умолчанию таблица и ячейки не имеют видимых границ. Границы задаются с помощью свойства border:\n
/* внешние границы таблицы серого цвета толщиной 1px */\n
table {border: 1px solid grey;}\n
/* границы ячеек первого ряда таблицы */\n
th {border: 1px solid grey;}\n
/* границы ячеек тела таблицы */\n
td {border: 1px solid grey;}\n\n

Промежутки между ячейками таблицы убираются с помощью свойства table {border-collapse: collapse;}.\n
Ширина таблицы по умолчанию равна ширине её внутреннего содержимого. Чтобы установить ширину, нужно задать значение для свойства width:\n
/* сделает ширину таблицы равной ширине блока контейнера, в котором она находится */\n
table {width: 100%;}\n
/* задаст фиксированную ширину для таблицы */\n
table {width: 600px;}\n\n

Если для ячеек таблицы заданы внутренние отступы и границы, то ширина таблицы будет включать в себя следующие значения:\n
padding-left и padding-right, ширина border-left плюс ширина border-right последней ячейки в ряду. Если заданы ширина и границы ячеек, то ширина таблицы будет складываться из ширины ячеек плюс ширина border-left и ширина border-right последней ячейки в ряду.\n\n
2. Как создать строки (ряды) таблицы\n
Строки или ряды таблицы создаются с помощью тега &lt;tr>. Количество горизонтальных строк таблицы определяется количеством парных тегов &lt;tr>&lt;/tr>.\n\n
3. Как сделать ячейку заголовка столбца таблицы\n
Элемент &lt;th> создаёт заголовок столбца — специальную ячейку, текст в которой выделяется полужирным. Количество ячеек заголовка определяется количеством пар тегов &lt;th>&lt;/th>. Для элемента доступны атрибуты colspan, rowspan, headers.\n\n
&lt;table>\n
&lt;tr>&lt;th>ячейка заголовка&lt;/th>&lt;th>ячейка заголовка&lt;/th>&lt;/tr>\n
&lt;/table>\n\n

4. Как сделать ячейку тела таблицы\n
Элемент &lt;td> создаёт ячейки таблицы, внутрь которых помещаются данные таблицы. Парные теги &lt;td>&lt;/td>, расположенные в одном ряду, определяют количество ячеек в строке таблицы. Количество пар ячеек &lt;td> должно быть равно количеству пар ячеек &lt;th>. Для элемента доступны атрибуты colspan, rowspan, headers.\n\n
&lt;table>\n
&lt;tr>&lt;th>ячейка заголовка&lt;/th>&lt;th>ячейка заголовка&lt;/th>&lt;/tr>\n
&lt;tr>&lt;td>ячейка тела таблицы&lt;/td>&lt;td>ячейка тела таблицы&lt;/td>&lt;/tr>\n
&lt;/table>\n\n

5. Как добавить подпись (заголовок) к таблице\n
Элемент &lt;caption> создает подпись таблицы. Добавляется непосредственно после тега &lt;table>, вне строки или ячейки.\n\n
&lt;table>\n
&lt;caption>Перечень продуктов&lt;/caption>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
    &lt;th>Ед. изм.&lt;/th>\n
    &lt;th>Количество&lt;/th>\n
    &lt;th>Цена за ед. изм., руб.&lt;/th>\n
    &lt;th>Стоимость, руб.&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>\n
  &lt;/tr>\n
&lt;/table>\n\n

6. Группирование строк и столбцов таблицы\n
Элемент &lt;colgroup> создает структурную группу столбцов, выделяя логически однородные ячейки. Группирует один или более столбцов для единого форматирования, позволяя применить стили к столбцам вместо того, чтобы повторять стили для каждой ячейки и для каждой строки. Добавляется непосредственно после тегов &lt;table> и &lt;caption>.\n
Элемент &lt;col> формирует группы столбцов, которые делят таблицу на разделы, не относящиеся к общей структуре, т.е. не содержащие информацию одного типа. Позволяет задавать свойства столбцов для каждого столбца в пределах элемента &lt;colgroup>. С помощью атрибута style можно изменить основной цвет фона ячеек. Для элемента &lt;col> доступен атрибут span, задающий количество столбцов для объединения.\n\n
&lt;table>\n
  &lt;colgroup>\n
    &lt;col span="2" style="background:Khaki">&lt;!-- С помощью этой конструкции задаем цвет фона для первых двух столбцов таблицы-->\n
      &lt;col style="background-color:LightCyan">&lt;!-- Задаем цвет фона для следующего (одного) столбца таблицы-->\n
  &lt;/colgroup>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование&lt;/th>\n
    &lt;th>Цена&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1&lt;/td>\n
    &lt;td>Карандаш цветной&lt;/td>\n
    &lt;td>20,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2&lt;/td>\n
    &lt;td>Линейка 20 см&lt;/td>\n
    &lt;td>30,00&lt;/td>\n
  &lt;/tr>\n
&lt;/table>\n\n

№ п/п Наименование \t\t\t\tЦена\n
\t1 \t\t\tКарандаш цветной 20,00\n
\t2 \t\t\tЛинейка, 20см \t\t\t30,00\n\n

7. Группировка разделов таблицы\n
Элемент &lt;thead> создает группу заголовков для строк таблицы с целью задания единого оформления. Используется в сочетании с элементами &lt;tbody> и &lt;tfoot> для указания каждой части таблицы.\n
Элемент должен быть использован в следующем порядке: как дочерний элемент &lt;table>, после &lt;caption> и &lt;colgroup>, и перед &lt;tbody>, &lt;tfoot> и &lt;tr> элементами. В пределах одной таблицы можно использовать один раз.\n
Элемент &lt;tbody> группирует основное содержимое таблицы. Используется в сочетании с элементами &lt;thead> и &lt;tfoot>.\n
Элемент &lt;tfoot> создает группу строк для представления информации о суммах или итогах, расположенную в нижней части таблицы. Используется в таблице один раз. Располагается после тега &lt;thead>, перед тегами &lt;tbody> и &lt;tr>.\n\n
&lt;table>\n
 &lt;thead>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
     &lt;th>Ед. изм.&lt;/th>\n
     &lt;th>Количество&lt;/th>\n
     &lt;th>Цена за ед.&lt;/th>\n
     &lt;th>Стоимость&lt;/th>\n
  &lt;/tr>\n
 &lt;/thead>\n
&lt;tfoot>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>\n
  &lt;/tr>\n
&lt;/tfoot>\n
&lt;tbody>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
&lt;/tbody>\n
&lt;/table>\n\n

Такая группировка строк была заложена в стандарте в расчете на то, что обозреватели при отображении длинных таблиц обеспечат прокрутку строк данных при сохранении надзаголовка и подзаголовка неподвижными, а при их выводе на принтер смогут использовать надзаголовок и подзаголовок в качестве колонтитулов страницы. Однако, современные обозреватели этого не делают и либо просто отображают &lt;thead> и &lt;tfoot> как строки данных, либо, в лучшем случае, просто помещают соответствующие строки в начало и конец таблицы.\n\n

8. Как объединить ячейки таблицы\n
Атрибуты colspan и rowspan объединяют ячейки таблицы. Атрибут colspan задает количество ячеек, объединенных по горизонтали, а rowspan — по вертикали.\n\n
&lt;table>\n
  &lt;tr>\n
    &lt;th>№ п/п&lt;/th>\n
    &lt;th>Наименование товара&lt;/th>\n
     &lt;th>Ед. изм.&lt;/th>\n
     &lt;th>Количество&lt;/th>\n
     &lt;th>Цена за ед. изм., руб.&lt;/th>\n
     &lt;th>Стоимость, руб.&lt;/th>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>1.&lt;/td>\n
    &lt;td>Томаты свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>15,20&lt;/td>&lt;td>69,00&lt;/td>&lt;td>1048,80&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td>2.&lt;/td>\n
    &lt;td>Огурцы свежие&lt;/td>&lt;td>кг&lt;/td>&lt;td>2,50&lt;/td>&lt;td>48,00&lt;/td>&lt;td>120,00&lt;/td>\n
  &lt;/tr>\n
  &lt;tr>\n
    &lt;td colspan="5" style="text-align:right">ИТОГО:&lt;/td>&lt;td>1168,80&lt;/td>&lt;!-- Задаем количество ячеек по горизонтали для объединения-->\n
  &lt;/tr>\n
&lt;/table>\n\n

9. Атрибуты элементов таблицы\n
ТАБЛИЦА 1. АТРИБУТЫ ЭЛЕМЕНТОВ ТАБЛИЦЫ\n
Атрибут	Описание, принимаемое значение\n
colspan	Количество ячеек в строке для объединения по горизонтали.\n
&lt;td colspan="3">\n
Возможные значения: число от 1 до 999.\n
headers	Задает список ячеек заголовка, содержащих информацию о заголовке текущей ячейки данных. Предназначен для речевых браузеров.\n
&lt;th id="идентификатор">...&lt;/th>\n
&lt;th headers="идентификатор">...&lt;/th>\n
Принимаемые значения: список имен ячеек, разделенных пробелами; эти имена должны быть присвоены ячейкам через их атрибут id.\n
rowspan	Количество ячеек в столбце для объединения по вертикали.\n
&lt;td rowspan="2">\n
Возможные значения: число от 1 до 999.\n
span	Количество колонок, объединяемых для задания единого стиля, по умолчанию равно 1.\n
&lt;col span="2">\n
Принимаемые значения: любое целое положительное число.\n
</item>
 <!--27--><item>27.ПОНЯТИЕ ОБЪЕКТА В HTML-ДОКУМЕНТАХ. ЭЛЕМЕНТЫ ФОРМ.\n\n\n\n\n
Общие понятия об объектах в HTML\n
Для того, чтобы добавить создаваемым Web-страницам дополнительные возможности, мы можем вставлять в состав их содержимого специализированные функциональные элементы. В качестве подобных элементов часто выступают Java-апплеты, элементы ActiveX, Flash-ролики и многое другое. Как их обрабатывает браузер, нас заботить не должно. Он все равно сделает это правильно. Нас интересует, как их внедрять в Web-страницы.\n
До тех пор, пока мы не научились сами создавать функциональные объекты, пользуясь какой-либо достаточно серьезной технологией, часто требующей хороших навыков программиста, мы можем использовать подобные компоненты от сторонних производителей. Благо подобные компоненты в изобилии выложены в Сети. Главное, их найти и правильно внедрить в Web-страницу.\n
Для вставки некоего функционального объекта, следует воспользоваться тэгом <object>. Для него существует и закрывающий тэг </object>. Между этими двумя тэгами обычно размещается список дополнительных данных, которые передаются объекту в качестве параметров, и некий текст, который будет отображаться, если браузер все-таки не сможет правильно обработать внедренный объект. Здесь необходимо различать свойства объекта, которые мы задаем при помощи параметров тэга, и дополнительные данные, которые передаются как параметры самого объекта при помощи специализированных тэгов.\n
Так, например, если мы хотим вставить в свою Web-страницу некий элемент ActiveX, демонстрирующий изменение некоторой зависимости на графике, то нам потребуется, помимо внедрения самого объекта, установить еще и начальные данные. Для этого придется воспользоваться приблизительно следующей конструкцией:\n\n
&lt;object classid="clsid:EB39F965-2374-llD3-85Fl-F21"\n
\t\t\tcodebase="http://www.mysite.com/scripts..."\n
\t\t\twidth="500 height-300 align center">\n
\t\t\t&lt;param name="start" value="0" valuеtype="data">\n
\t\t\t<p>K сожалению, Ваша операционная система не поддерживает технологию ActiveX</p>\n
&lt;object>\n\n
В данном примере мы при объявлении внедренного объекта использовали в объявляющем тэге несколько параметров. Параметр classid применяется для установки идентификатора внедряемого элемента, а параметр codebase задает URL файла, в котором и содержится внедряемый объект. Обычно для распространяемых объектов подобные параметры детально описываются в сопроводительном тексте. Чуть позже мы подробно рассмотрим все параметры этого тэга. После тэга &lt;object> мы разместили тэг &lt;param>, при помощи которого задали начальные данные для внедренного объекта. Проще всего рассматривать подобные передаваемые параметры как переменные. На каждую передаваемую переменную требуется один тэг &lt;рагаm>. Но теперь, все-таки, перейдем к рассмотрению многочисленных параметров тэга &lt;оbject>.\n
  •  Параметр classid, как мы уже знаем, применяется для установки уникального идентификатора внедряемого элемента. Часто его просто необходимо использовать, так как внедряемый элемент сохраняется в локальной системе пользователя, как, например, элементы ActiveX.\n
•  Параметр codebase предназначен для указания URL, который указывает на некий файл или каталог, в котором располагаются все необходимые для функционирования внедряемого элемента файлы.\n
•  Параметр data предназначен для задания местоположения графических изображений или иных блоков данных, которые используются встраиваемым объектом для своей деятельности. В качестве значения параметра используется URL, указывающий на файл с требуемым блоком данных.\n
•  Параметр type задает тип данных, на которые указывает предыдущий параметр. В качестве значения данного параметра используется одно из стандартных наименований типов данных, определенных в протоколе HTTP.\n
•  Параметр codetype позволяет указывать тип подключаемого объекта. Рекомендуется использовать данный параметр в тех случаях, когда информации, находящейся в параметре classid недостаточно для того, чтобы четко указать тип внедряемого элемента.\n
•  Параметр archive позволяет указывать местоположение архивных данных, которые имеют отношение к внедренному объекту, например, его обновлению. В некоторых случаях это позволяет сократить общее время загрузки новой версии внедряемого объекта. В качестве значения данного параметра используется список URL, разделенный пробелами.\n
•  Параметр declare не имеет значений. Если он входит в состав тэга &lt;object>, то внедряемый объект просто объявляется, но не вставляется в Web-страницу. Обычно параметр применяется, если у нас есть несколько тэгов &lt;object>, вставленных друг в друга.\n
•  Параметр standby позволяет задавать текст, который будет отображаться на месте объекта, пока он сам загружается из Сети. В качестве значения параметра используется обычная текстовая строка.\n
•  Параметр height предназначен для явного указания высоты объекта. В качестве значения параметра используется количество пикселов, абсолютное или кратное, или процентное соотношение.\n
•  Параметр width позволяет явно задавать ширину внедряемого объекта. В качестве значения используется один из стандартных вариантов задания размеров.\n
•  Параметр usemap используется, если внедряемый объект является графическим изображением, которое предназначено для использования в качестве сегментированной карты. Вопросы использования сегментированной графики мы рассматривали в разделе, посвященном гиперссылкам. В качестве значения параметра используется имя карты ссылок, заданное в параметре name тэга &lt;тар>, объявляющего подключаемую карту сегментов.\n
•  Параметр name позволяет задавать уникальное идентифицирующее имя данного конкретного внедряемого объекта.\n
•  Параметр tabindex Позволяет задавать порядковый номер объекта в последовательности органов управления, размещенных на Web-странице, переход между которыми производится при помощи клавиши табуляции.\n
•  Параметр hspace задает размеры свободного пространства по горизонтали между встроенным объектом и остальным содержимым Web-страницы. В качестве значения, используется число, обозначающее количество пикселов в отступе.\n
•  Параметр vspace позволяет задавать отступы про вертикали. В качестве значения используется все то же количество пикселов.\n
•  Параметр border задает толщину границы, обрамляющей внедренный объект. В качестве значения используется количество пикселов.\n
•  Параметр align позволяет задавать вертикальное или горизонтальное выравнивание объекта относительно остального содержимого Web-страницы. В качестве значения используется одно из уже знакомых нам ключевых слов: bottom, middle, top, left, right. Механизм их действия подробно описывался в разделе, посвященном использованию графики.\n
Если встраиваемому объекту необходимо передавать начальные данные для работы, то для этих целей применяется тэг &lt;param>, который мы уже упоминали ранее. Он помещается между тэгами <object> и </object>. Если мы передаем данные объекту, то тот принимает их как переменные. Следовательно, нам необходимо задать имя этой переменной, чтобы объект мог правильно ее распознать, и значение переменной. Это минимальные требования. На самом деле, мы можем сделать больше. Все эти действия производятся при помощи параметров &lt;param>. Всего этих параметров — пять. Помимо общего идентифицирующего параметра id, есть и четыре специфичных.\n
•  Параметр name является обязательным для тэга &lt;param>. При помощи значения этого параметра мы устанавливаем имя передаваемой переменной. Значением параметра является текст. Так как существуют самые различные методы создания встраиваемых объектов, то может получиться так, что это наименование переменной будет чувствительно к регистру символов. Поэтому стоит придерживаться того наименования, которое приводится в описании объекта.\n
•  Параметр value предназначен для установки значения передаваемой переменной. Значением данного параметра является текст. Встраиваемый объект сам берет на себя его распознавание.\n
•  Параметр valuetype позволяет задавать тип передаваемого значения. Это могут быть данные в каком-либо стандартизованном формате, ссылка на некий ресурс в Сети или другой объект. Кроме того, некоторые встраиваемые объекты в качестве переменных могут принимать другие объекты, причем, их тип может и не совпадать. В качестве значения параметра может использоваться одно из трех ключевых слов. Значение data, установленное по умолчанию, указывает, что используется стандартная переменная, передающая данные какого-либо типа. Как и упоминалось, мы передаем данные как строку, а объект сам интерпретирует их. Значение ref указывает, что в качестве переменной передается ссылка на какой-либо ресурс в Сети: А значение object сигнализирует, что мы передаем в качестве стартовых данных другой объект.\n
•  Параметр type используется в тех случаях, когда параметр valuetype имеет значение ref, т.е. когда в качестве переменной мы передаем ссылку на некий ресурс в Сети. Данный параметр указывает, какой тип имеет ресурс, на который мы ссылаемся.\n
И на этом перечень используемых параметров тэга &lt;param> заканчивается. Еще раз напомню, что когда мы берем из Сети некий встраиваемый объект, к нему всегда прилагается сопроводительный текст, в котором рассказывается, как подключать данный объект, и какие стартовые данные ему нужны для работы. Внимательно читайте инструкцию, это может серьезно сэкономить вам время.\n
Среди встраиваемых объектов HTML выделяет в особую группу Java-апплеты. Для того, чтобы внедрить их в состав содержимого Web-страниц, предусмотрен специализированный тэг &lt;applet>. Но прежде, чем мы разберем его использование, стоит все-таки узнать, что такое Java-апплеты.\n
Язык Java изначально задумывался для создания приложений, которые бы выполнялись на любой компьютерной платформе без изменения кода, т. е. с использованием Java не нужно писать отдельные версии программного обеспечения для компьютеров на базе Intel-процессоров и компьютеров семейства Macintosh, или для различных операционных систем.\n
Подобная "многоликость" достигается за счет очень остроумного решения. Java-приложения записываются не в кодах какого-либо процессора, как обычные исполняемые программы, а в своем специализированном формате, называемом байт-кодом. Этот байт-код распознается не процессором, а другим приложением, которое называется виртуальной Java-машиной, Вот эта виртуальная Java-машина пишется для каждой компьютерной системы отдельно. Она переводит байт-код в команды процессора. Эти виртуальные Java-машины написаны уже почти для каждой операционной системы, поэтому Java-приложения медленно, но верно завоевывают популярность.\n
Естественно, возможность выполнения кода на любой компьютерной системе — это именно то, чего не хватает WWW. Ведь если документы читают браузеры, то активные элементы должны обрабатываться непосредственно операционной системой; и если сделать ставку на какое-либо решение, которое действует только в одной системе, то тем самым мы отсекаем от своего ресурса пользователей остальных компьютерных платформ и операционных систем.\n
Поэтому был разработан дополнительный стандарт облегченных Java-приложений, которые могли бы внедряться в Web-страницы. Подобные облегченные Java-приложения называются Java-апплетами. Вставляются в содержимое Web-страниц они при помощи тэга <appiet>. Но специфика использования его ничем не отличаются от правил использования тэга &lt;object>. И наборы параметров этих двух тэгов практически не различаются. В тэге &lt;applet> могут применяться параметры codebase, code, name, archive, width, height, alt, align, hspace, vspace. Естественно, функциональность этих параметров не отличается от функциональности их близнецов, используемых в тэге &lt;object>. Между тэгами &lt;applet> и </appiet> могут размещаться тэги &lt;param>, задающие стартовые данные для Java-апплета.\n
Следует обратить внимание на то, что в списке параметров отсутствует параметр classid. Дело в том, что тэг; &lt;applet> применяется для объектов строго фиксированного типа, для апплетов, а они унаследовали пакетную структуру из своего прародителя — языка Java. Java-апплеты, если говорить более точно, представляют собой не просто какие-то файлы, а, так называемые, классы, хранимые в Java-пакетах. Поэтому для идентификации используется просто наименование класса, которое записывается в параметре name.\n
И на этом мы заканчиваем рассмотрение внедряемых исполняемых объектов. Еще раз повторюсь: до тех пор, пока вы не умеете создавать их самостоятельно, а для этого необходимо уметь программировать немного лучше начального уровня, следует использовать общедоступные внедряемые элементы. Однако при их использовании все-таки следует соблюдать определенную осторожность, так как исполняемые объекты от неизвестных производителей потенциально могут быть опасны для пользователей. Следует пользоваться элементами, которые уже прошли проверку временем и интернет-сообществом.\n
Раньше в HTML имелась только одна возможность добавлять мультимедийную информацию на web-страницы - элемент IMG. Он позволял добавлять только изображения, а остальные форматы были закрыты для web. Тогда разработчики браузеров стали добавлять поддержку новых элементов. Так появились тэги &lt;embed> от фирмы Netscape и &lt;applet> от фирмы Sun.\n
Но появление этих элементов не решило всех проблем и тогда в спецификацию HTML был добавлен новый элемент &lt;object>, позволяющий работать с любыми форматами. При этом на компьютере пользователя должно быть установлено приложение или дополнительный модуль к браузеру (плагин), позволяющий просматривать объект соответствующего формата.\n\n
Элементы форм\n
Формы состоят из определенного количества элементов ввода. Все элементы ввода помещаются между тегами <form> и </form>\n
Наиболее распространенным элементом ввода является элемент input. Однако реальное действие этого элемента зависит от того, какое значение установлено у его атрибута type. А он может принимать следующие значения:\n
•  text: обычное текстовое поле\n
•  password: тоже текстовое поле, только вместо вводимых символов отображаются звездочки, поэтому в основном используется для ввода пароля\n
•  radio: радиокнопка или переключатель. Из группы радиокнопок можно выбрать только одну\n
•  checkbox: элемент флажок, который может находиться в отмеченном или неотмеченном состоянии\n
•  hidden: скрытое поле\n
•  submit: кнопка отправки формы\n
•  color: поле для ввода цвета\n
•  date: поле для ввода даты\n
•  datetime: поле для ввода даты и времени с учетом часового пояса\n
•  datetime-local: поле для ввода даты и времени без учета часового пояса\n
•  email: поле для ввода адреса электронной почты\n
•  month: поле для ввода года и месяца\n
•  number: поле для ввода чисел\n
•  range: ползунок для выбора числа из некоторого диапазона\n
•  tel: поле для ввода телефона\n
•  time: поле для ввода времени\n
•  week: поле для ввода года и недели\n
•  url: поле для ввода адреса url\n
•  file: поле для выбора отправляемого файла\n
•  image: создает кнопку в виде картинки\n
Кроме элемента input в различных модификациях есть еще небольшой набор элементов, которые также можно использовать на форме:\n
•  button: создает кнопку\n
•  select: выпадающий список\n
•  label: создает метку, которая отображается рядом с полем ввода\n
•  textarea: многострочное текстовое поле\n\n
Атрибуты name и value\n
У всех элементов ввода можно установить атрибуты name и value. Эти атрибуты имеют важное значение. По атрибуту name мы можем идентифицировать поле ввода, а атрибут value позволяет установить значение поля ввода. Например:\n
&lt;html>\n
\t\t&lt;head>\n
\t\t\t\t\t\t&lt;meta charset="utf-8">\n
\t\t\t\t\t&lt;title>Формы в HTML5&lt;/title>\n
\t\t&lt;/head>\n
\t\t&lt;body>\n
\t\t\t&lt;form method="get" action="index.html">\n
\t\t\t\t\t&lt;input type="text" name="login" value="Tom"/>\n
\t\t\t\t\t&lt;input type="password" name="password"/>\n
\t\t\t\t\t&lt;input type="submit" value="Войти" />\n
\t\t\t&lt;/form>\n
\t\t&lt;/body>\n
&lt;/html>\n\n
Здесь текстовое поле имеет значение "Tom" (как указано в атрибуте value), поэтому при загрузке веб-страницы в этом поле мы увидим данный текст.\n
Поскольку методом отправки данных формы является метод "get", то данные будут отправляться через строку запроса. Так как нам в данном случае не важно, как данные будут приниматься, не важен сервер, который получает данные, поэтому в качестве адреса я установил ту же самую страницу - то есть файл index.html. И при отправке мы сможем увидеть введенные данные в строке запроса:\n
В строке запроса нас интересует следующий кусочек:\n
login=Tom&amp;password=qwerty\n
При отправке формы браузер соединяет все данные в набор пар "ключ-значение". В нашем случае две таких пары: login=Tom и password=qwerty. Ключом в этих парах выступает название поля ввода, которое определяется атрибутом name, а значением - собственно то значение, которое введено в поле ввода (или значение атрибута value).\n
Получив эти данные, сервер легко может узнать, какие значения в какие поля ввода были введены пользователем.\n
</item>
 <!--28--><item>28.ТИПЫ УПРАВЛЯЮЩИХ ЭЛЕМЕНТОВ. ПОНЯТИЕ ФРЕЙМОВОЙ СТРУКТУРЫ WEB-СТРАНИЦЫ.\n\n\n\n\n
Типы управляющих элементов\n\n
В HTML определены следующие типы управляющих элементов:\n\n
кнопки:\n
Авторы могут создавать три типа кнопок:\n
•	кнопки отправки: При активизации такой кнопки производится отправка формы. В форме может быть несколько кнопок отправки.\n
•	кнопки сброса: При активизации такой кнопки для всех управляющих элементов устанавливаются исходные значения.\n
•	прочие кнопки: Для таких кнопок действие по умолчанию не определено. С атрибутами событий каждой такой кнопки могут быть связаны клиентские скрипты. Если происходит событие (например, пользователь нажимает кнопку, отпускает ее и т.д.), включается связанный с событием скрипт.\n
Авторы должны определять язык скрипта для кнопок в объявлении скрипта по умолчанию (в элементе META).\n
Авторы создают кнопки с помощью элемента BUTTON или INPUT. Подробнее об определении различных типов кнопок см. в определении этих элементов.\n\n
флажки\n
Флажки (и кнопки с зависимой фиксацией) - это переключатели вкл./выкл., которые могут переключаться пользователем. Переключатель "включен", если для управляющего элемента установлен атрибут selected.\n
При отправке формы успешными могут стать только включенные переключатели. Несколько флажков в форме могут иметь одно и то же имя управляющего элемента. Таким образом, например, флажки позволяют пользователям выбрать несколько значений для одного и того же свойства. Для создания флажков используется элемент INPUT.\n\n
кнопки с зависимой фиксацией\n
Кнопки с зависимой фиксацией похожи на флажки за исключением того, что, если несколько кнопок используют одно и то же имя управляющего элемента, они являются взаимоисключающими: если одна кнопка включена, другие обязательно выключены. Для создания кнопок с зависимой фиксацией используется элемент INPUT.\n\n
меню\n
Предоставляют пользователям варианты на выбор. Меню создается с помощью элемента SELECT, а также элементов OPTGROUP и OPTION.\n\n
текстовый ввод\n
Для ввода текста пользователем авторы могут создавать управляющие элементы двух типов. Элемент INPUT создает управляющий элемент для ввода текста из одной строки, а элемент TEXTAREA - элемент для ввода текста из нескольких строк. В обоих случаях вводимый текст становится текущим значением управляющего элемента.\n\n
выбор файлов\n
Управляющие элементы этого типа позволяют пользователям выбирать файлы, содержимое которых может передаваться вместе с формой. Для создания этого управляющего элемента используется элемент INPUT.\n\n
скрытые управляющие элементы\n
Авторы могут создавать управляющие элементы, не представляемые пользователям, но имеющие значения, которые передаются с формой. Обычно они используются для хранения информации между обменом клиент/сервер, которая в противном случае могла бы пропасть вследствие stateless природы протокола http. Для создания скрытого управляющего элемента используется элемент INPUT.\n\n
объекты\n
Авторы могут помещать в формы общие объекты, так что связанные с ними значения будут передаваться с другими управляющими элементами. Для создания таких управляющих элементов используется элемент OBJECT.\n\n

Фреймы - средство для разделения экрана на несколько областей, в каждой из которых отображается содержимое отдельной Web - страницы или Web - сайта.\n
Фреймы – это прямоугольные области экрана, каждая из которых содержит свой собственный HTML - документ.\n
Тег &lt;FRAMESET>
Тег &lt;FRAMESET> определяет структуру фреймов на Web - странице. Фреймы разделяют окно браузера на отдельные области, расположенные вплотную друг к другу. В каждую из таких областей загружается самостоятельная веб-страница определяемая с помощью тега &lt;FRAME>. С помощью фреймов Web - страница делится на два или более документа, которые обычно содержат навигацию по сайту и его контент. Механизм фреймов позволяет открывать документ в одном фрейме, по ссылке, нажатой в совершенно другом фрейме. Тег <FRAMESET> заменяет тег &lt;BODY> и используется для разделения экрана. Имеет закрывающий тег </FRAMESET>. Допустимо использовать вложенную структуру элементов, это позволяет разбить один фрейм на две и более области.\n\n
Тег &lt;FRAME>.\n
Внутри тегов <FRAMESET> </FRAMESET> располагаются одиночные теги &lt;FRAME>, причем их должно быть столько, сколько задано областей. Без параметров эти теги бесполезны.\n
Тег &lt;FRAME> определяет свойства отдельного фрейма, на которые делится окно браузера. Этот элемент должен располагаться в контейнере &lt;FRAMESET>, который к тому же задает способ разметки страницы на отдельные области. В каждую из таких областей загружается самостоятельная Web – страница, определяемая с помощью атрибута Src. Хотя обязательных атрибутов у тега &lt;FRAME> и нет, рекомендуется задавать каждому фрейму его имя через атрибут Name. Это особенно важно, если требуется по ссылке из одного фрейма загружать документ в другой.\n
&lt;FRAME> Тег для описания рамки (&lt;FRAME SRC="file.htm">).\n\n
Атрибуты тега&lt;FRAME>\n\n
Bordercolor\n
Устанавливает цвет границы фрейма\n\n
Frameborder\n
Определяет, отображать рамку вокруг фрейма или нет.\n\n
Name\n
Задает уникальное имя фрейма.\n\n
Noresize\n
Определяет, можно изменять размер фрейма пользователю или нет.\n\n
Scrolling\n
Определяет присутствие в окне фрейма полосы прокрутки. Может принимать значения "yes", "no" и "auto"(по умолчанию)\n\n
Src\n
Путь к файлу, предназначенному для загрузки во фрейме.\n\n
Marginwidht\n
Определяет расстояние между содержимым фрейма и его границами справа и слева.\n\n
Marginheight\n
Определяет расстояние между содержимым фрейма и его границами сверху и снизу.\n\n
Target\n
Устанавливает связь между фреймами. Определяет имя фрейма, в который будет загружен новый документ. Имеет несколько значений: - _blank загружает содержимое страницы, заданной ссылкой, в новое пустое окно. - _self загружает содержимое страницы, заданной ссылкой, в то же окно, которое содержит ссылку. - _parent загружает содержимое страницы, заданной ссылкой, в окно, являющееся непосредственным владельцем набора фреймов. - _top загружает содержимое страницы, заданной ссылкой, в полное окно, игнорируя используемые фреймы
</item>
 <!--29--><item>29.СТИЛЕВОЕ ОФОРМЛЕНИЕ HTML-ДОКУМЕНТОВ. КАСКАДНЫЕ ТАБЛИЦЫ СТИЛЕЙ (CSS).\n\n\n\n\n
Любой html-документ, сколько бы он элементов не содержал, будет по сути "мертвым" без использования стилей. Стили или лучше сказать каскадные таблицы стилей (Cascading Style Sheets) или попросту CSS определяют представление документа, его внешний вид. Рассмотрим вкратце применение стилей в контексте HTML5.\n
Стиль в CSS представляет правило, которое указывает веб-браузеру, как надо форматировать элемент. Форматирование может включать установку цвета фона элемента, установку цвета и типа шрифта и так далее.\n
Определение стиля состоит из двух частей: селектор, который указывает на элемент, и блок объявления стиля - набор команд, которые устанавливают правила форматирования. Например:\n\n
div{\n
    background-color:red;\n
    width: 100px;\n
    height: 60px;\n
}\n
В данном случае селектором является div. Этот селектор указывает, что этот стиль будет применяться ко всем элементам div.\n
После селектора в фигурных скобках идет блок объявления стиля. Между открывающей и закрывающей фигурными скобками определяются команды, указывающие, как форматировать элемент.\n
Каждая команда состоит из свойства и значения. Так, в следующем выражении:\n\n
background-color:red;\n\n
background-color представляет свойство, а red - значение. Свойство определяет конкретный стиль. Свойств css существует множество. Например, background-color определяет цвет фона. После двоеточия идет значение для этого свойства. Например, выше указанная команда определяет для свойства background-color значение red. Иными словами, для фона элемента устанавливается цвет "red", то есть красный.\n
После каждой команды ставится точка с запятой, которая отделяет данную команду от других.\n
Наборы таких стилей часто называют таблицами стилей или CSS (Cascading Style Sheets или каскадные таблицы стилей). Существуют различные способы определения стилей.\n\n
Атрибут style\n
Первый способ заключается во встраивании стилей непосредственно в элемент с помощью атрибута style:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2 style="color:blue;">Стили&lt;/h2>\n
        &lt;div style="width: 100px; height: 100px; background-color: red;">&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n

Здесь определены два элемента - заголовок h2 и блок div. У заголовка определен синий цвет текста с помощью свойства color. У блока div определены свойства ширины (width), высоты (height), а также цвета фона (background-color).\n
Второй способ состоит в использования элемента style в документе html. Этот элемент сообщает браузеру, что данные внутри являются кодом css, а не html:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
        &lt;style>\n
        h2{\n
            color:blue;\n
        }\n
        div{\n
            width: 100px;\n
            height: 100px;\n
            background-color: red;\n
        }\n
        &lt;/style>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2>Стили&lt;/h2>\n
        &lt;div>&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
Результат в данном случае будет абсолютно тем же, что и в предыдущем случае.\n
Часто элемент style определяется внутри элемента head, однако может также использоваться в других частях HTML-документа. Элемент style содержит наборы стилей. У каждого стиля указывается вначале селектор, после чего в фигурных скобках идет все те же определения свойств css и их значения, что были использованы в предыдущем примере.\n
Второй способ делает код html чище за счет вынесения стилей в элемент style. Но также есть и третий способ, который заключается в вынесении стилей во внешний файл.\n
Создадим в одной папке с html странице текстовый файл, который переименуем в styles.css и определим в нем следующее содержимое:\n\n
h2{\n
    color:blue;\n
}\n
div{\n
    width: 100px;\n
    height: 100px;\n
    background-color: red;\n
}\n
Это те же стили, что были внутри элемента style. И также изменим код html-страницы:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;meta charset="utf-8">\n
        &lt;title>Стили&lt;/title>\n
        &lt;link rel="stylesheet" type="text/css" href="styles.css"/>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;h2>Стили&lt;/h2>\n
        &lt;div>&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
Здесь уже нет элемента style, зато есть элемент link, который подключает выше созданный файл styles.css: <link rel="stylesheet" type="text/css" href="styles.css"/>\n
Таким образом, определяя стили во внешнем файле, мы делаем код html чище, структура страницы отделяется от ее стилизации. При таком определении стили гораздо легче модифицировать, чем если бы они были определены внутри элементов или в элементе style, и такой способ является предпочтительным в HTML5.\n
Использование стилей во внешних файлах позволяет уменьшить нагрузку на веб-сервер с помощью механизма кэширования. Поскольку веб-браузер может кэшировать css-файл и при последующем обращении к веб-странице извлекать нужный css-файл из кэша.\n
Также возможна ситуация, когда все эти подходы сочетаются, а для одного элемента одни свойства css определены внутри самого элемента, другие свойства css определены внутри элемента style, а третьи находятся во внешнем подключенном файле. Например:\n\n
&lt;!DOCTYPE html>\n
&lt;html>\n
    &lt;head>\n
        &lt;link rel="stylesheet" type="text/css" href="styles.css"/>\n
        &lt;style>\n
            div{\n
                width:200px;\n
            }\n
        &lt;/style>\n
    &lt;/head>\n
    &lt;body>\n
        &lt;div style="width:120px;">&lt;/div>\n
    &lt;/body>\n
&lt;/html>\n\n
А в файле style.css определен следующий стиль:\n\n
div{\n
    width:50px;\n
    height:50px;\n
    background-color:red;\n
}\n\n
В данном случае в трех местах для элемента div определено свойство width, причем с разным значением. Какое значение будет применяться к элементу в итоге? Здесь у нас действует следующая система приоритетов:\n
•	Если у элемента определены встроенные стили (inline-стили), то они имеют высший приоритет, то есть в примере выше итоговой шириной будет 120 пикселей\n
•	Далее в порядке приоритета идут стили, которые определены в элементе style\n
•	Наименее приоритетными стилями являются те, которые определены во внешнем файле.\n\n
Атрибуты html и стили css\n
Многие элементы html позволяют устанавливать стили отображения с помощью атрибутов. Например, у ряда элементов мы можем применять атрибуты width и height для установки ширины и высоты элемента соответственно. Однако подобного подхода следует избегать и вместо встроенных атрибутов следует применять стили CSS. Важно четко понимать, что разметка HTML должна предоставлять только структуру html-документа, а весь его внешний вид, стилизацию должны определять стили CSS.\n\n
Валидация кода CSS\n
В процессе написания стилей CSS могут возникать вопросы, а правильно ли так определять стили, корректны ли они. И в этом случае мы можем воспользоваться валидатором css, который доступен по адресу http://jigsaw.w3.org/css-validator/.
</item>
 <!--30--><item>30.СЕРВЕРНЫЙ ЯЗЫК PHP. СИНТАКСИС. ВКЛЮЧЕНИЕ PHP-СЦЕНАРИЯ В HTML-ДОКУМЕНТ.\n\n\n\n\n
PHP (PHP: Hypertext Preprocessor — «PHP: препроцессор гипертекста»; первоначально Personal Home Page Tools — «Инструменты для создания персональных веб-страниц») — скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время поддерживается подавляющим большинством хостинг-провайдеров и является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов.\n
Язык и его интерпретатор (Zend Engine) разрабатываются группой энтузиастов в рамках проекта с открытым кодом. Проект распространяется под собственной лицензией, несовместимой с GNU GPL.\n\n
 Область применения\n
В области веб-программирования, в частности серверной части, PHP — один из популярных сценарных языков (наряду с JSP, Perl и языками, используемыми в ASP.NET).\n
Популярность в области построения веб-сайтов определяется наличием большого набора встроенных средств и дополнительных модулей для разработки веб-приложений. Основные из них:\n
•	автоматическое извлечение POST- и GET-параметров, а также переменных окружения веб-сервера в предопределённые массивы;\n
•	взаимодействие с большим количеством различных систем управления базами данных через дополнительные модули (MySQL, MySQLi, SQLite, PostgreSQL, Oracle (OCI8), Oracle, Microsoft SQL Server, Sybase, ODBC, mSQL, IBM DB2, Cloudscape и Apache Derby, Informix, Ovrimos SQL, Lotus Notes, DB++, DBM, dBase, DBX, FrontBase, FilePro, Ingres II, SESAM, Firebird / InterBase, Paradox File Access, MaxDB, Интерфейс PDO), Redis;\n
•	автоматизированная отправка HTTP-заголовков;\n
•	работа с HTTP-авторизацией;\n
•	работа с cookies и сессиями;\n
•	работа с локальными и удалёнными файлами, сокетами;\n
•	обработка файлов, загружаемых на сервер;\n
•	работа с XForms.\n
В настоящее время PHP используется сотнями тысяч разработчиков. Согласно рейтингу корпорации TIOBE, базирующемуся на данных поисковых систем, в мае 2019 года PHP находился на 6 месте среди языков программирования. К крупнейшим сайтам, использующим PHP, относятся Facebook, Wikipedia и др.
Входит в LAMP — распространённый набор программного обеспечения для создания и хостинга веб-сайтов (Linux, Apache, MySQL, PHP).\n\n
Синтаксис\n
Синтаксис PHP подобен синтаксису языка Си. Некоторые элементы, такие как ассоциативные массивы и цикл foreach, заимствованы из Perl.\n
Для написания простейшего скрипта не требуется описывать какие-либо переменные, используемые модули и т. п. Любой скрипт может начинаться непосредственно с оператора PHP.\n
Простейшая программа Hello world на PHP выглядит следующим образом:\n\n
        &lt;?php\n
            echo \'Hello, world!\';\n
            ?>\n
Также возможен более короткий вариант вывода строки:\n
        &lt;?= \'Hello, world!\' ?>\n
Открывающий тег вида &lt;?= используется для сокращённой записи конструкций, используемых для вывода строки.\n
PHP исполняет код, находящийся внутри ограничителей, таких как &lt;?php ?>. Всё, что находится вне ограничителей, выводится без изменений. В основном это используется для вставки PHP-кода в HTML-документ, например, так:\n\n
&lt;html>\n
   &lt;head>\n
      &lt;title>\n
         Тестируем PHP\n
      &lt;/title>\n
   &lt;/head>\n
   &lt;body>\n
      &lt;?php\n
          echo "Привет мир!";\n
          ?>\n
   &lt;/body>\n
&lt;/html>\n\n
Помимо ограничителей &lt;?php ?>, допускается использование сокращённого варианта &lt;? ?>. Кроме того, до версии 7.0 допускалось использование ограничителей языка программирования ASP &lt;% %> и &lt;script language="php"> &lt;/script>. Работа сокращённых конструкций определяется в конфигурационном файле php.ini.\n
Имена переменных начинаются с символа $, тип переменной объявлять не нужно. Имена переменных и констант чувствительны к регистру символов. Имена классов, методов классов и функций к регистру символов не чувствительны. Переменные обрабатываются в строках, заключённых в двойные кавычки, и heredoc-строках (строках, созданных при помощи оператора &lt;&lt;&lt;). Переменные в строках, заключённых в одинарные кавычки, не обрабатываются.\n
PHP рассматривает переход на новую строку как пробел, так же как HTML и другие языки со свободным форматом. Инструкции разделяются с помощью точки с запятой (;), за исключением некоторых случаев, после объявления конструкции if/else и циклов.\n
Переменные в функцию можно передавать как по значению, так и по ссылке (используется знак &amp;).\n
PHP поддерживает три типа комментариев: в стиле языка Си (ограниченные /* */), C++ (начинающиеся с // и идущие до конца строки) и оболочки UNIX (с # до конца строки).\n
</item>
 <!--31--><item>Уругвай</item>
 <!--32--><item>Уругвай</item>
 <!--33--><item>33.СИСТЕМНЫЕ ПЕРЕМЕННЫЕ MATLAB.\n\n\n\n\n
Системные переменные MATLAB\n
В системе MATLAB существует особой вид переменных, значение которых, за исключением переменой ans, нельзя изменить. Эти переменные называются системными. Они предназначены для более эффективной работы при вычислениях, а также для вывода системой сообщений при некорректной постановке задачи пользователем. В таблице приведен список системных переменных, используемых в MATLAB.\n\n
Обозначения системных переменных MATLAB\n
Переменная	Значение переменной\n
i, j	мнимая единица ( )\n
pi	число (3.14159265)\n
eps	погрешность для операций над числами с плавающей точкой (по умолчанию -52)\n
realmin	минимальное значение вещественного числа (2-1022)\n
realmax	Максимальное значение вещественного числа (21023)\n
inf	бесконечность ()\n
naN	неопределенность, например, 0/0)\n
ans	переменная, хранящая результат последней операции\n
</item>
 <!--34--><item>Уругвай</item>
 <!--35--><item>Уругвай</item>
 <!--36--><item>36.ПРИНЦИПЫ УПРАВЛЕНИЯ ПРОЕКТОМ.\n\n\n\n\n\n
Три фундаментальных принципа проектного управления.\n\n
Первый принцип проектного управления. Принцип яйца.\n
Как ответ на эти два вызова - конечность и неопределенность, родилось проектное управление. Появился принцип яйца. Это, конечно, метафора. Но она отражает то, как менеджеры отреагировали на конечность и неопределенность.\n
 Что символизирует куриное яйцо? Представьте, курица снесла яйцо и садится его высиживать. Яйцо сразу конечного размера, то есть скорлупа уже больше не увеличивается. И скорлупа – это аналог того, что называется «устав проекта». В каждом проекте обязательно есть такая вещь, как устав. В уставе фиксируются неизменные ограничения проекта - стоимость, сроки и кратко его суть (содержание). И сколько бы курица ни сидела, яйцо больше не растёт. Это жесткие рамки, в которые проект должен уложиться, и мы обязаны уложить его в эти рамки любой ценой.\n
Под скорлупой яйца находится внутреннее содержимое. Но пока это только общие планы. Когда курица садится на яйцо, там есть белок и желток - размытые субстанции, а птица еще не угадывается. Так и на старте проекта пишется устав, а подробных планов нет. Они создаются очень примерно. То есть вы должны представить себе общую картину, а уточнять будете позже, чтобы не тратить каждый раз время на переписывание и уточнение. И чем дальше продвигается проект вперёд, чем дольше курица высиживает яйцо, тем явственнее проступают лапки, клювик, глазки и вообще наша будущая птица. Так и с проектом. Сначала планы примерные, а чем дольше он длится, тем больше уточнений вы вносите, и в этом заключается принцип яйца.\n
 То есть на старте есть устав и примерные планы (белок и желток). На протяжении проекта устав неизменен, а планы меняются, расширяются. Это очень важное правило – скорлупу трогать нельзя. Если вы расковыряли пальцем скорлупу яйца, то результат у вас уже не получится, высидеть яйцо будет невозможно. Точно так же и с проектом: если вы устав нарушили, этот проект надо перезапускать. Если яйцо сначала высиживала курица, а потом вы решили, что это должен делать крокодил, то придется брать уже другое яйцо.\n
 Задача менеджера проекта – обеспечить, чтобы внутреннее содержимое не переросло ограничения, чтобы белок и желток не стали больше самого яйца. Если скорлупа лопнет, проект тоже не получится. И PMBoK – это пособие о том, как впихнуть то, что не вмещается, как яйцо удержать в скорлупе.\n
 Попробуйте ответить, можно ли назвать успешным проект, если сроки были превышены в 50 раз, а бюджет – в 40 раз, но продукт получился хорошим? Речь идет, в частности, о продуктах Microsoft – Word и Excel – очень популярных, очень хороших продуктах. Являются ли они успешными проектами?\n
 На самом деле это провальные проекты, но все довольны. И надо эти две вещи разделять и не путаться: это очень хорошие продукты, которыми все довольны, но провальные проекты. Почему это не просто придирки? Если бы это была не Microsoft, а совершенно другая компания, то:\n
•	проект никогда бы не завершился,\n
•	компания разорилась бы.\n
 По сути, эти проекты не обладали конечностью. Руководству на самом деле было все равно, сколько денег уйдет на проекты и когда они выйдут. Главное – чтобы продукты вышли и покорили рынок.\n
 И таких компаний немало, тот же Яндекс или Google. Они не очень переживают, сколько будет стоить их новый сервис или обновление. Их не очень интересуют сроки. Для них важно, чтобы получился очень хороший продукт.\n
 Когда у вас такая ситуация – скрам работает прекрасно, ничего лучше не бывает. Если у вас бесконечное число денег и времени, и вам просто нужен хороший продукт, то ничего лучше, чем спокойненько делать и все время показывать клиенту промежуточные результаты, никто не придумал. Но если вы работаете в боевых рыночных условиях, если у вас бюджет ограничен, и хороший продукт – не единственное, что вас волнует, то для этого есть проектное управление.\n\n
Второй принцип. Принцип удава.\n
 Любой проект имеет жизненный цикл. Он начинается с инициации (этап определения границ и формального запуска проекта) и заканчивается закрытием (этап формального завершения работ), а в середине у него клубок процессов. Абсолютно у каждого проекта, даже если вы его не закончили, провалили, есть начало, конец и середина: инициация, закрытие и клубок процессов. Если на этот цикл натянуть смешной контур, то получится удав. Такой сытый удав, который что-то переваривает.\n\n
Третий принцип. Принцип командности и проактивности.\n
Как вы считаете, должен ли быть менеджер проекта экспертом в том, в чем у него проект, должен ли он разбираться в этом?\n
С одной стороны, должен, иначе его просто обманут. Но с другой, менеджеру проекта не просто быть экспертом, потому что непонятно, где именно должна находиться зона его экспертизы. Вот конкретный пример. Представьте себе проект по разработке томографа. Давайте попробуем разобраться, какими должны быть компетенции менеджера этого проекта. Томограф - сложный прибор со сложным софтом, над ним трудится инженер-электронщик, с одной стороны, программист – с  другой. Проектирование с последующей сборкой - примерно столь же трудоемкая задача, как и написание для томографа программного обеспечения. При этом томограф делается для врачей, поэтому необходимо участие врача, для уточнения, что имеет диагностическую ценность, а что - нет. А еще томограф – прибор, который проходит строгую сертификацию, потому что при неправильном применении он может человека убить. И процедура его сертификации длительная и сложная, требует участия отдельных компетентных специалистов. И в какой из упомянутых сфер должен быть экспертом менеджер проекта? Понятно, что он не может быть одновременно и электронщиком, и программистом, и врачом, и специалистом по сертификации.\n
 Это универсальная ситуация: проекты – всегда задачи с конечностью и неопределенностью, когда стыкуются разные сферы и нужны разные специалисты. Поэтому менеджеру проекта не обязательно быть экспертом, потому что непонятно, в какой это должно быть области.\n
 Другая ситуация, когда мы смотрим на работу какого-либо отдела. Обычно начальники отделов – это бывшие эксперты. Сначала он был простым инженером, потом дорос до начальника отдела инженеров. Он самый умный инженер, поэтому его назначили всеми руководить. Начальники отделов, конечно, не всегда вырастают из рядовых сотрудников, но чаще всего ситуация именно такая. Но здесь вряд ли речь пойдет именно об управлении проектами. Если у вас вдруг проект внутри отдела, и в него вовлечены только сотрудники отдела, это наверняка не проект. Это просто задачи в рамках вашей операционной деятельности. Проект предполагает конечность и неопределенность. А откуда возьмется неопределенность, если ваши люди делают дело, которое и вы, и они хорошо знают? Проекты, как правило, предполагают кросс-функциональность. Это верно даже для тех IT-проектов, в которых команды маленькие. Все равно в них есть программисты, тестировщики, аналитики, дизайнеры, люди других профессий. Во всех этих сферах нельзя быть экспертом, поэтому менеджер не может быть экспертом во всем. Конечно, грамотность нужна, понимание предмета проекта, например, в нашем последнем примере знать что-то про томограф обязательно. Иначе команда вас не примет как руководителя. Но быть экспертом во всем невозможно.\n
 И отсюда берется принцип командности. Очень простая логика: проектное управление не предполагает, что вы, как руководитель, можете взять и сделать проект самостоятельно. Понадобятся знания большого количества экспертов в разных доменах, которые вам нужно объединить. Вы – интегратор в первую очередь. Принцип командности говорит о том, что вся команда участвует в формировании планов. Планы пишутся всей командой – вами и вашими сотрудниками. Один вы не сможете учесть все нюансы, хотя соблазн самому построить план проекта всегда велик.\n
 Проактивность – это антоним реактивности. Что такое реактивность? Когда что-то загорелось, побежали – потушили. А проактивность – это мы сидим и думаем, как бы так сделать, чтобы не загорелось никогда, а если загорится, чтобы мы быстро справились. Фактически, проактивность - это управление рисками. Превентивное.\n
 А управление проектом – это, во-первых, умение увлекать команду формированием планов и управление этими планами. А во-вторых, проактивность – вы должны думать про риски, управлять ими, всячески их оценивать.\n
</item>
 <!--37--><item>37.ОРГАНИЗАЦИОННАЯ СТРУКТУРА ПРОЕКТА.\n\n\n\n\n
Организационная структура проекта – это временная организационная структура, созданная для повышения качества управления и взаимодействия в проекте путем определения и визуализации процессов взаимодействия как между внутренними, так и с внешними участниками проекта.\n\n
Команда проекта\n
Проект — явление временное, и это определяет специфику управления его участниками. На время реализации проекта создается так называемая команда проекта, которая имеет определенную организационную структуру. Несмотря на все многообразие существующих проектов, в команде можно выделить ряд более или менее стандартных ролей.\n
В первую очередь, это менеджер (руководитель) проекта — физическое лицо, несущее личную ответственность за успех проекта и осуществляющее оперативное руководство.\n
Как правило, в компаниях назначают куратора проекта — представителя высшего руководства, который хоть и не вникает в тонкости текущего положения дел в проекте, но контролирует его ход, следит, чтобы проект соответствовал стратегическим целям компании, а если у менеджера проекта не хватает полномочий, — помогает ему своим авторитетом.\n
Проектный комитет создается в компаниях, в которых бизнес построен по проектному типу. Это орган, задачи которого — отбирать проекты и контролировать их выполнение на высшем уровне, принимать ключевые решения.\n
В технически сложных проектах важна роль главного инженера проекта (ГИП), который порой по статусу равен менеджеру проекта.\n
В крупных проектах могут выделяться менеджеры по различным функциональным областям, например по управлению финансами, персоналом, рисками и т. п.\n
Все вышеперечисленные роли образуют команду управления проектом, которая входит в команду проекта. Также участниками команды проекта являются исполнители как из числа штатных сотрудников компании, так и нанятые специально для реализации конкретного проекта. Иногда в нее включают подрядчиков и субподрядчиков.\n
Отдельно стоит выделить проектный офис. В простейшем случае это своего рода секретариат, в котором хранится вся документация по проекту. Он может состоять как из одного, так и из нескольких сотрудников. В более продвинутых компаниях проектный офис также играет роль методологического центра, обслуживающего все проекты организации. Ниже представлен пример типичной команды проекта.\n\n
\t\t\t\t\t\t\tВысшее руководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tПроектный комитет\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tКуратор проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
\t\t\t\t\t\t\tМенеджер проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-ль отдела | ГИП | Админ проекта\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Исполнители | Подрядчики | Субподрядчики\n\n

Проект и компания\n
Ни один проект не существует в вакууме. Как правило, он реализуется в интересах некоторой компании, которая его и инициирует. Такая компания называется родительской, головной или материнской. Соответственно, у компании есть определенная организационная структура, и проект каким-то образом «встраивается» в нее.\n
Самой распространенной структурой на сегодняшний день является функциональная структура, представляющая собой иерархию, в которой для каждого служащего четко определен один вышестоящий руководитель. При этом сотрудники сгруппированы по специальностям: маркетинг, производство, закупки и т.п. Такая структура оптимальна для хорошо налаженного циклического производства, однако вызывает ряд трудностей при выполнении проектов.\n
На определенном этапе в организации возникают проекты и назначается их координатор. Он отвечает за выполнение проекта, достижение целей, соблюдение сроков и выделенного бюджета. Фактически же такой сотрудник не имеет достаточно полномочий для решения поставленных задач. Отвечать «за все» и не иметь полномочий – главная проблема для эффективного управления проектами. Также, одним из основных недостатков при реализации проектов является неповоротливость структуры, так как все распоряжения любой сотрудник может получать только от своего функционального руководителя, что вызывает длительные задержки при принятии решений. Также проблемы могут возникать из-за того, что интересы проекта вступают в противоречие с интересами функциональных руководителей.\n
Такая структура весьма статична и эффективна только для реализации локальных проектов в рамках подразделения.\n\n
ФУНКЦИОНАЛЬНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-ль подр_1 Рук-ль подр_2 Рук-ль подр_3\n
\t\t\t\t\t|\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\t\t|\n
СОТРУДНИК_1  \tсотрудник_1  \t\t\tСОТРУДНИК_1\n
сотрудник_2 \t\t\tСОТРУДНИК_2  \tсотрудник_2\n
сотрудник_3 \t\t\tсотрудник_3  \t\t\tСОТРУДНИК_3\n\n

Примечание: Большими буквами выделены сотрудники, участвующие в проекте.\n\n
Проектная структура полностью противоположна матричной по своей организации. Здесь проектные команды как бы образуют свои собственные временные подразделения, созданные на время выполнения проекта и возглавляемые руководителями проектов. При такой организации функциональные подразделения выполняют сервисную функцию по отношению к проектам, т. е. оказывают им услуги, например техническую поддержку или бухгалтерское обслуживание. Также функциональные отделы играют роль пула ресурсов (например, специалистов), динамически перераспределяемых между проектами. В проектной структуре члены команды ориентированы только на достижение целей проекта и подчиняются только его руководителю.\n
При такой организации проект фактически представляет собой филиал компании, при этом «законы», по которым действует сотрудник в рамках проекта, полностью определяются руководством проекта. Такая структура эффективна в крупных, значимых для компании проектах, как правило, продолжительностью более двух лет.\n\n
ПРОЕКТНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-во проекта_1 Рук-во проекта_2 Др. отделы\n
\t\t\t\t\t|\n
СОТРУДНИК_1\n
СОТРУДНИК_2\n
СОТРУДНИК_3\n
Примечание: Большими буквами сотрудники, участвующие в проекте.\n

Основной недостаток проектной структуры состоит в том, что ресурсы не всегда используются эффективно (например, услугами юриста вы пользуетесь всего несколько часов в неделю, и их невыгодно оплачивать полностью из бюджета проекта).\n
Эту проблему позволяет решить матричная структура, которая представляет собой компромисс между функциональной и проектной структурами. Здесь сотрудник подчиняется с одной стороны руководителю проекта, а с другой — своему функциональному руководителю. В зависимости от того, у кого из них больше власти, различают слабую (незначительная власть руководителя проекта) и сильную, или жесткую (менеджер проекта выше функционального руководителя) матрицы. Идеальной представляется сбалансированная матрица, при которой менеджер проекта ответственен за его результаты, а функциональный руководитель — за качество работы своих сотрудников, «командированных» в проект. Основной минус матричной структуры — двойное подчинение сотрудников.\n\n
МАТРИЧНАЯ ОРГСТРУКТУРА\n
\t\t\t\t\t\t\t\tРуководство компании\n
\t\t\t\t\t\t\t\t\t\t\t\t|\n
Рук-во проекта Рук-во отдела_1 Рук-во отдела_2\n
\t\t\t\t\t|\n
Менеджер_1 \tСотрудник_1 \t\tСотрудник_1\n
МЕНЕДЖЕР_2 СОТРУДНИК_2 СОТРУДНИК_2\n
Менеджер_3 \tСотрудник_3 \t\tСотрудник_3\n
Примечание: Большими буквами сотрудники, участвующие в проекте.\n
В компании могут одновременно сосуществовать различные оргструктуры. Наибольшее применение получила слабая матрица, т. к. традиционно велика роль функциональных руководителей.\n\n
Выбор организационной структуры проекта\n
Каждый тип структуры имеет свои плюсы и минусы. Матричная структура является компромиссной, ее разновидности можно наиболее часто встретить в компаниях, бизнес которых связан с ведением проектов. Зачастую в одной компании можно встретить несколько структур в зависимости от масштаба и других особенностей конкретного проекта. Однако можно дать ряд рекомендаций по выбору организационной структуры.\n\n
Крит. выбора:	Функц-ая	Матричная	Проектная\n
Уров. неопр-сти:	Низкий	Средний	Высокий\n
Технология:	Типовая	Сложная	Инновационная\n
Комплексность:	Низкая	Средняя	Высокая\n
Продолжительность:	Малая	Средняя	Большая\n
Знач. для компании:	Малое	Среднее	Ключевое\n
Уровень взаимосвязей между частями проекта:	Низкий	Средний	Высокий\n
Важность фактора времени (наличие критических сроков):	Низкая	Средняя	Высокая\n
Зависимость от вышестоящей организации:	Высокая	Средняя	Низкая\n
</item>
 <!--38--><item>Уругвай</item>
 <!--39--><item>Уругвай</item>
 <!--40--><item>Уругвай</item>
 <!--41--><item>Уругвай</item>
 <!--42--><item>Уругвай</item>
 <!--43--><item>Уругвай</item>
 <!--44--><item>Уругвай</item>
 <!--45--><item>Уругвай</item>
 <!--46--><item>Уругвай</item>
 <!--47--><item>Уругвай</item>
 <!--48--><item>Уругвай</item>
 <!--49--><item>Уругвай</item>
 <!--50--><item>Уругвай</item>
 <!--51--><item>Уругвай</item>
 <!--52--><item>Уругвай</item>
 <!--53--><item>Уругвай</item>
 <!--54--><item>Уругвай</item>
 <!--55--><item>Уругвай</item>
 <!--56--><item>Уругвай</item>
 <!--57--><item>Уругвай</item>
 <!--58--><item>Уругвай</item>
 <!--59--><item>Уругвай</item>
 <!--60--><item>Уругвай</item>
 <!--61--><item>Уругвай</item>
 <!--62--><item>Уругвай</item>
 <!--63--><item>Уругвай</item>
 <!--64--><item>Уругвай</item>
 <!--65--><item>Уругвай</item>
 <!--66--><item>Уругвай</item>
 <!--67--><item>Уругвай</item>
    </string-array>
</resources>