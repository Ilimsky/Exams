<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="answers">
 <!--1--><item >1.ПОНЯТИЕ АЛГОРИТМА. ПОДХОДЫ К ОПРЕДЕЛЕНИЮ АЛГОРИТМА. СВОЙСТВО АЛГОРИТМА.\n\n
Понятие алгоритма является одним из основных понятий современ¬ных математики и информатики, но зародилось оно еще в глубокой древности. Термин алгоритм происходит от имени средневекового узбекского математика Аль Хорезми (IX в.), который сформулировал правила выполнения четырех арифметических действий в десятичной системе счисления.\n\n
В современной информатике используется следующее определение алгоритма. Алгоритмом называют систему четких однозначных указаний, которые определяют последовательность действий над некоторыми объектами и после конечного числа шагов приводят к получению требуемого результата.\n\n
Подходы к определению алгоритма:
Слово алгоритм происходит от algorithmi – латинской формы написания имени великого математика IX в. Аль Хорезми, который сформулировал правила выполнения арифметических действий. Первоначально под алгоритмами и понимали только правила выполнения четырех арифметических действий над многозначными числами. В дальнейшем это понятие стали использовать вообще для обозначения последовательности действий, приводящих к решению поставленной задачи.\n\n
Свойства алгоритма\n
1. Дискретность алгоритма предполагает, что решение задачи (т.е. алгоритм) разбито на отдельные шаги (операции, команды) и переход к сле¬дующему шагу возможен только после выполнения предыдущего.
\n
2. Определенность (точность) алгоритма предполагает, что каждая его команда должна однозначно определять действие исполнителя алгоритма (записанные в алгоритме команды должны иметь однозначную трактовку).
\n
3. Понятность алгоритма подразумевает, что он должен включать в себя только те шаги или команды, которые понятны исполнителю (в алгоритме не могут присутствовать команды, смысл которых неизвестен исполнителю).
\n
4. Результативность (конечность) предполагает, что алгоритм дол¬жен быть нацелен на получение конечного результата, т.е. исполнение алгоритма должно закончиться за конечное число шагов.
\n
5. Массовость алгоритма подразумевает, что алгоритм должен быть пригоден для решения целого класса однотипных задач (а не только для одной конкретной задачи).
\n\n
Основные способы записи алгоритмов
\n
1. Словесный способ, т.е. описание алгоритма на естественном языке (словами).\n
2. Формульно-словесный способ, в котором кроме слов могут использоваться математические формулы.\n
3. Графический способ, т.е. в виде блок-схемы.\n
4. Программный способ, т.е. в виде программы на алгоритмическом языке.\n
</item>
 <!--2--><item>2.СТРУКТУРА ПРОГРАММЫ, ЭЛЕМЕНТЫ ЯЗЫКА С++. ПОНЯТИЕ ТИПА ДАННЫХ.\n\n\n\n
Структура программы на языке С++ \n
Программа на языке C++ состоит из функций, описаний и директив препроцессора.\n
(Препроцессор — это программа, которая выполняет обработку файла исходного кода перед началом компиляции).\n
Рассмотрим простейшую программу:\n
#include &lt;Ciostream>\n
using namespace std;\n
int main()\n
{\n
cout &lt;&lt; "Hello world!" &lt;&lt; end1;\n
return 0;\n
}\n
В первой строке с помощью директивы #include подключается заголовочный файл &lt;iostream>, который содержит необходимую информацию для управления вводом/выводом.\n
Следующая директива using открывает доступ к пространству имен (англ. namespace) std, в котором определяются средства стандартной библиотеки языка C++.\n
(Пространство имён — некоторое множество, созданное для логической группировки уникальных идентификаторов).\n
Отправной точкой выполнения любой С++-программы является функция main(). Функция содержит четыре элемента:\n
•	возвращаемый тип (в нашем случае int);\n
•	имя функции (main);\n
•	список параметров, заключенный в круглые скобки (в данном случае список пуст);\n
•	заключенное в фигурные скобки, тело функции, представляющее собой блок инструкций.\n\n
Инструкцией называется часть программы, определяющая действие и не являющаяся директивой препроцессора.\n
В нашей программе тело функции содержит две инструкции:\n
•	cout  "Hello, World!";\n
•	return 0;\n
Во-первых, выводится на экран строка Hello, World, а затем возвращается в точку вызова значение 0, которое означает, что программа выполнена успешно.\n
Обратим внимание на то, что каждая инструкция в языке С++ заканчивается точкой с запятой. Существуют следующие исключения:\n
•	директивы препроцессора, начинающиеся с символа # (например, #include);\n
•	составные операторы и блоки определения функций, которые обрамлены фигурными скобками — { }.\n\n

Элементы языка С++\n
Начнем изучение языка С++ с рассмотрения состава и основных конструкций необходимых для написания программ.\n
Алфавит языка\n
Алфавит языка программирования C++ включает:\n
•	прописные и строчные латинские буквы, и знак подчеркивания;\n
•	арабские цифры от 0 до 9;\n
•	специальные знаки: " { } , | [ ] ( ) + - / % * . \ ? &lt; = > ! &amp; # - ; ' '\n
•	пробельные символы: пробел, символы табуляции, символы перехода на новую строку.\n\n
Из символов алфавита формируются лексемы языка (минимальная единица языка, имеющая самостоятельный смысл):\n
o	идентификаторы;\n
o	ключевые слова;\n
o	знаки операций;\n
o	константы;\n
o	разделители (скобки, точка, запятая, пробельные символы).\n\n

Идентификаторы\n
Идентификатор — это имя программного объекта\n
Первым символом в идентификаторе может быть буква или знак подчеркивания. Внутри идентификаторов не допускается использование пробелов.\n
Например: v1, _sum\n\n

При выборе идентификатора следует иметь в виду следующее:\n
•	идентификатор не должен совпадать с ключевыми словами и именами используемых стандартных объектов языка;\n
•	не рекомендуется начинать идентификаторы с символа подчеркивания, т. к. в этом случае они могут совпасть с именами системных функций или переменных.\n\n

Ключевые слова\n
Ключевые слова — это зарезервированные идентификаторы, которые имеют специальное значение для компилятора.\n

Таблица1. Список ключевых слов C++\n
asm auto bool break case catch char class const\n
const_cast continue default delete do double\n
dynamic_cast else enum explicit export extern\n
false float for friend goto if inline int long\n
mutable namespace new operator private protected\n
public register reinterpret_cast return short\n
signed sizeof static static__cast struct switch\n
template this throw true try typedef typeid typename\n
union unsigned using virtual void volatile wchar_t while\n\n

Знаки операций\n
Знак операции — это один или более символов, определяющих действие над операндами.
Операции делятся на унарные, бинарные и тернарную по количеству участвующих в них операндов. Один и тот же знак может интерпретироваться по-разному в зависимости от контекста.\n\n

Константы\n
Константами называют неизменяемые величины.\n
Различаются целые, вещественные, символьные и строковые константы. Компилятор, выделив константу в качестве лексемы, относит ее к одному из типов по ее внешнему виду.\n\n

Комментарии\n
Комментарии используются для пояснения отдельных частей или всей программы. Отметим, что компилятор игнорирует комментарии.\n
В языке С++ используется две формы комментариев:\n
•	комментарий начинается с двух символов «прямая косая черта» // и заканчивается символом перехода на новую строку\n
•	комментарий заключается между символами-скобками /* ... */\n\n

Внимание! Вложенные комментарии-скобки стандартом не допускаются.\n
Внутри комментария можно использовать любые допустимые на данном компьютере символы.\n\n

Типы данных С++\n
Любая программа в ходе работы обрабатывает данные. Хранение и обработка данных зависит от их типа. Каждая константа, переменная, результат вычисления выражения или функции должны иметь определенный тип.\n\n

Тип данных определяет:\n
•	представление данных в памяти компьютера;\n
•	множество значений, которые могут принимать величины данного типа;\n
•	операции и функции, которые можно применять к величинам этого типа.\n\n

Все типы языка C++ можно разделить на основные и составные.\n
Основные типы данных используются для представления целых, вещественных, символьных и логических величин. К составным типам относятся массивы, перечисления, функции, структуры, ссылки, указатели, объединения и классы.\n\n

Основные типы данных\n
Для описания основных типов данных определены следующие ключевые слова:\n
•	int (целый);\n
•	char (символьный);\n
•	wchar_t (расширенный символьный);\n
•	bool (логический);\n
•	float (вещественный);\n
•	double (вещественный с двойной точностью).\n\n

Для уточнения диапазона значений и внутреннего представления стандартных типов применяются четыре спецификатора типа:\n
•	short (короткий);\n
•	long (длинный);\n
•	signed (знаковый);\n
•	unsigned (беззнаковый).\n\n

Типичные размеры значений и диапазоны представлений\n
Тип: bool\n
Размер (байт): 1\n
Диапазон значений: true, false\n
Замечания: Внутренняя форма представления значения false - 0. Любое другое значение интерпретируется как true.\n\n

Тип: signed char\n
Размер (байт): 1\n
Диапазон значений: -128 ... 127\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: unsigned char\n
Размер (байт): 1\n
Диапазон значений: 0 ... 255\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: signed short int\n
Размер (байт): 2\n
Диапазон значений: -32768 ... 32767\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned short int\n
Размер (байт): 2\n
Диапазон значений: 0 ... 65535\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: signed long int\n
Размер (байт): 4\n
Диапазон значений: -2 147 483 648 ... 2 147 483 647\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned long int\n
Размер (байт): 4\n
Диапазон значений: 0 ... 4 294 967 295\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: float\n
Размер (байт): 4\n
Диапазон значений: 3.4e-38 ... 3.4e+38\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: double\n
Размер (байт): 8\n
Диапазон значений: 1.7e-308 ... 1.7e+308\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: long double\n
Размер (байт):8\n
Диапазон значений: 3.4e-4932 ... 3.4e+4932\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Константам, встречающимся в программе, компилятор приписывает тот или иной тип в соответствии с их видом. Можно явно указать требуемый тип с помощью соответствующих суффиксов:\n
•	Для целых типов:\n
L, l (long) и u, U (unsigned). Например, 50L будет иметь тип long. Суффиксы L и U можно использовать одновременно, например: 105LU.\n
•	Для вещественных типов:\n
F, f (float) и L, l (long). Например, константа 3e+5L будет иметь тип long double, а константа 1.82f — тип float.\n\n

Тип void\n
К основным типам языка С++ относится также тип void. Множество значений этого типа пусто. Он применяется для определения функций, которые не возвращают значения, для указания пустого списка аргументов функции, как базовый тип для указателей и в операции приведения типов.
</item>
 <!--3--><item>3.ОПЕРАЦИИ (АРИФМЕТИЧЕСКИЕ, ЛОГИЧЕСКИЕ) НА ТИПАХ. СТАНДАРТНЫЕ ФУНКЦИИ. ВЫРАЖЕНИЯ.\n\n
Операции. Арифметические операции\n
1. Какие арифметические операции используются в языке C/C++?\n
В языке C++ поддерживаются следующие арифметические операции:\n
+ – сложение;\n
- – вычитание;\n
* – умножение;\n
/ – деление;\n
% – остаток от деления.\n
Все эти операции являются бинарными. Это означает, что для получения результата, нужно 2 операнда. Общий вид арифметической операции:\n
операнд1 операция операнд2\n
где операция – одна из операций +, —, *, %, /.\n\n
            2. Для каких типов данных можно применять арифметические операции?\n
Арифметические операции можно применять для:\n
•  целочисленных типов: short int, unsigned short int, int, unsigned int, long, unsigned long;\n
•  типов с плавающей запятой (вещественных типов): float, double, long double;\n
•  типов (классов), которые содержат «перегруженные» арифметические операции.\n
В арифметических операциях один из операндов может иметь целочисленный тип, а второй быть типом с плавающей запятой. В этом случае результат имеет тип с плавающей запятой.\n\n
3. Как осуществляется приведение типов в операциях +, —, *?\n
В выражениях, где используются операции +, —, *, действуют следующие правила приведения типа результата:\n
•  если оба операнда имеют целый тип, то результат также будет целого типа;\n
•  если хотя бы один из операндов имеет вещественный (с плавающей запятой) тип а другой целый тип, то результат также будет вещественного типа;\n
•  если один из операндов имеет тип float, а другой тип double, то результат будет типа double. Это связано с тем, что тип double требует больше памяти чем тип float. В этом случае происходит расширение типа float к типу double.\n\n
4. Какой приоритет и ассоциативность арифметических операций?\n
Арифметические операции имеют приоритет и ассоциативность, как изображено в следующей таблице.
Знаки операций Наименование   Ассоциативность\n
*   /   %  Бинарные, мультипликативные    Слева направо\n
+   —  Бинарные, аддитивные   Слева направо\n\n
5. Какое отличие между бинарными и унарными операциями сложения (+) и вычитания (—)?\n
Операции сложения (+) и вычитания (—) могут быть как бинарными, так и унарными.\n
Бинарные операции + и — используются в выражениях при проведении вычислений.\n
Унарные операции + и — используются для обозначения знака числа (положительное число или отрицательное число).\n
Пример.\n
int a, b;\n
a = -8; // унарная операция \'-\', обозначает знак числа\n
b = +9; // унарная операция \'+\', b = 9\n
a = b-5; // бинарная операция \'-\', используется для вычисления выражения\n\n
6. Какие особенности использования операции % (остаток от деления)?\n
Операция % используется над целыми операндами. Операция % позволяет получить остаток от деления целых операндов.\n
Пример.\n
// Операция % - взятие остатка от деления\n
int a, b;\n
int c;\n
a = 3;\n
b = 5;\n
c = a % b;   // c = 3\n
a = 8;\n
b = 4;\n
c = a % b;   // c = 0\n
c = 12 % 35; // c = 12\n
c = 35 % 12; // c = 11\n
c = -5 % -3; // c = -2\n\n
7. Какие особенности использования операции / (деление)?\n
Операция деления имеет свои особенности, которые состоят в следующем:\n
•  если два операнда имеют целочисленный тип, то результат возвращается целого типа. В этом случае происходит деление нацело. Остаток от деления урезается;\n
•  если один из операндов имеет тип с плавающей запятой, тогда результат имеет также тип с плавающей запятой.\n
Пример.\n
// Операция деления \'/\'\n
int a, b;\n
int c;\n
float x;\n
a = 8;\n
b = 3;\n
c = a / b; // c = 2\n
x = a / b; // x = 2.0\n
x = a / (float)b; // x = 2.666667\n
x = 17.0 / 3; // x = 5.666667\n
x = 17 / 3;   // x = 5.0\n\n
C++. Логические операции. Поразрядные логические операции. Операции сдвига. Операция XOR\n
1. Для каких типов можно применять логические операции, поразрядные логические операции и операции сдвига?\n
Логические операции, поразрядные логические операции и операции сдвига можно использовать только для операндов целых типов.\n
2. Какие логические операции используются в C++?\n
В языке программирования C++ используются следующие логические операции:\n
•  &amp;&amp; – логическое «И»;\n
•  || – логическое «ИЛИ»;\n
•  ! – логическое «НЕТ».\n
Результатом логических операций есть значение false или true. В языке C++ принято, что значение false считается равным 0, а значение true считается равным 1.\n
Отсюда можно сделать вывод, что false &lt; true. Например:\n
// логические операции\n
bool res;\n
res = false &lt; true; // res = true\n\n
3. Таблица истинности логических операций\n
Таблица истинности логических операций &amp;&amp; (логическое «И»), || (логическое «ИЛИ»), ! (логическое «НЕТ») имеет следующий вид:\n
a b a&amp;&amp;b a||b !a !b\n
false false false false true true\n
false true false true true false\n
true false false true false true\n
true true true true false false\n

В языке C++ принимается, что значение false равно 0, а значение true не равно 0 (любое ненулевое целочисленное значение).\n\n
4. Примеры использования логических операций в C++\n
Пример 1. Логическая операция в сочетании с логическим выражением\n
// логические операции\n
bool res;\n
int a, b;\n
// операция &amp;&amp; (AND)\n
a = 8;\n
b = 5;\n
res = a &amp;&amp; b; // res = True\n
a = 0;\n
res = a &amp;&amp; b; // res = False\n
// операция || (OR)\n
a = 0;\n
b = 0;\n
res = a || b; // res = False\n
b = 7;\n
res = a || b; // res = True\n\n
// операция ! (логическое "НЕТ")\n
a = 0;\n
res = !a; // res = True\n
a = 15;\n
res = !a; // res = False\n\n
Пример 2. Логическая операция в условных выражениях. Приведен фрагмент кода, в котором логическая операция используется в операторе условного перехода if.\n
// логические операции в условных выражениях\n
int a, b;\n
bool res;\n
a = 0;\n
b = 3;\n
res = false;\n
if (a &amp;&amp; b)\n
res = true; // res = false\n
a = 0;\n
b = 7;\n
if (a || b)\n
res = true; // res = true\n\n
5. Какие поразрядные логические операции используются в C++?\n
Язык С++ поддерживает следующие поразрядные логические операции:\n
•  &amp; – поразрядное логическое И (AND);\n
•  ^ – поразрядное сложение по модулю 2 (XOR — исключающее ИЛИ);\n
•  | – поразрядное логическое ИЛИ (OR);\n
•  ~ – поразрядная инверсия (NOT).\n
Операции &amp;, ^, | есть бинарными. Это означает, что они требуют двух операндов. Биты любого операнда сравниваются между собой по следующему правилу: бит в позиции 0 первого операнда сравнивается с битом в позиции 0 второго операнда. Затем бит в позиции 1 первого операнда сравнивается с битом в позиции 1 второго операнда. Так сравниваются все биты целочисленных операндов.\n\n
6. Таблица истинности поразрядных логических операций\n
Каждый бит результата определяется на основе двух операндов, которые являются битами, так как показано в таблице.\n
бит1 бит2 &amp; || ^ ~бит1 ~бит2\n
0 0 0 0 0 1 1\n
0 1 0 1 1 1 0\n
1 0 0 1 1 0 1\n
1 1 1 1 0 0 0\n

Инверсия требует единого операнда справа от знака ~. Результат получается поразрядной инверсией всех битов операнда.\n\n
7. Пример работы с логическими побитовыми операциями\n
Пусть даны два числа 17 и 45 типа unsigned short int. Каждое из чисел занимает в памяти 1 байт или 8 бит. Ниже приведен пример того, как происходит вычисление для каждой побитовой операции\n
  128 64 32 16 8 4 2 1\n
17 =       0 0 0 1 0 0 0 1\n
45 =       0 0 1 0 1 1 0 1\n
17&amp;45 = 0 0 0 0 0 0 0 1 = 1\n
17|45 =  0 0 1 1 1 1 0 1 = 61\n
17^45 = 0 0 1 1 1 1 0 0 = 60\n
~17 =     1 1 1 0 1 1 1 0 = 238\n

Как видно из примера, происходит выполнение заданной операции над каждым битом.\n\n
8. Какие операции сдвига используются в C++?\n
Язык С++ включают две операции поразрядного сдвига:\n
•  &lt;&lt; – сдвиг влево значения операнда на заданное количество бит. Операнд размещается слева от знака операции. Число сдвигаемых бит указывается справа от знака операции;\n
•  >> – сдвиг вправо значения операнда на заданное количество бит. Операнд размещается слева от знака операции (&lt;&lt;). Количество сдвигаемых бит размещается справа от знака операции.\n
Выдвижные биты теряются, а «входят» нулевые биты. Сдвиг операндов влево на 1, 2, 3 и более разрядов – наиболее быстрый способ умножения на 2, 4, 8, … Сдвиг операндов вправо на 1, 2, 3 и более разрядов – наиболее быстрый способ деления на 2, 4, 8, …\n
Если в программе нужно, чтобы операция умножения целочисленных операндов на 2, 4, 8 и т.д. происходила максимально быстро, то целесообразно использовать операцию сдвига влево.\n
Это касается и случаев, когда нужно максимально быстро поделить целочисленный операнд на 2, 4, 8 и т.д. В этих случаях рекомендуется использовать сдвиг вправо.\n\n
9. Примеры использования операций сдвига в программе
\\// Операции сдвига\n
int a;\n
int b;\n
int c;\n
a = 15;\n
b = -5;\n

// сдвиг влево - умножение\n
c = a &lt;&lt; 1; // c = a * 2^1 = 30\n
c = b &lt;&lt; 2; // c = b * 2^2 = -20\n

// сдвиг вправо - деление\n
c = a >> 3; // c = a / 2^3 = 1\n
c = b >> 1; // c = b / 2^1 = -3\n\n
10. Какое отличие между логическими операциями и поразрядными логическими операциями?\n
В логических операциях сравнивается значение двух операндов целиком. Каждый из операндов может иметь значение true или false. Язык C++ допускает сравнение операндов, которые являются целыми числами. В этом случае целочисленное значение 0 соответствует значению false, а ненулевое (любое другое) значение соответствует значению true.\n
Поразрядные логические операции работают строго с битами любого операнда. Бит может иметь 2 значения: 0 или 1. Поэтому, вычислению подлежат соответствующие биты каждого операнда а не значение операнда в целом.\n\n
11. Как в C++ реализовать логическую операцию XOR?\n
Как известно, язык C++ не содержит встроенной логической операции XOR (исключающее «ИЛИ»).\n
Ниже приведен фрагмент кода, который реализует операцию XOR с помощью использования операций &amp;&amp; (AND), || (OR), ! (NOT).\n
// реализация операции XOR через операции &amp;&amp; (AND), || (OR), ! (NOT)\n
bool x, y;\n
bool res;\n

...\n

res = (x || y) &amp;&amp; !(x &amp;&amp; y);\n

...\n
В вышеприведенном программном коде:\n
•  x, y – переменные, для которых вычисляется операция XOR;\n
•  res – переменная, которая есть результатом вычисления.\n

</item>
 <!--4--><item>4.УСЛОВНЫЙ ОПЕРАТОР. ОПЕРАТОР МНОЖЕСТВЕННОГО ВЕТВЛЕНИЯ (ВЫБОРА).\n\n\n
Условные операторы if и switch в C++\n
Одна из основных конструкций алгоритма — разветвляющийся процесс. Он реализован в языке C++ двумя условными операторами: if и switch. Рассмотрим каждый из них.\n\n

Условный оператор if\n
Для организации вычислений в зависимости от какого-либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом:\n
if (условие) оператор_1; else оператор_2;\n
Здесь условие — это логическое выражение, переменная или константа.\n
Работает условный оператор следующем образом. Сначала вычисляется значения выражения, записанного в виде условия. Если оно имеет значение истина (true), выполняется оператор_1. В противном случае (значение ложное (false) ) оператор_2.\n
Например, чтобы сравнить значения переменных a и b нужно написать следующую часть программного кода:\n

int a, b;\n
cin>>a;\n
cin>>b;\n
if (a==b) cout&lt;&lt;"a equal b";\n
else cout&lt;&lt;"a not equal b";\n
Не путайте знак проверки равенства == и оператор присваивания =\n
Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.\n
if (условие) { оператор_1; оператор_2; … }\n
else { оператор_1; оператор_2; … }\n
Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.\n\n
Оператор варианта switch\n
Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
default: операторы; break;\n
}\n
Оператор работает следующем образом. Вычисляется значение выражения. Затем выполняются операторы, помеченные значением, совпадающим со значением выражения. То есть если, выражение принимает значение_1, то выполняются операторы_1 и т.д.. Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.\n
Ветвь default может отсутствовать, тогда оператор имеет вид:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
}\n
Оператор break необходим для того, чтобы осуществить выход из операторы switch. Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.\n
Некоторые вещи могут быть непонятны, и поэтому для ясности давайте рассмотрим пример несложной задачи.\n\n
Задача\n
Необходимо вывести на название дня недели, соответствующее заданному числу D, при условии, что в месяце 31 день и 1-е число — понедельник.\n
Для решения задачи воспользуемся операцией %, позволяющей вычислить остаток от деления двух чисел. Программа будет выводить название дня недели в зависимости от заданного нами числа.\n

#include "stdafx.h"\n
#include &lt;iostream>\n
using namespace std;\n
int main ()\n
{\n
unsigned int D, R; //описанны целые положительные числа\n
cout&lt;&lt;"D=";\n
cin>>D;\n
R=D%7;\n
switch (R)\n
{\n
case 1: cout&lt;&lt;"Monday \n"; break;\n
case 2: cout&lt;&lt;"Theusday \n"; break;\n
case 3: cout&lt;&lt;"Wednesday \n"; break;\n
case 4: cout&lt;&lt;"Thursday \n"; break;\n
case 5: cout&lt;&lt;"Friday \n"; break;\n
case 6: cout&lt;&lt;"Saturday \n"; break;\n
case 0: cout&lt;&lt;"Sunday \n"; break;\n
}\n
system ("pause");\n
return 0;\n
}\n
</item>
 <!--5--><item>5.ЦИКЛИЧЕСКИЕ ОПЕРАТОРЫ.\n\n\n\n\n
Циклы в C++\n
Иногда необходимо повторять одно и то же действие несколько раз подряд. Для этого используют циклы. В этом уроке мы научимся программировать циклы на C++, после чего посчитаем сумму всех чисел от 1 до 1000.\n
Цикл for\n
Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит примерно так:\n
for (действие до начала цикла;\n
     условие продолжения цикла;\n
     действия в конце каждой итерации цикла) {\n
         инструкция цикла;\n
         инструкция цикла 2;\n
         инструкция цикла N;\n
}\n
Итерацией цикла называется один проход этого цикла\n
Существует частный случай этой записи, который мы сегодня и разберем:\n
for (счетчик = значение; счетчик &lt; значение; шаг цикла) {\n
    тело цикла;\n
}\n
Счетчик цикла — это переменная, в которой хранится количество проходов данного цикла.\n
Описание синтаксиса\n
•	Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.\n
•	Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.\n
•	Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.\n
Пример кода\n
Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    int i; // счетчик цикла\n
    int sum = 0; // сумма чисел от 1 до 1000.\n
    setlocale(0, "");\n
    for (i = 1; i &lt;= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.\n
    {\n
        sum = sum + i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную работу за нас.\n
Заметьте, что конечное значение счетчика я задал нестрогим неравенством ( &lt;= — меньше либо равно), поскольку, если бы я поставил знак меньше, то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. Это довольно важный момент, т.к. здесь новички часто допускают ошибки, особенно при работе с массивами (о них будет рассказано в следующем уроке). Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1.\n
В теле цикла, при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент — в начале программы я присвоил переменной sum значение нуля. Если бы я этого не сделал, программа вылетела вы в сегфолт. При объявлении переменной без ее инициализации что эта переменная будет хранить «мусор».\n
Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, такие как gcc, инициализирует переменную нулем при ее объявлении.\n
Цикл while\n
Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.\n
while (Условие) {\n
    Тело цикла;\n
}\n
Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно.\n
Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    while (i &lt; 1000)\n
    {\n
        i++;\n
        sum += i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
После компиляции программа выдаст результат, аналогичный результату работы предыдущей программы. Но поясним несколько важных моментов. Я задал строгое неравенство в условии цикла и инициализировал счетчик i нулем, так как в цикле while происходит на одну итерацию больше, потому он будет выполняться, до тех пор, пока значение счетчика перестает удовлетворять условию, но данная итерация все равно выполнится. Если бы мы поставили нестрогое неравенство, то цикл бы закончился, когда переменная i стала бы равна 1001 и выполнилось бы на одну итерацию больше.\n
Теперь давайте рассмотрим по порядку исходный код нашей программы. Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел.
В данном случае мы обязательно должны присвоить счетчику цикла какое-либо значение, т.к. в предыдущей программе мы это значение присваивали внутри цикла for, здесь же, если мы не инициализируем счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется — сегфолт практически неизбежен.\n
Затем мы описываем условие цикла — «пока переменная i меньше 1000 — выполняй цикл». При каждой итерации цикла значение переменной-счетчика i увеличивается на единицу внутри цикла.\n
Когда выполнится 1000 итераций цикла, счетчик станет равным 999 и следующая итерация уже не выполнится, поскольку 1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i.
После окончания выполнения цикла, выводим сообщение с ответом.\n
Цикл do while\n
Цикл do while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do while один проход цикла будет выполнен независимо от условия. Решение задачи на поиск суммы чисел от 1 до 1000, с применением цикла do while.\n
#include &lt;iostream>\n
using namespace std;\n

int main ()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    do {// выполняем цикл.\n
        i++;\n
        sum += i;\n
    } while (i &lt; 1000); // пока выполняется условие.\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Принципиального отличия нет, но если присвоить переменной i значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход.
</item>
 <!--6--><item>6.СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ (СУБД).\n\n\n\n\n
Система управления базами данных сокр. СУБД (англ. Database Management System, сокр. DBMS) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.\n
СУБД — комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.\n\n
Основные функции СУБД\n
1.	управление данными во внешней памяти (на дисках);\n
2.	управление данными в оперативной памяти с использованием дискового кэша;\n
3.	журнализация изменений, резервное копирование и восстановление базы данных после сбоев;\n
4.	поддержка языков БД (язык определения данных, язык манипулирования данными).\n\n
Состав СУБД\n
Обычно современная СУБД содержит следующие компоненты:\n
•	ядро, которое отвечает за управление данными во внешней и оперативной памяти и журнализацию;\n
•	процессор языка базы данных, обеспечивающий оптимизацию запросов на извлечение и изменение данных и создание, как правило, машинно-независимого исполняемого внутреннего кода;\n
•	подсистему поддержки времени исполнения, которая интерпретирует программы манипуляции данными, создающие пользовательский интерфейс с СУБД;\n
•	сервисные программы (внешние утилиты), обеспечивающие ряд дополнительных возможностей по обслуживанию информационной системы.\n\n
Классификации СУБД\n
По модели данных\n
Примеры:\n
•	Иерархические\n
•	Сетевые\n
•	Реляционные\n
•	Объектно-ориентированные\n
•	Объектно-реляционные\n\n
По степени распределённости\n
•	Локальные СУБД (все части локальной СУБД размещаются на одном компьютере)\n
•	Распределённые СУБД (части СУБД могут размещаться не только на одном, но на двух и более компьютерах).\n
По способу доступа к БД\n
•	Файл-серверные\n
В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок.\n
Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера.\n
Недостатки: потенциально высокая загрузка локальной сети; затруднённость или невозможность централизованного управления; затруднённость или невозможность обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.\n
На данный момент файл-серверная технология считается устаревшей, а её использование в крупных информационных системах — недостатком.\n
Примеры: Microsoft Access, Paradox, dBase, FoxPro, Visual FoxPro.\n
•	Клиент-серверные\n
Клиент-серверная СУБД располагается на сервере вместе с БД и осуществляет доступ к БД непосредственно, в монопольном режиме. Все клиентские запросы на обработку данных обрабатываются клиент-серверной СУБД централизованно.\n
Недостаток клиент-серверных СУБД состоит в повышенных требованиях к серверу.\n
Достоинства: потенциально более низкая загрузка локальной сети; удобство централизованного управления; удобство обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность.\n
Примеры: Oracle Database, Firebird, Interbase, IBM DB2, Informix, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Caché, ЛИНТЕР.\n
•	Встраиваемые\n
Встраиваемая СУБД — СУБД, которая может поставляться как составная часть некоторого программного продукта, не требуя процедуры самостоятельной установки. Встраиваемая СУБД предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети.\n
Физически встраиваемая СУБД чаще всего реализована в виде подключаемой библиотеки. Доступ к данным со стороны приложения может происходить через SQL либо через специальные программные интерфейсы.\n
Примеры: OpenEdge, SQLite, BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact, ЛИНТЕР.\n
Стратегии работы с внешней памятью\n
СУБД с непосредственной записью\n
В таких СУБД все изменённые блоки данных незамедлительно записываются во внешнюю память при поступлении сигнала подтверждения любой транзакции. Такая стратегия используется только при высокой эффективности внешней памяти.\n
СУБД с отложенной записью\n
В таких СУБД изменения аккумулируются в буферах внешней памяти до наступления любого из следующих событий:\n
•	Контрольная точка.\n
•	Нехватка пространства во внешней памяти, отведенного под журнал. СУБД создаёт контрольную точку и начинает писать журнал сначала, затирая предыдущую информацию.\n
•	Останов. СУБД ждёт, когда всё содержимое всех буферов внешней памяти будет перенесено во внешнюю память, после чего делает отметки, что останов базы данных выполнен корректно.\n
•	Нехватка оперативной памяти для буферов внешней памяти.\n
Такая стратегия позволяет избежать частого обмена с внешней памятью и значительно увеличить эффективность работы СУБД.\n

</item>
 <!--7--><item>7.ПРОЕКТИРОВАНИЕ СТРУКТУРЫ БАЗЫ ДАННЫХ.\n\n\n\n
Проектирование баз данных — процесс создания схемы базы данных и определения необходимых ограничений целостности.\n

Основные задачи проектирования баз данных\n
Основные задачи:\n
•	Обеспечение хранения в БД всей необходимой информации.\n
•	Обеспечение возможности получения данных по всем необходимым запросам.\n
•	Сокращение избыточности и дублирования данных.\n
•	Обеспечение целостности базы данных.\n\n

Основные этапы проектирования баз данных\n
Концептуальное (инфологическое) проектирование\n

Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель», «концептуальная модель» и «инфологическая модель» являются синонимами. Кроме того, в этом контексте равноправно могут использоваться слова «модель базы данных» и «модель предметной области» (например, «концептуальная модель базы данных» и «концептуальная модель предметной области»), поскольку такая модель является как образом реальности, так и образом проектируемой базы данных для этой реальности.\n
Конкретный вид и содержание концептуальной модели базы данных определяется выбранным для этого формальным аппаратом. Обычно используются графические нотации, подобные ER-диаграммам.\n
Чаще всего концептуальная модель базы данных включает в себя:\n
•	описание информационных объектов или понятий предметной области и связей между ними.\n
•	описание ограничений целостности, то есть требований к допустимым значениям данных и к связям между ними.\n
Логическое (даталогическое) проектирование\n
Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных, например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.\n
Преобразование концептуальной модели в логическую модель, как правило, осуществляется по формальным правилам. Этот этап может быть в значительной степени автоматизирован.\n
На этапе логического проектирования учитывается специфика конкретной модели данных, но может не учитываться специфика конкретной СУБД.\n
Физическое проектирование\n
Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т. п. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и т. д.\n
Результатом физического проектирования логической схемы выше на языке SQL может являться следующий скрипт:\n
CREATE TABLE IF NOT EXISTS Department ( -- Факультет\n
  id INT NOT NULL,\n
  name VARCHAR(45),\n
  PRIMARY KEY (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Group (\n
  id INT NOT NULL,\n
  name VARCHAR(45) ,\n
  depart_id INT NOT NULL,\n
  UNIQUE INDEX depart_id_UNIQUE (depart_id ASC),\n
  PRIMARY KEY (id, depart_id),\n
  CONSTRAINT depart_fk\n
    FOREIGN KEY (depart_id)\n
    REFERENCES Department (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Student (\n
  first_name VARCHAR(16) NOT NULL,\n
  last_name VARCHAR(45) NOT NULL,\n
  email VARCHAR(255),\n
  group_id INT NOT NULL,\n
  PRIMARY KEY (last_name, first_name, group_id),\n
  INDEX group_fk_idx (group_id ASC),\n
  CONSTRAINT group_fk\n
    FOREIGN KEY (group_id) REFERENCES Group (id)\n
);\n\n
Нормализация\n
При проектировании реляционных баз данных обычно выполняется так называемая нормализация.\n
Модели «сущность-связь»\n
Модель «сущность-связь» (англ. “Entity-Relationship model”), или ER-модель, предложенная П. Ченом в 1976 г., является наиболее известным представителем класса семантических (концептуальных, инфологических) моделей предметной области. ER-модель обычно представляется в графической форме, с использованием оригинальной нотации П. Чена, называемой ER-диаграмма, либо с использованием других графических нотаций (Crow’s Foot, Information Engineering и др.).\n
Основные преимущества ER-моделей:\n
•	наглядность;\n
•	модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;\n
•	ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).\n
Основные элементы ER-моделей:\n
•	объекты (сущности);\n
•	атрибуты объектов;\n
•	связи между объектами.\n
Сущность — объект предметной области, имеющий атрибуты.\n
Связь между сущностями характеризуется:\n
•	типом связи (1:1, 1:N, N:М);\n
•	классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.\n
Семантические модели\n
Семантическая модель (концептуальная модель, инфологическая модель) — модель предметной области, предназначенная для представления семантики предметной области на самом высоком уровне абстракции. Это означает, что устранена или минимизирована необходимость использовать понятия «низкого уровня», связанные со спецификой физического представления и хранения данных.\n
Семантическое моделирование стало предметом интенсивных исследований с конца 1970-х годов. Основным побудительным мотивом подобных исследований (то есть проблемой, которую пытались разрешить исследователи) был следующий факт. Дело в том, что системы баз данных обычно обладают весьма ограниченными сведениями о смысле хранящихся в них данных. Чаще всего они позволяют лишь манипулировать данными определенных простых типов и определяют некоторые простейшие ограничения целостности, наложенные на эти данные. Любая более сложная интерпретация возлагается на пользователя. Однако было бы замечательно, если бы системы могли обладать немного более широким объемом сведений и несколько интеллектуальнее отвечать на запросы пользователя, а также поддерживать более сложные (то есть более высокоуровневые) интерфейсы пользователя.\n
Идеи семантического моделирования могут быть полезны как средство проектирования базы данных даже при отсутствии их непосредственной поддержки в СУБД.\n
Наиболее известным представителем класса семантических моделей является модель «сущность-связь» (ER-модель).\n

</item>
 <!--8--><item>8.ВИДЫ МОДЕЛЕЙ ДАННЫХ.\n\n\n\n\n\n
Виды моделей данных БД\n
Модели организации данных. Сетевые, реляционные, иерархические модели.\n
Ядром любой базы данных является модель данных. С помощью модели данных могут быть представлены объекты предметной области и взаимосвязи между ними.\n
Модель данных - это совокупность структур данных и операций их обработки. Рассмотрим три основных типа моделей данных: иерархическую, сетевую и реляционную.\n
Виды моделей данных БД\n
Иерархическую модель БД изображают в виде дерева. Элементы дерева вершины представляют совокупность данных, например логические записи.\n
Иерархическая модель представляет собой совокупность элементов, расположенных в порядке их подчинения от общего к частному и образующих перевернутое по структуре дерево (граф).\n
К основным понятиям иерархической структуры относятся уровень, узел и связь. Узел – это совокупность атрибутов данных, описывающих некоторый объект. На схеме иерархического дерева узлы представляются вершинами графа. Каждый узел на более низком уровне связан только с одним узлом, находящимся на более высоком уровне. Иерархическое дерево имеет только одну вершину, не подчиненную никакой другой вершине и находящуюся на самом верхнем - первом уровне. Зависимые (подчиненные) узлы находятся на втором, третьем и т. д. уровнях. Количество деревьев в базе данных определяется числом корневых записей. К каждой записи базы данных существует только один иерархический путь от корневой записи.\n
Сетевые модели БД соответствуют более широкому классу объектов управления, хотя требуют для своей организации и дополнительных затрат.\n
В сетевой структуре при тех же основных понятиях (уровень, узел, связь) каждый элемент может быть связан с любым другим элементом.\n
Реляционная модель БД представляет объекты и взаимосвязи между ними в виде таблиц, а все операции над данными сводятся к операциям над этими таблицами. На этой модели базируются практически все современные СУБД. Эта модель более понятна, "прозрачна" для конечного пользователя организации данных.\n
Реляционная модель данных объекты и связи между ними представляет в виде таблиц, при этом связи тоже рассматриваются как объекты. Все строки, составляющие таблицу в реляционной базе данных, должны иметь первичный ключ. Все современные средства СУБД поддерживают реляционную модель данных.\n
Эта модель характеризуются простотой структуры данных, удобным для пользователя табличным представлением и возможностью использования формального аппарата алгебры отношений и реляционного исчисления для обработки данных.\n
Каждая реляционная таблица представляет собой двумерный массив и обладает следующими свойствами:\n
1. Каждый элемент таблицы соответствует одному элементу данных.\n
2. Все столбцы в таблице однородные, т.е. все элементы в столбце имеют одинаковый тип и длину.\n
3. Каждый столбец имеет уникальное имя.\n
4. Одинаковые строки в таблице отсутствуют.\n
5. Порядок следования строк и столбцов может быть произвольным.\n
В последние годы все большее признание и развитие получают объектно-ориентированные базы данных (ООБД), толчок к появлению которых дали объектно-ориентированное программирование и использование персональных компьютеров для обработки и представления практически всех форм информации, воспринимаемых человеком. В ООБД модель данных более близка сущностям реального мира. Объекты можно сохранить и использовать непосредственно, не раскладывая их по таблицам.\n
</item>
 <!--9--><item>9.СОЗДАНИЕ БАЗЫ ДАННЫХ. ПРИМЕРЫ В СРЕДЕ ACCESS.\n\n\n\n\n
Создание базы данных в MS Access: пошаговая инструкция\n
СОДЕРЖАНИЕ\n
•	Описание MS Access\n
•	Определения основных понятий\n
•	Создание БД\n
•	Создание и заполнение таблиц\n
•	Создание и редактирование схем данных\n
•	Выполнение запросов\n
•	Создание формы\n
•	Формирование отчета\n
В современном мире нужны инструменты, которые бы позволяли хранить, систематизировать и обрабатывать большие объемы информации, с которыми сложно работать в Excel или Word.\n
Подобные хранилища используются для разработки информационных сайтов, интернет-магазинов и бухгалтерских дополнений. Основными средствами, реализующими данный подход, являются MS SQL и MySQL.\n
Продукт от Microsoft Office представляет собой упрощенную версию в функциональном плане и более понятную для неопытных пользователей. Давайте рассмотрим пошагово создание базы данных в Access.\n\n

Описание MS Access\n
Microsoft Access – это система управления базами данных (СУБД), реализующая полноценный графический интерфейс пользователя, принцип создания сущностей и связей между ними, а также структурный язык запросов SQL. Единственный минус этой СУБД – невозможность работать в промышленных масштабах. Она не предназначена для хранения огромных объемов данных. Поэтому MS Access используется для небольших проектов и в личных некоммерческих целях.\n
Но прежде чем показывать пошагово создание БД, нужно ознакомиться с базовыми понятиями из теории баз данных.\n\n
Определения основных понятий\n
Без базовых знаний об элементах управления и объектах, использующихся при создании и конфигурации БД, нельзя успешно понять принцип и особенности настройки предметной области. Поэтому сейчас я постараюсь простым языком объяснить суть всех важных элементов. Итак, начнем:\n
•	Предметная область – множество созданных таблиц в базе данных, которые связаны между собой с помощью первичных и вторичных ключей.\n
•	Сущность – отдельная таблица базы данных.\n
•	Атрибут – заголовок отдельного столбца в таблице.\n
•	Кортеж – это строка, принимающая значение всех атрибутов.\n
•	Первичный ключ – это уникальное значение (id), которое присваивается каждому кортежу.\n
•	Вторичный ключ таблицы «Б» – это уникальное значение таблицы «А», использующееся в таблице «Б».\n
•	SQL запрос – это специальное выражение, выполняющее определенное действие с базой данных: добавление, редактирование, удаление полей, создание выборок.\n
Теперь, когда в общих чертах есть представление о том, с чем мы будем работать, можно приступить к созданию БД.\n\n
Создание БД\n
Для наглядности всей теории создадим тренировочную базу данных «Студенты-Экзамены», которая будет содержать 2 таблицы: «Студенты» и «Экзамены». Главным ключом будет поле «Номер зачетки», т.к. данный параметр является уникальным для каждого студента. Остальные поля предназначены для более полной информации об учащихся.\n
Итак, выполните следующее:\n
•	Запустите MS Access.\n
•	Нажмите на кнопку «Новая база данных».\n
•	В появившемся окне введите название БД и выберите «Создать».\n

Все, теперь осталось только создать, заполнить и связать таблицы. Переходите к следующему пункту.\n\n
Создание и заполнение таблиц\n
После успешного создания БД на экране появится пустая таблица. Для формирования ее структуры и заполнения выполните следующее:\n
1.	Нажмите ПКМ по вкладке «Таблица1» и выберите «Конструктор».\n

2.	Теперь начинайте заполнять названия полей и соответствующий им тип данных, который будет использоваться.\n

Внимание! Первым полем принято устанавливать уникальное значение (первичный ключ). Для него предпочтительно числовое значение.\n
1.	После создания необходимых атрибутов сохраните таблицу и введите ее название.\n
2.	Снова нажмите ПКМ по вкладке с уже новым название и выберите «Режим таблицы».\n

3.	Заполните таблицу необходимыми значениями.\n

Совет! Для тонкой настройки формата данных перейдите на ленте во вкладку «Режим таблицы» и обратите внимание на блок «Форматирование и тип данных». Там можно кастомизировать формат отображаемых данных.\n\n
Создание и редактирование схем данных\n
Перед тем, как приступить к связыванию двух сущностей, по аналогии с предыдущим пунктом нужно создать и заполнить таблицу «Экзамены». Она имеет следующие атрибуты: «Номер зачетки», «Экзамен1», «Экзамен2», «Экзамен3».\n
Для выполнения запросов нужно связать наши таблицы. Иными словами, это некая зависимость, которая реализуется с помощью ключевых полей. Для этого нужно:\n
1.	Перейти во вкладку «Работа с базами данных».\n
2.	Нажать на кнопку «Схема данных».\n
3.	Если схема не была создана автоматически, нужно нажать ПКМ на пустой области и выбрать «Добавить таблицы».\n

4.	Выберите каждую из сущностей, поочередно нажимая кнопку «Добавить».\n
5.	Нажмите кнопку «ОК».\n
Конструктор должен автоматически создать связь, в зависимости от контекста. Если же этого не случилось, то:\n
3.	Перетащите общее поле из одной таблицы в другую.\n
4.	В появившемся окне выберите необходимы параметры и нажмите «ОК».\n

5.	Теперь в окне должны отобразиться миниатюры двух таблиц со связью (один к одному).\n

Выполнение запросов\n
Что же делать, если нам нужны студенты, которые учатся только в Москве? Да, в нашей БД только 6 человек, но что, если их будет 6000? Без дополнительных инструментов узнать это будет сложно.\n
Именно в этой ситуации к нам на помощь приходят SQL запросы, которые помогают изъять лишь необходимую информацию.\n\n
Виды запросов\n
SQL синтаксис реализует принцип CRUD (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить»). Т.е. с помощью запросов вы сможете реализовать все эти функции.\n\n
На выборку\n
В этом случае в ход вступает принцип «прочесть». Например, нам нужно найти всех студентов, которые учатся в Харькове. Для этого нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL.\n

4.	В текстовое поле введите команду: SELECT * FROM Студенты WHERE Адрес = «Харьков»; где «SELECT *» означает, что выбираются все студенты, «FROM Студенты» — из какой таблицы, «WHERE Адрес = «Харьков»» — условие, которое обязательно должно выполняться.\n
5.	Нажмите кнопку «Выполнить».\n

6.	На выходе мы получаем результирующую таблицу.\n

А что делать, если нас интересуют студенты из Харькова, стипендии у которых больше 1000? Тогда наш запрос будет выглядеть следующим образом:\n
SELECT * FROM Студенты WHERE Адрес = «Харьков» AND Стипендия > 1000;\n
а результирующая таблица примет следующий вид:\n\n

На создание сущности\n
Кроме добавления таблицы с помощью встроенного конструктора, иногда может потребоваться выполнение этой операции с помощью SQL запроса. В большинстве случаев это нужно во время выполнения лабораторных или курсовых работ в рамках университетского курса, ведь в реальной жизни необходимости в этом нет. Если вы, конечно, не занимаетесь профессиональной разработкой приложений. Итак, для создания запроса нужно:\n
1.	Перейти во вкладку «Создание».\n
2.	Нажать кнопку «Конструктор запросов» в блоке «Другие».\n
3.	В новом окне нажмите на кнопку SQL, после чего в текстовое поле введите команду:\n
CREATE TABLE Преподаватели\n
(КодПреподавателя INT PRIMARY KEY,\n
Фамилия CHAR(20),\n
Имя CHAR (15),\n
Отчество CHAR (15),\n
Пол CHAR (1),\n
Дата_рождения DATE,\n
Основной_предмет CHAR (200));\n
где «CREATE TABLE» означает создание таблицы «Преподаватели», а «CHAR», «DATE» и «INT» — типы данных для соответствующих значений.\n

1.	Кликните по кнопке «Выполнить».\n
2.	Откройте созданную таблицу.\n

Внимание! В конце каждого запроса должен стоять символ «;». Без него выполнение скрипта приведет к ошибке.\n
На добавление, удаление, редактирование\n
Здесь все гораздо проще. Снова перейдите в поле для создания запроса и введите следующие команды:\n
1.	для заполнения кортежа:\n
INSERT INTO Преподаватели\n
VALUES (1, ‘Иванова’, ‘Иванна’, ‘Ивановна’, ‘Ж’, ’05-06-1981′, ‘География’);\n
2.	для редактирования записи:\n
UPDATE Преподаватели SET Имя = ‘Анна’;\n

3.	для удаления:\n
DELETE * FROM Преподаватели WHERE Имя=’Анна’;.\n\n

Создание формы\n
При огромном количестве полей в таблице заполнять базу данных становится сложно. Можно случайно пропустить значение, ввести неверное или другого типа. В данной ситуации на помощь приходят формы, с помощью которых можно быстро заполнять сущности, а вероятность допустить ошибку минимизируется. Для этого потребуются следующие действия:\n
4.	Откройте интересующую таблицу.\n
5.	Перейдите во вкладку «Создание».\n
6.	Нажмите на необходимый формат формы из блока «Формы».\n

Совет! Рекомендуется использовать «Разделенную форму» – кроме самого шаблона, в нижней части будет отображаться миниатюра таблицы, которая сделает процесс редактирования еще более наглядным.\n
7.	С помощью навигационных кнопок переходите к следующей записи и вносите изменения.\n

Все базовые функции MS Access 2007 мы уже рассмотрели. Остался последний важный компонент – формирование отчета.\n\n
Формирование отчета\n
Отчет – это специальная функция MS Access, позволяющая оформить и подготовить для печати данные из базы данных. В основном это используется для создания товарных накладных, бухгалтерских отчетов и прочей офисной документации.\n
Если вы никогда не сталкивались с подобной функцией, рекомендуется воспользоваться встроенным «Мастером отчетов». Для этого сделайте следующее:\n
•	Перейдите во вкладку «Создание».\n
•	Нажмите на кнопку «Мастер отчетов» в блоке «Отчеты».\n

•	Выберите интересующую таблицу и поля, нужные для печати.\n

•	Добавьте необходимый уровень группировки.\n

•	Выберите тип сортировки каждого из полей.\n

•	Настройте вид макета для отчета.\n

•	Выберите подходящий стиль оформления.\n

Внимание! В официальных документах допускается только стандартный стиль оформления.\n
•	Просмотрите созданный отчет.\n

Если отображение вас не устраивает, его можно немного подкорректировать. Для этого:\n
1.	Нажмите ПКМ на вкладке отчета и выберите «Конструктор».\n
2.	Вручную расширьте интересующие столбцы.\n
3.	Сохраните изменения.\n
</item>
 <!--10--><item>10.МОДЕЛИ И ИХ СВОЙСТВА. ДАТА MINING.\n\n\n\n\n\n\n\n
Основные понятия\n
Знания есть не только у человека, но и у накопленных данных, которые подвергаются анализу. Такие знания содержатся в огромной объеме информации, которую человек не в силах исследовать самостоятельно. В связи с этим существует вероятность пропустить гипотезы, которые могут принести значительную выгоду.\n
Для обнаружения «скрытых» знаний применяется специальные методы автоматического анализа, при помощи которых приходиться практически добывать знания из «завалов» информации. За этим направлением закрепился термин «добыча данных (DataMining)» или «интеллектуальный анализ данных».\n
Существует множество определений DataMining, которые друг друга дополняют. Вот некоторые из них.\n
DataMining – это процесс обнаружения в базах данных нетривиальных и практически полезных закономерностей. (BaseGroup)\n
DataMining – это процесс выделения, исследования и моделирования больших объемов данных для обнаружения неизвестных до этого структур(patterns) с целью достижения преимуществ в бизнесе. (SAS Institute)\n
DataMining – это процесс, цель которого – обнаружить новые значимые корреляции, образцы и тенденции в результате просеивания большого объема хранимых данных с использованием методик распознавания образцов плюс применение статистических и математических методов. (GartnerGroup)\n
DataMining – это исследование и обнаружение «машиной» (алгоритмами, средствами искусственного интеллекта) в сырых данных скрытых знаний, которые ранее не были известны, нетривиальны, практически полезны, доступны для интерпретации человеком. (А.Баргесян «Технологии анализа данных»)\n
DataMining – это процесс обнаружения полезных знаний о бизнесе. (Н.М.Абдикеев «КБА»)\n
Свойства обнаруживаемых знаний\n
Рассмотрим свойства обнаруживаемых знаний.\n
1.	Знания должны быть новые, ранее неизвестные. Затраченные усилия на открытие знаний, которые уже известны пользователю, не окупаются. Поэтому ценность представляют именно новые, ранее неизвестные знания.\n
2.	Знания должны быть нетривиальны. Результаты анализа должны отражать неочевидные, неожиданные закономерности в данных, составляющие так называемые скрытые знания. Результаты, которые могли бы быть получены более простыми способами (например, визуальным просмотром), не оправдывают привлечение мощных методов DataMining.\n
3.	Знания должны быть практически полезны. Найденные знания должны быть применимы, в том числе и на новых данных, с достаточно высокой степенью достоверности. Полезность заключается в том, чтобы эти знания могли принести определенную выгоду при их применении.\n
4.	Знания должны быть доступны для понимания человеку. Найденные закономерности должны быть логически объяснимы, в противном случае существует вероятность, что они являются случайными. Кроме того, обнаруженные знания должны быть представлены в понятном для человека виде.\n
В DataMining для представления полученных знаний служат модели. Виды моделей зависят от методов их создания. Наиболее распространенными являются: правила, деревья решений, кластеры и математические функции.\n\n
Задачи DataMining\n
Напомним, что в основу технологии DataMining положена концепция шаблонов, представляющих собой закономерности. В результате обнаружения этих, скрытых от невооруженного глаза закономерностей решаются задачи DataMining. Различным типам закономерностей, которые могут быть выражены в форме, понятной человеку, соответствуют определенные задачи DataMining.\n
Единого мнения относительно того, какие задачи следует относить к DataMining, нет. Большинство авторитетных источников перечисляют следующие: классификация,
кластеризация, прогнозирование, ассоциация, визуализация, анализ и обнаружение отклонений, оценивание, анализ связей, подведение итогов.\n
Цель описания, которое следует ниже, - дать общее представление о задачах DataMining, сравнить некоторые из них, а также представить некоторые методы, с помощью которых эти задачи решаются. Наиболее распространенные задачи DataMining - классификация,кластеризация, ассоциация, прогнозирование и визуализация. Таким образом, задачи подразделяются по типам производимой информации, это наиболее общая классификация задач DataMining.\n\n
Классификация (Classification)\n
Задача разбиения множества объектов или наблюдений на априорно заданные группы, называемые классами, внутри каждой из которых они предполагаются похожими друг на друга, имеющими примерно одинаковые свойства и признаки. При этом решение получается на основе анализа значений атрибутов (признаков).\n
Классификация является одной из важнейших задач DataMining. Она применяется в маркетинге при оценке кредитоспособности заемщиков, определении лояльности клиентов, распознавании образов, медицинской диагностике и многих других приложениях. Если аналитику известны свойства объектов каждого класса, то когда новое наблюдение относится к определенному классу, данные свойства автоматически распространяются и на него.\n
Если число классов ограничено двумя, то имеет место бинарная классификация, к которой могут быть сведены многие более сложные задачи. Например, вместо определения таких степеней кредитного риска, как «Высокий», «Средний» или «Низкий», можно использовать всего две - «Выдать» или «Отказать».\n
Для классификации в DataMining используется множество различных моделей: нейронные сети, деревья решений, машины опорных векторов, метод k-ближайших соседей, алгоритмы покрытия и др., при построении которых применяется обучение с учителем, когда выходная переменная (метка класса) задана для каждого наблюдения. Формально классификация производится на основе разбиения пространства признаков на области, в пределах каждой из которых многомерные векторы рассматриваются как идентичные. Иными словами, если объект попал в область пространства, ассоциированную с определенным классом, он к нему и относится.\n\n
Кластеризация (Clustering)\n
Краткое описание. Кластеризация является логическим продолжением идеи классификации. Это задача более сложная, особенность кластеризации заключается в том, что классы объектов изначально не предопределены. Результатом кластеризации является разбиение объектов на группы.\n
Пример метода решения задачи кластеризации: обучение "без учителя" особого вида нейронных сетей - самоорганизующихся карт Кохонена.\n\n
Ассоциация (Associations)\n
Краткое описание. В ходе решения задачи поиска ассоциативных правил отыскиваются закономерности между связанными событиями в наборе данных.
Отличие ассоциации от двух предыдущих задач DataMining: поиск закономерностей осуществляется не на основе свойств анализируемого объекта, а между несколькими событиями, которые происходят одновременно. Наиболее известный алгоритм решения задачи поиска ассоциативных правил – алгоритм Apriori.\n\n
Последовательность (Sequence) или последовательная ассоциация (sequentialassociation)\n
Краткое описание. Последовательность позволяет найти временные закономерности между транзакциями. Задача последовательности подобна ассоциации, но ее целью является установление закономерностей не между одновременно наступающими событиями, а между событиями, связанными во времени (т.е. происходящими с некоторым определенным интервалом во времени). Другими словами, последовательность определяется высокой вероятностью цепочки связанных во времени событий. Фактически, ассоциация является частным случаем последовательности с временным лагом, равным нулю. Эту задачу DataMining также называют задачей нахождения последовательных шаблонов (sequentialpattern).\n
Правило последовательности: после события X через определенное время произойдет событие Y.\n
Пример. После покупки квартиры жильцы в 60% случаев в течение двух недель приобретают холодильник, а в течение двух месяцев в 50% случаев приобретается телевизор. Решение данной задачи широко применяется в маркетинге и менеджменте, например, при управлении циклом работы с клиентом (CustomerLifecycleManagement).\n\n

Регрессия, прогнозирование (Forecasting)\n
Краткое описание. В результате решения задачи прогнозирования на основе особенностей исторических данных оцениваются пропущенные или же будущие значения целевых численных показателей.\n
Для решения таких задач широко применяются методы математической статистики, нейронные сети и др.\n\n

Дополнительные задачи\n
Определение отклонений или выбросов (DeviationDetection), анализ отклонений или выбросов\n
Краткое описание. Цель решения данной задачи - обнаружение и анализ данных, наиболее отличающихся от общего множества данных, выявление так называемых нехарактерных шаблонов.\n\n
Оценивание (Estimation)\n
Задача оценивания сводится к предсказанию непрерывных значений признака.\n
Анализ связей (LinkAnalysis)\n
Задача нахождения зависимостей в наборе данных.\n
Визуализация (Visualization, GraphMining)\n
В результате визуализации создается графический образ анализируемых данных. Для решения задачи визуализации используются графические методы, показывающие наличие закономерностей в данных.\n
Пример методов визуализации - представление данных в 2-D и 3-D измерениях.\n\n
Подведение итогов (Summarization)\n
Задача, цель которой - описание конкретных групп объектов из анализируемого набора данных.\n
Достаточно близким к вышеупомянутой классификации является подразделение задач DataMining на следующие: исследования и открытия, прогнозирования и классификации, объяснения и описания.\n
Автоматическое исследование и открытие (свободный поиск)\n
Пример задачи: обнаружение новых сегментов рынка.\n
Для решения данного класса задач используются методы кластерного анализа.\n
Прогнозирование и классификация\n
Пример задачи: предсказание роста объемов продаж на основе текущих значений.\n
Методы: регрессия, нейронные сети, генетические алгоритмы, деревья решений.\n
Задачи классификации и прогнозирования составляют группу так называемого индуктивного моделирования, в результате которого обеспечивается изучение анализируемого объекта или системы. В процессе решения этих задач на основе набора данных разрабатывается общая модель или гипотеза.\n\n
Объяснение и описание\n
Пример задачи: характеристика клиентов по демографическим данным и историям покупок.\n
Методы: деревья решения, системы правил, правила ассоциации, анализ связей.\n
Если доход клиента больше, чем 50 условных единиц, и его возраст - более 30 лет, тогда класс клиента - первый.\n
Сравнение кластеризации и классификации\n
Характеристика	Классификация	Кластеризация\n
Контролируемость обучения	Контролируемое	Неконтролируемое\n
Стратегии	Обучение с учителем	Обучение без учителя\n
Наличие метки класса Обучающее множество сопровождается меткой, указывающей класс, к которому относится наблюдение	Метки класса обучающего
множества неизвестны\n
Основание для классификации	Новые данные классифицируются на основании обучающего множества	Дано множество данных с целью
установления существования классов или кластеров данных\n\n

Сферы применения DataMining\n
Следует отметить, что на сегодняшний день наибольшее распространение технология DataMining получила при решении бизнес-задач. Возможно, причина в том, что именно в этом направлении отдача от использования инструментов DataMining может составлять, по некоторым источникам, до 1000% и затраты на ее внедрение могут достаточно быстро окупиться.\n
Мы будем рассматривать четыре основные сферы применения технологии DataMining подробно: наука, бизнес, исследования для правительства и Web-направление.\n
Применение DataMining для решения бизнес-задач. Основные направления: банковское дело, финансы, страхование, CRM, производство, телекоммуникации, электронная коммерция, маркетинг, фондовый рынок и другие.\n
1.	Выдавать ли кредит клиенту\n
2.	Сегментация рынка\n
3.	Привлечение новых клиентов\n
4.	Мошенничество с кредитными карточками\n
Применение DataMining для решения задач государственного уровня. Основные направления: поиск лиц, уклоняющихся от налогов; средства в борьбе с терроризмом.\n
Применение DataMining для научных исследований. Основные направления: медицина, биология, молекулярная генетика и генная инженерия, биоинформатика, астрономия, прикладная химия, исследования, касающиеся наркотической зависимости, и другие.\n
Применение DataMining для решения Web-задач. Основные направления: поисковые машины (search engines), счетчики и другие.\n\n
Электронная коммерция\n
В сфере электронной коммерции DataMining применяется для формирования рекомендательных систем и решения задач классификации посетителей Web-сайтов.\n
Такая классификация позволяет компаниям выявлять определенные группы клиентов и проводить маркетинговую политику в соответствии с обнаруженными интересами и потребностями клиентов. Технология DataMining для электронной коммерции тесно связана с технологией WebMining.\n\n
Основные задачи DataMining в промышленном производстве:\n
· комплексный системный анализ производственных ситуаций;\n
· краткосрочный и долгосрочный прогноз развития производственных ситуаций;\n
· выработка вариантов оптимизационных решений;\n
· прогнозирование качества изделия в зависимости от некоторых параметров технологического процесса;\n
· обнаружение скрытых тенденций и закономерностей развития производственныхпроцессов;\n
· прогнозирование закономерностей развития производственных процессов;\n
· обнаружение скрытых факторов влияния;\n
· обнаружение и идентификация ранее неизвестных взаимосвязей между производственными параметрами и факторами влияния;\n
· анализ среды взаимодействия производственных процессов и прогнозирование изменения ее характеристик;\n
· выработку оптимизационных рекомендаций по управлению производственнымипроцессами;\n
· визуализацию результатов анализа, подготовку предварительных отчетов и проектов допустимых решений с оценками достоверности и эффективности возможных реализаций.\n\n
Маркетинг\n
В сфере маркетинга DataMining находит очень широкое применение.\n
Основные вопросы маркетинга "Что продается?", "Как продается?", "Кто является потребителем?"\n
В лекции, посвященной задачам классификации и кластеризации, подробно описано использование кластерного анализа для решения задач маркетинга, как, например, сегментация потребителей.\n
Другой распространенный набор методов для решения задач маркетинга - методы и алгоритмы поиска ассоциативных правил.\n
Также успешно здесь используется поиск временных закономерностей.\n\n
Розничная торговля\n
В сфере розничной торговли, как и в маркетинге, применяются:\n
· алгоритмы поиска ассоциативных правил (для определения часто встречающихся наборов товаров, которые покупатели покупают одновременно). Выявление таких правил помогает размещать товары на прилавках торговых залов, вырабатывать стратегии закупки товаров и их размещения на складах и т.д.\n
· использование временных последовательностей, например, для определения необходимых объемов запасов товаров на складе.\n
· методы классификации и кластеризации для определения групп или категорий клиентов, знание которых способствует успешному продвижению товаров.\n\n
Фондовый рынок\n
Вот список задач фондового рынка, которые можно решать при помощи технологии DataMining: · прогнозирование будущих значений финансовых инструментов и индикаторов по их прошлым значениям;\n
· прогноз тренда (будущего направления движения - рост, падение, флэт) финансового инструмента и его силы (сильный, умеренно сильный и т.д.);\n
· выделение кластерной структуры рынка, отрасли, сектора по некоторому набору характеристик;\n
· динамическое управление портфелем;\n
· прогноз волатильности;\n
· оценка рисков;\n
· предсказание наступления кризиса и прогноз его развития;\n
· выбор активов и др.\n
Кроме описанных выше сфер деятельности, технология DataMining может применяться в самых разнообразных областях бизнеса, где есть необходимость в анализе данных и накоплен некоторый объем ретроспективной информации.\n\n
Применение DataMining в CRM\n
Одно из наиболее перспективных направлений применения DataMining – использование данной технологии в аналитическом CRM.\n
CRM (CustomerRelationshipManagement) - управление отношениями с клиентами.\n
При совместном использовании этих технологий добыча знаний совмещается с "добычей денег" из данных о клиентах.\n
Важным аспектом в работе отделов маркетинга и отдела продаж является составление целостного представления о клиентах, информация об их особенностях, характеристиках, структуре клиентской базы. В CRM используется так называемое профилирование клиентов, дающее полное представление всей необходимой информации о клиентах.\n
Профилирование клиентов включает следующие компоненты: сегментация клиентов, прибыльность клиентов, удержание клиентов, анализ реакции клиентов. Каждый из этих компонентов может исследоваться при помощи DataMining, а анализ их в совокупности, как компонентов профилирования, в результате может дать те знания, которые из каждой отдельной характеристики получить невозможно.\n\n
WebMining\n
WebMining можно перевести как "добыча данных в Web".\n
Интеллект готов "открыть новую главу" в стремительном развитии электронного бизнеса. Способность определять интересы и предпочтения каждого посетителя, наблюдая за его поведением, является серьезным и критичным преимуществом конкурентной борьбы на рынке электронной коммерции.\n
Системы WebMining могут ответить на многие вопросы, например, кто из посетителей является потенциальным клиентом Web-магазина, какая группа клиентов Web-магазина приносит наибольший доход, каковы интересы определенного посетителя или группы посетителей.\n\n
</item>
 <!--11--><item>11.РЕЛЯЦИОННЫЕ ХРАНИЛИЩА ДАННЫХ (ROLAP).\n\n\n\n\n
ROLAP (реляционная OLAP) — OLAP-системы, которые имеют прямой доступ к существующим базам данных или используют данные, выгруженные в собственные локальные таблицы.\n
Общие сведения\n
Аналитические запросы в ROLAP строятся над виртуальным многомерным представлением данных, и их выполнение происходит на уровне реляционной базы данных, то есть выполняются SQL-запросы над реляционной системой. Основными составляющими архитектуры баз данных являются таблица фактов (fact table) и таблицы измерений (dimension tables). Таблица фактов является основной таблицей базы данных. В ней обычно содержатся сведения об объектах или событиях, совокупность которых будет подвергнута анализу. Таблицы измерений содержат постоянные либо редко изменяемые данные. Они содержат как минимум одно описательное поле и целочисленное ключевое поле для однозначной идентификации измеряемой величины. Таблица измерений обязательно должна находиться в отношении «один ко многим» с таблицей фактов; если каждое измерение находится в одной таблице измерений, то такая схема называется «звезда» (star schema). Если же хотя бы одно из измерений находится в нескольких взаимосвязанных таблицах, то такая схема построения называется «снежинка» (snowflake schema).\n
Условия применения\n
Если многомерная модель реализуется в виде реляционной базы данных, необходимо ее представлять как длинные и «узкие» таблицы фактов и сравнительно небольшие и «широкие» таблицы измерений. Таблицы фактов содержат числовые значения ячеек гиперкуба, а остальные таблицы определяют содержащую их многомерную совокупность измерений. Часть информации можно получать с помощью динамической агрегации данных, распределенных по нормализованным структурам, отличающимся по своей архитектуре от «звезды», но в этом случае включающие агрегацию запросы при высоконормализованной структуре БД могут выполняться довольно медленно. Представление многомерной информации с помощью звездообразных реляционных моделей устраняет проблему оптимизации хранения разреженных матриц, остро стоящую перед многомерными СУБД , в которых проблема разреженности решается специальным выбором схемы. Хотя для хранения каждой ячейки используется целая запись, включающая, кроме непосредственно значений, вторичные ключи — ссылки на таблицы измерений, несуществующие значения просто не включаются в таблицу фактов.\n
Оценка качества\n
ROLAP-системы имеют свои преимущества и недостатки в сравнении с многомерными системами.\n
Достоинства\n
•	реляционные СУБД могут работать с очень большими БД и имеют развитые функции администрирования. При использовании ROLAP размер хранилища не является настолько важным параметром, как в случае с MOLAP\n
•	при оперативной аналитической обработке содержимого хранилища данных инструменты ROLAP позволяют производить анализ непосредственно над хранилищем, ведь обычно корпоративные хранилища данных реализуются с помощью реляционных СУБД\n
•	при изменяющейся размерности задачи, когда изменения в структуру измерений вносятся достаточно часто, ROLAP системы с динамическим представлением размерности предстают наилучшим решением, так как в них такие манипуляции не требуют физической реорганизации БД.\n
•	Системы ROLAP могут функционировать на гораздо менее мощных клиентских станциях, поскольку основная вычислительная нагрузка приходится на сервер, где выполняются сложные аналитические SQL-запросы, формируемые системой\n
•	реляционные СУБД обеспечивают значительно более высокий уровень защиты данных и хорошие возможности разграничения прав доступа\n
Недостатки\n
•	Ограниченные возможности расчета значений функционального типа.\n
•	Меньшая производительность, чем у MOLAP. Для обеспечения сравнимой с MOLAP производительности реляционные системы требуют тщательной проработки схемы БД и специальной настройки индексов. Но в результате такой работы производительность хорошо настроенных реляционных систем при использовании схемы «звезда» сравнима с производительностью систем на основе многомерных БД.\n

</item>
 <!--12--><item>12.ТЕХНОЛОГИЯ OLAP. СУЩНОСТЬ МНОГОМЕРНОГО ПРЕДСТАВЛЕНИЯ ДАННЫХ.\n\n\n\n
OLAP (англ. online analytical processing, интерактивная аналитическая обработка) — технология обработки данных, заключающаяся в подготовке суммарной (агрегированной) информации на основе больших массивов данных, структурированных по многомерному принципу. Реализации технологии OLAP являются компонентами программных решений класса Business Intelligence.\n
Основоположник термина OLAP — Эдгар Кодд, предложил в 1993 году «12 правил аналитической обработки в реальном времени» (по аналогии с ранее сформулированными «12 правил для реляционных баз данных»).\n\n

Действие OLAP \n
Причина использования OLAP для обработки запросов — скорость. Реляционные базы данных хранят сущности в отдельных таблицах, которые обычно хорошо нормализованы. Эта структура удобна для операционных баз данных (системы OLTP), но сложные многотабличные запросы в ней выполняются относительно медленно.
OLAP-структура, созданная из рабочих данных, называется OLAP-куб. Куб создаётся из соединения таблиц с применением схемы звезды или схемы снежинки. В центре схемы звезды находится таблица фактов, которая содержит ключевые факты, по которым делаются запросы. Множественные таблицы с измерениями присоединены к таблице фактов. Эти таблицы показывают, как могут анализироваться агрегированные реляционные данные. Количество возможных агрегирований определяется количеством способов, которыми первоначальные данные могут быть иерархически отображены.\n
Например, все клиенты могут быть сгруппированы по городам или регионам страны (Запад, Восток, Север и так далее), таким образом, 50 городов, восемь регионов и две страны составят три уровня иерархии с 60-ю членами. Также клиенты могут быть объединены по отношению к продукции; если существуют 250 продуктов по 20 категориям, три группы продукции и три производственных подразделения, то количество агрегатов составит 16 560. При добавлении измерений в схему количество возможных вариантов быстро достигает десятков миллионов и более.\n
OLAP-куб содержит базовые данные и информацию об измерениях (агрегаты). Куб потенциально содержит всю информацию, которая может потребоваться для ответов на любые запросы. При огромном количестве агрегатов зачастую полный расчёт происходит только для некоторых измерений, для остальных же производится «по требованию».\n
Существуют три типа OLAP:\n
o	многомерная OLAP (Multidimensional OLAP — MOLAP);\n
o	реляционная OLAP (Relational OLAP — ROLAP);\n
o	гибридная OLAP (Hybrid OLAP — HOLAP).\n
MOLAP — классическая форма OLAP, так что её часто называют просто OLAP. Она использует суммирующую базу данных и создаёт требуемую многомерную схему данных с сохранением как базовых данных, так и агрегатов.\n
ROLAP работает напрямую с реляционной базой данных, факты и таблицы с измерениями хранятся в реляционных таблицах, и для хранения агрегатов создаются дополнительные реляционные таблицы.\n
HOLAP использует реляционные таблицы для хранения базовых данных и многомерные таблицы для агрегатов.\n
Особым случаем ROLAP является «ROLAP реального времени» (Real-time ROLAP — R-ROLAP). В отличие от ROLAP в R-ROLAP для хранения агрегатов не создаются дополнительные реляционные таблицы, а агрегаты рассчитываются в момент запроса. При этом многомерный запрос к OLAP-системе автоматически преобразуется в SQL-запрос к реляционным данным.\n
Каждый тип хранения имеет определённые преимущества, хотя есть разногласия в их оценке у разных производителей. MOLAP лучше всего подходит для небольших наборов данных, он быстро рассчитывает агрегаты и возвращает ответы, но при этом генерируются огромные объёмы данных. ROLAP считается более масштабируемым решением, притом более экономичным к пространству хранения, но с ограничениями по возможностям аналитической обработки. HOLAP находится посреди этих двух подходов, он достаточно хорошо масштабируется, и позволяет преодолеть ряд ограничений. Архитектура R-ROLAP позволяет производить многомерный анализ OLTP-данных в режиме реального времени.\n
Сложность в применении OLAP состоит в создании запросов, выборе базовых данных и разработке схемы, в результате чего большинство продуктов OLAP поставляются вместе с огромным количеством предварительно настроенных запросов. Другая проблема — в базовых данных, они должны быть полными и непротиворечивыми.\n
Реализации OLAP\n
Исторически первой многомерной системой управления базами данных, по существу являющейся OLAP-реализацией, считается система Express, разработанная в 1970-м году компанией IRI (позднее права на продукт были приобретены корпорацией Oracle и превращён в OLAP-опцию для Oracle Database). Термин OLAP ввёл Эдгар Кодд в публикации в журнале Computerworld в 1993 году, в которой он предложил 12 принципов аналитической обработки, по аналогии с 12 правилами для реляционных баз данных, сформулированными им же десятилетием ранее, в качестве референтного продукта, удовлетворяющего предложенным принципам, Кодд указал систему Essbase компании Arbor (поглощённой в 1997 году компанией Hyperion, которую, в свою очередь, в 2007-м году купила Oracle). Примечательно, что впоследствии публикация была изъята из архивов Computerworld из-за возможного конфликта интересов, так как Кодд позднее оказывал консультационные услуги для Arbor.\n
С точки зрения реализации, делятся на «физическую OLAP» и «виртуальную» (реляционную, англ. Relational OLAP, ROLAP). «Физическая», в свою очередь, в зависимости от реализации подразделяется на многомерную (англ. Multidimensional OLAP, MOLAP) и гибридную — (англ. Hybrid OLAP, HOLAP).\n
В первом случае наличествует программа, выполняющая на этапе предварительной загрузки данных в OLAP предварительный расчёт агрегатов (вычислений по нескольким исходным значениям, например «итог за месяц»), которые затем сохраняются в специальную многомерную базу данных, обеспечивающую быстрое извлечение и экономичное хранение.\n
Гибридная реализация является комбинацией: сами данные хранятся в реляционной базе данных, а агрегаты — в многомерной.\n
В ROLAP-реализациях все данные хранятся и обрабатываются в реляционных системах управления базами данных, а агрегаты могут не существовать вообще или создаваться по первому запросу к базе данных или кэше аналитического программного обеспечения.\n
С точки зрения пользователя, все варианты выглядят похожими по возможностям. Наибольшее применение OLAP находит в продуктах для финансового планирования, хранилищах данных, решениях класса Business Intelligence.\n
Среди коммерческих продуктов выделяют: Microsoft SQL Server Analysis Services, Essbase, PowerPlay, BusinessObjects, MicroStrategy, SAP BW, Cartesis Magnitude, Oracle Database OLAP Option, TM1. Существует несколько свободных решений, среди них отмечаются Mondrian и Palo.\n

</item>
 <!--13--><item>13.АЛГОРИТМЫ ИНТЕЛЛЕКТУАЛЬНОГО АНАЛИЗА ДАННЫХ.\n\n\n\n
Алгоритм интеллектуального анализа данных представляет собой механизм, создающий модель интеллектуального анализа данных. Чтобы создать модель, алгоритм сначала анализирует набор данных, осуществляя поиск определенных закономерностей и трендов. Алгоритм использует результаты этого анализа для определения параметров модели интеллектуального анализа данных. Затем эти параметры применяются ко всему набору данных, чтобы выявить пригодные к использованию закономерности и получить подробную статистику.\n
Ниже перечислены алгоритмы интеллектуального анализа данных, реализованные в Microsoft SQL Server 2008 R2 (указание на Майкрософт говорит о том, что это ее реализации алгоритмов, а приводимые английские названия понадобятся нам в дальнейшем):\n\n
1.	Упрощенный алгоритм Байеса (Майкрософт) - MicrosoftNaiveBayes;\n
Упрощенный алгоритм Байеса является алгоритмом классификации на основе Байеса теоремах и может использоваться как для произвольного, так и для прогнозного моделирования. Слово «упрощенный» в его названии указывает на то, что алгоритм использует методы Байеса, но не учитывает возможные зависимости.\n
Данный алгоритм требует меньшего количества вычислений, чем другие алгоритмы Microsoft, и может применяться для быстрого формирования моделей интеллектуального анализа данных для обнаружения отношений между входными и прогнозируемыми столбцами. Этот алгоритм можно использовать для первоначального исследования данных, а затем применить результаты для создания дополнительных моделей интеллектуального анализа с другими алгоритмами, требующими большего количества вычислений и являющимися более точными.\n\n
2.	Алгоритм дерева принятия решений (Майкрософт) - MicrosoftDecisionTrees;\n
Алгоритм дерева принятия решений (Microsoft) представляет собой алгоритм регрессии и классификации для использования в прогнозном моделировании дискретных и непрерывных атрибутов.\n
Для дискретных атрибутов алгоритм осуществляет прогнозирования на основе связи между входными столбцами в наборе данных. Он использует значения этих столбцов (известные как состояния) для прогнозирования состояний столбца, который обозначается как прогнозируемый. Алгоритм идентифицирует входные столбцы, которые коррелированы с прогнозируемым столбцом. Например, в сценарии для прогнозирования того, какие заказчики, скорее всего, приобретут велосипед, если девять из десяти молодых заказчиков покупают велосипед, но только двое из более старших заказчиков делают это, то алгоритм заключает, что возраст является хорошим прогнозом приобретения велосипеда. Дерево решений осуществляет прогнозирование на основе этой тенденции в направлении конкретного результата.\n
Для непрерывных атрибутов алгоритм использует линейную регрессию для определения места разбиения дерева решений.\n
Если несколько столбцов установлены как прогнозируемые или если входные данные содержат вложенную таблицу, которая задана как прогнозируемая, то алгоритм строит отдельное дерево решений для каждого прогнозируемого столбца\n\n
3.	Алгоритм временных рядов (Майкрософт) - MicrosoftTimeSeries;\n
Алгоритм временных рядов ( Microsoft ) предоставляет несколько алгоритмов, оптимизированных для прогноза непрерывных значений, таких как продажи продуктов, во времени. В отличие от других алгоритмов Microsoft , таких как деревья принятия решений, модель временных рядов не требует дополнительных столбцов новых сведений, чтобы прогнозировать тренд. С помощью модели временных рядов можно прогнозировать тенденции на основе только исходного набора данных, использованного для создания модели. При прогнозировании можно вводить в модель новые данные и автоматически задействовать их при анализе тенденций.\n
Сочетание исходных данных и прогнозируемых данных называется рядом.\n
Важной характеристикой алгоритма временных рядов ( Microsoft ) является его способность выполнять перекрестный прогноз. При обучении алгоритма двумя отдельными, но связанными друг с другом рядами можно использовать итоговую модель для прогнозирования исхода одного ряда на основе поведения другого ряда. Например, наблюдаемые продажи одного продукта могут оказать влияние на прогнозируемые продажи другого продукта. Перекрестные прогнозы также полезны при создании общей модели, которую можно применить к нескольким рядам. Например, прогнозы для определенного региона нестабильны, так как в ряду недостаточно данных хорошего качества. Общую модель можно обучить на среднем значении всех четырех регионов, а затем применить модель к отдельным рядам, чтобы подготовить более стабильные прогнозы для каждого региона.\n\n
4.Алгоритм кластеризации (Майкрософт) - MicrosoftClustering;\n
Алгоритм кластеризации Microsoft является алгоритмом сегментации или кластеризации , который выполняет итерацию вариантов в наборе данных, чтобы сгруппировать их в кластеры, содержащие подобные характеристики. Такие группирования полезно использовать для просмотра данных, выявления в них аномалий и создания прогнозов.\n
Модели кластеризации определяют связи в наборе данных, который невозможно логически получить с помощью случайного наблюдения. Например, можно логически догадаться, что люди, добирающиеся на работу на велосипеде, не обязательно живут далеко от работы. Алгоритм может найти другие не очевидные характеристики велосипедистов. На следующей диаграмме кластер А соответствует людям, добирающимся до работы на машине, а кластер Б — людям, добирающимся до работы на велосипеде.\n
Алгоритм кластеризации отличается от других алгоритмов интеллектуального анализа данных, например алгоритма дерева принятия решений Microsoft , в котором не требуется назначать прогнозируемый столбец, необходимый для создания модели кластеризации. Алгоритм кластеризации обучает модель строго на основе связей, существующих в данных и на основе кластеров, идентифицированных алгоритмом.\n\n
5.Алгоритм кластеризации последовательностей (Майкрософт) - MicrosoftSequenceClustering;\n
Алгоритм кластеризации последовательностей Microsoft — это уникальный алгоритм сочетающий в себе анализ последовательностей и кластеризацию. Данный алгоритм можно использовать для просмотра данных, содержащих события, которые могут быть связаны в последовательность. Алгоритм находит самые распространенные последовательности и выполняет кластеризацию для поиска идентичных последовательностей. Ниже описаны типы последовательностей, которые можно использовать в качестве данных для машинного обучения, чтобы получить сведения о стандартных проблемах или бизнес-сценариях:\n
•	Сведения о посещениях и схемах щелчков, которые создаются, когда пользователи переходят по веб-сайту или просматривают его.\n
•	Журналы, в которых перечислены события, предшествовавшие инциденту, такие как сбой жесткого диска или взаимоблокировка сервера.\n
•	Записи транзакций, описывающие порядок, в котором клиент добавляет в корзину товары, выбранные в интернет-магазине.\n
•	Записи, следящие за взаимодействием с клиентом или пациентом во времени для прогнозирования отмены услуг или других нежелательных итогов.\n
Этот алгоритм во многом напоминает алгоритм кластеризации Microsoft . Однако вместо поиска кластеров вариантов, содержащих похожие атрибуты, алгоритм кластеризации последовательностей Microsoft находит кластеры вариантов, содержащие похожие пути в последовательности.\n\n
6.Алгоритм взаимосвязей Майкрософт - MicrosoftAssociationRules;\n
Алгоритм взаимосвязей Microsoft часто используется для механизмов выработки рекомендаций. Механизм рекомендаций рекомендует продукты пользователям на основе элементов, которые они уже купили или к которым проявили интерес. Алгоритм взаимосвязей Microsoft удобно использовать для анализа потребительской корзины.
Модели взаимосвязей построены на наборах данных, содержащих идентификаторы для отдельных вариантов и элементов этих вариантов. Группа элементов в варианте называется набор элементов. Модель взаимосвязей состоит из рядов наборов элементов и правил, описывающих, как эти элементы группируются в вариантах. Правила, определяемые алгоритмом, могут использоваться для прогнозирования вероятных будущих покупок покупателей на основе элементов, уже имеющихся в корзине покупателя. На следующей диаграмме представлен ряд правил в наборе элементов.\n
Алгоритм взаимосвязей Microsoft потенциально может находить множество правил внутри набора данных. Для описания набора элементов и формируемых ими правил алгоритм использует два параметра: мощность несущего множества и вероятность. Например, если X и Y представляют два элемента, которые могут находиться в корзине для покупок, то параметр несущего множества будет равен количеству вариантов в наборе данных, содержащих сочетание элементов X и Y. Используя параметр несущего множества в сочетании с пользовательскими параметрами MINIMUM_SUPPORT и MAXIMUM_SUPPORT , алгоритм управляет количеством создаваемых наборов элементов. Параметр вероятности, называемый также достоверностью, представляет часть вариантов в наборе данных, содержащих X и Y. Используя параметр вероятности в сочетании с параметром MINIMUM_PROBABILITY , этот алгоритм управляет количеством сформированных правил.\n\n
7.	Алгоритм нейронной сети (Майкрософт) - MicrosoftNeuralNetwork;\n
Алгоритм нейронной сети Microsoft представляет собой реализацию архитектуры распространенной и адаптируемой нейронной сети для машинного обучения. Алгоритм работает путем тестирования каждого возможного состояния входного атрибута с каждым возможным состоянием прогнозируемого атрибута и использует обучающие данные для вычисления вероятностей каждого сочетания. Эти вероятности можно использовать для задач классификации или регрессии, а также для прогнозирования исхода на основе входных атрибутов. Нейронную сеть можно также использовать для анализа взаимосвязей.\n
При создании модели интеллектуального анализа данных с помощью алгоритма нейронной сети Microsoft можно включить несколько выходных данных, а алгоритм создаст несколько сетей. Количество сетей, содержащихся в одной модели интеллектуального анализа данных, зависит от числа состояний (или значений атрибута) во входных столбцах, а также от числа прогнозируемых столбцов, используемых в модели интеллектуального анализа данных, и числа состояний в этих столбцах.\n\n
8.	Алгоритм линейной регрессии (Майкрософт) - MicrosoftLinearRegression;\n
Алгоритм линейной регрессии Microsoft является разновидностью алгоритма дерева принятия решений Microsoft, помогающего рассчитать линейную связь между зависимой и независимой переменной, а затем использовать эту связь при прогнозировании.\n
Связь принимает вид формулы линии, представляющей ряд данных. Например, линия на следующей диаграмме является наилучшим линейным представлением данных.\n
Каждой точке на диаграмме соответствует ошибка, связанная с ее расстоянием от линии регрессии. Коэффициенты a и b в уравнении регрессии регулируют угол и положение линии регрессии. Регрессивное уравнение можно получать с помощью подбора коэффициентов a и b до тех пор, пока сумма ошибок, связанных с этими точками, не станет минимальной.\n
Существуют другие типы регрессии, в которых используется несколько переменных, а также нелинейные методы регрессии. Однако линейная регрессия является полезным и широко известным методом моделирования ответа на изменение в каком-либо базовом факторе.\n\n
9.	Алгоритм логистической регрессии (Майкрософт) - MicrosoftLogisticRegression.\n
Логистическая регрессия является известным статистическим методом, применяемым для моделирования двоичных результатов.\n
Существуют различные варианты внедрения логистической регрессии в статистических исследованиях. Такие варианты различаются по методам обучения, реализованным в них. Алгоритм логистической регрессии Microsoft реализован на основе вариации алгоритма нейронной сети Microsoft . Этот алгоритм обладает многими качествами нейронных сетей, но более прост в обучении.\n
Одним из преимуществ логистической регрессии является гибкость алгоритма, способного принимать входные данные любого рода и поддерживать несколько различных аналитических задач.\n
•	Использование демографических данных для составления прогнозов о результатах, например оценка риска некоторого заболевания.\n
•	Исследование и взвешивание факторов, влияющих на результат. Например, поиск факторов, побуждающих клиентов совершить повторное посещение магазина.\n
•	Классификация документов, электронной почты и других объектов, имеющих множество атрибутов.\n
</item>
 <!--14--><item>14.	ПРОЦЕССЫ ЖИЗНЕННОГО ЦИКЛА ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
1.Основные процессы жизненного цикла.\n
1.1.Процесс заказа.\n
Процесс заказа определяет работы и задачи заказчика. Процесс заказа состоит из определения потребностей заказчика в системе, программном продукте или программной услуге, подготовки и выпуска заявки на подряд, выбора поставщика и управления процессом заказа до завершения приемки системы, программного продукта или программной услуги.\n
1.2.Процесс поставки.\n
Процесс поставки определяет работы и задачи поставщика. Процесс поставки начинается с решения о подготовке предложения в ответ на заявку на подряд, присланную заказчиком, или с подписания договора с заказчиком на поставку системы, ПП или программной услуги. Затем определяются процедуры и ресурсы, необходимые для управления и обеспечения проекта, включая разработку проектных планов и их выполнение.\n
1.3.Процесс разработки.\n
Процесс разработки определяет работы и задачи разработчика. Данный процесс включает работы по анализу требований, проектированию, программированию, сборке, тестированию, вводу в действие и приемке программного продукта или системы.\n
1.4.Процесс эксплуатации.\n
Процесс эксплуатации определяет работы и задачи оператора. Данный процесс включает эксплуатацию программного продукта и поддержку пользователей в процессе эксплуатации.\n
1.5.Процесс сопровождения.\n
Процесс сопровождения определяет работы и задачи персонала сопровождения и реализуется при модификациях программного продукта. Цель процесса – изменение существующего ПП при сохранении его целостности. Процесс охватывает вопросы переносимости и снятия ПП с эксплуатации.\n\n
2.Вспомогательные процессы жизненного цикла.\n
2.1	Процесс документирования.\n
Процесс документирования является процессом формализованного описания информации, созданной в процессе или работе жизненного цикла. Он включает планирование, проектирование, разработку, выпуск, редактирование, распространение и сопровождение документов по программному продукту.\n
2.2 Процесс управления конфигурацией.\n
Процесс управления конфигурацией является процессом применения административных и технических процедур на всем протяжении ЖЦ ПС для определения состояния (базовой линии) программных объектов в системе, управления их изменениями и выпуском.\n
2.3	Процесс обеспечения качества\n
Процесс обеспечения качества является процессом обеспечения гарантий того, что программные продукты и процессы в жизненном цикле проекта соответствуют требованиям и планам. Данный процесс должен быть независимым от субъектов, участвующих в проекте. Это позволяет достичь объективности процесса. При обеспечении качества могут использоваться результаты процессов верификации, аттестации, совместного анализа, аудита и решения проблем\n
2.4	Процесс верификации.\n
Процесс верификации является процессом определения того, что программные продукты функционируют в полном соответствии с требованиями и условиями, реализованными в предшествующих работах.\n
Данное определение является не совсем понятным для лиц, некомпетентных в области верификации. Кроме того, оно сужает применимость верификации только до программных продуктов. Для пояснения данного определения следует рассмотреть само понятие верификации. Термин верификация (verification) обозначает подтверждение с помощью экспертизы и представления объективных доказательств того, что конкретные требования полностью реализованы. В процессе разработки верификация связана с экспертизой результатов данной работы с целью определения их соответствия установленным на входе данной работы требованиям. Таким образом, верификация может применяться не только к программным продуктам, но и к любым другим результатам работы. Например, верификации могут подвергаться требования, системная и программная архитектура, документация, методы, планы и т.п.\n
В этой связи более понятным и близким к истине является следующее определение процесса верификации. Процесс верификации – это процесс определения того, что результаты работы соответствуют требованиям или условиям, установленным на входе данной работы.\n
Процесс верификации может включать анализ, проверку и тестирование.\n
Объектами анализа и проверки могут являться, например, документация и исходные тексты программных модулей. Объектами тестирования могут являться исполнимые коды программных модулей, компонентов, промежуточных и конечного программных продуктов.\n
Данный процесс называется процессом независимой верификации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.5	Процесс аттестации и его структура.\n
Процесс аттестации является процессом определения полноты соответствия установленных требований, созданной системы или программного продукта их функциональному назначению. Чтобы пояснить это определение, следует рассмотреть понятие аттестации.\n
Термин аттестация (validation) обозначает подтверждение экспертизой и представлением объективных доказательств того, что конкретные требования к конкретным объектам полностью реализованы. В процессе разработки аттестация связана с экспертизой продукта в целях определения его соответствия потребностям пользователя (то есть исходным требованиям к проекту).\n
Аттестации (проверке на соответствие исходным требованиям) могут подвергаться любые промежуточные продукты процесса разработки. Аттестация может проводиться на начальных этапах работы и как часть работы по обеспечению приемки ПС.\n
Данный процесс называется процессом независимой аттестации, если организация–исполнитель не зависит от поставщика, разработчика, оператора или персонала сопровождения.\n
2.6	Процесс совместного анализа.\n
Процесс совместного анализа является процессом оценки состояний и результатов работ по проекту. Совместные анализы проводятся в течение всего договора и применяются как на уровне управления проектом, так и на уровне его технической реализации. Данный процесс может выполняться двумя любыми сторонами, участвующими в договоре, когда одна сторона (анализирующая) проверяет другую (анализируемую).\n
2.7	Процесс аудита.\n
Процесс аудита является процессом определения соответствия требованиям, планам и условиям договора. Данный процесс может выполняться двумя сторонами, участвующими в договоре, когда одна сторона (ревизующая) проверяет другую сторону (ревизуемую).\n
2.8	Процесс решения проблем.\n
Процесс решения проблем является процессом анализа и решения проблем (включая обнаруженные несоответствия), которые обнаружены в ходе выполнения разработки, эксплуатации, сопровождения или других процессов.\n\n
3. Организационные процессы жизненного цикла.\n
3.1 Процесс управления.\n
Процесс управления состоит из общих работ и задач, которые могут быть использованы любой стороной, управляющей соответствующим процессом. За управление продуктом, проектом, работами и задачами основных и вспомогательных процессов отвечает администратор.\n
3.2 Процесс создания инфраструктуры\n
Процесс создания инфраструктуры является процессом установления и сопровождения инфраструктуры, необходимой для любого другого процесса. Инфраструктура содержит технические и программные средства, инструментальные средства, методики, стандарты и условия для разработки, эксплуатации или сопровождения.\n
3.3 Процесс обучения\n
Процесс обучения является процессом обеспечения первоначального и продолженного обучения персонала работам по заказу, поставке, разработке, эксплуатации или сопровождению программного проекта.\n
3.4 Процесс усовершенствования\n
Процесс усовершенствования является процессом установления, оценки, измерения, контроля и улучшения любого процесса жизненного цикла программных средств.\n</item>
 <!--15--><item>15.ПРОЕКТИРОВАНИЕ ПРОГРАММНЫХ СРЕДСТВ.\n\n\n\n\n
Проектирование программного обеспечения — процесс создания проекта программного обеспечения (ПО), а также дисциплина, изучающая методы проектирования. Проектирование ПО является частным случаем проектирования продуктов и процессов.\n
Целью проектирования является определение внутренних свойств системы и детализации её внешних (видимых) свойств на основе выданных заказчиком требований к ПО (исходные условия задачи). Эти требования подвергаются анализу.\n
Проектирование ПО включает следующие основные виды деятельности:\n
•	выбор метода и стратегии решения;\n
•	выбор представления внутренних данных;\n
•	разработка основного алгоритма;\n
•	документирование ПО;\n
•	тестирование и подбор тестов;\n
•	выбор представления входных данных.\n
Первоначально программа рассматривается как чёрный ящик. Ход процесса проектирования и его результаты зависят не только от состава требований, но и выбранной модели процесса, опыта проектировщика.\n
Модель предметной области накладывает ограничения на бизнес-логику и структуры данных.\n
В зависимости от класса создаваемого ПО, процесс проектирования может обеспечиваться как «ручным» проектированием, так и различными средствами его автоматизации. В процессе проектирования ПО для выражения его характеристик используются различные нотации — блок-схемы, ER-диаграммы, UML-диаграммы, DFD-диаграммы, а также макеты.\n
Проектированию обычно подлежат:\n
•	Архитектура ПО;\n
•	Устройство компонентов ПО;\n
•	Пользовательские интерфейсы.\n
В практике проектирование ведется поэтапно в соответствии со стадиями:\n
•	Техническое задание,\n
•	Техническое предложение,\n
•	Эскизный проект,\n
•	Технический проект,\n
•	Рабочий проект.\n
На каждом из этапов формируется свой комплект документов, называемый проектом (проектной документацией).\n
В зарубежной практике регламентирующими документами, например, являются Software Architecture Document, Software Design Document.\n
</item>
 <!--16--><item>Уругвай</item>
 <!--17--><item>Уругвай</item>
 <!--18--><item>Уругвай</item>
 <!--19--><item>Уругвай</item>
 <!--20--><item>Уругвай</item>
 <!--21--><item>Уругвай</item>
 <!--22--><item>Уругвай</item>
 <!--23--><item>Уругвай</item>
 <!--24--><item>Уругвай</item>
 <!--25--><item>Уругвай</item>
 <!--26--><item>Уругвай</item>
 <!--27--><item>Уругвай</item>
 <!--28--><item>Уругвай</item>
 <!--29--><item>Уругвай</item>
 <!--30--><item>Уругвай</item>
 <!--31--><item>Уругвай</item>
 <!--32--><item>Уругвай</item>
 <!--33--><item>Уругвай</item>
 <!--34--><item>Уругвай</item>
 <!--35--><item>Уругвай</item>
 <!--36--><item>Уругвай</item>
 <!--37--><item>Уругвай</item>
 <!--38--><item>Уругвай</item>
 <!--39--><item>Уругвай</item>
 <!--40--><item>Уругвай</item>
 <!--41--><item>Уругвай</item>
 <!--42--><item>Уругвай</item>
 <!--43--><item>Уругвай</item>
 <!--44--><item>Уругвай</item>
 <!--45--><item>Уругвай</item>
 <!--46--><item>Уругвай</item>
 <!--47--><item>Уругвай</item>
 <!--48--><item>Уругвай</item>
 <!--49--><item>Уругвай</item>
 <!--50--><item>Уругвай</item>
 <!--51--><item>Уругвай</item>
 <!--52--><item>Уругвай</item>
 <!--53--><item>Уругвай</item>
 <!--54--><item>Уругвай</item>
 <!--55--><item>Уругвай</item>
 <!--56--><item>Уругвай</item>
 <!--57--><item>Уругвай</item>
 <!--58--><item>Уругвай</item>
 <!--59--><item>Уругвай</item>
 <!--60--><item>Уругвай</item>
 <!--61--><item>Уругвай</item>
 <!--62--><item>Уругвай</item>
 <!--63--><item>Уругвай</item>
 <!--64--><item>Уругвай</item>
 <!--65--><item>Уругвай</item>
 <!--66--><item>Уругвай</item>
 <!--67--><item>Уругвай</item>
    </string-array>
</resources>