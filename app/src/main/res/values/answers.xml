<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="answers">
        <item >1.ПОНЯТИЕ АЛГОРИТМА. ПОДХОДЫ К ОПРЕДЕЛЕНИЮ АЛГОРИТМА. СВОЙСТВО АЛГОРИТМА.\n\n
Понятие алгоритма является одним из основных понятий современ¬ных математики и информатики, но зародилось оно еще в глубокой древности. Термин алгоритм происходит от имени средневекового узбекского математика Аль Хорезми (IX в.), который сформулировал правила выполнения четырех арифметических действий в десятичной системе счисления.\n\n
В современной информатике используется следующее определение алгоритма. Алгоритмом называют систему четких однозначных указаний, которые определяют последовательность действий над некоторыми объектами и после конечного числа шагов приводят к получению требуемого результата.\n\n
Подходы к определению алгоритма:
Слово алгоритм происходит от algorithmi – латинской формы написания имени великого математика IX в. Аль Хорезми, который сформулировал правила выполнения арифметических действий. Первоначально под алгоритмами и понимали только правила выполнения четырех арифметических действий над многозначными числами. В дальнейшем это понятие стали использовать вообще для обозначения последовательности действий, приводящих к решению поставленной задачи.\n\n
Свойства алгоритма\n
1. Дискретность алгоритма предполагает, что решение задачи (т.е. алгоритм) разбито на отдельные шаги (операции, команды) и переход к сле¬дующему шагу возможен только после выполнения предыдущего.
\n
2. Определенность (точность) алгоритма предполагает, что каждая его команда должна однозначно определять действие исполнителя алгоритма (записанные в алгоритме команды должны иметь однозначную трактовку).
\n
3. Понятность алгоритма подразумевает, что он должен включать в себя только те шаги или команды, которые понятны исполнителю (в алгоритме не могут присутствовать команды, смысл которых неизвестен исполнителю).
\n
4. Результативность (конечность) предполагает, что алгоритм дол¬жен быть нацелен на получение конечного результата, т.е. исполнение алгоритма должно закончиться за конечное число шагов.
\n
5. Массовость алгоритма подразумевает, что алгоритм должен быть пригоден для решения целого класса однотипных задач (а не только для одной конкретной задачи).
\n\n
Основные способы записи алгоритмов
\n
1. Словесный способ, т.е. описание алгоритма на естественном языке (словами).\n
2. Формульно-словесный способ, в котором кроме слов могут использоваться математические формулы.\n
3. Графический способ, т.е. в виде блок-схемы.\n
4. Программный способ, т.е. в виде программы на алгоритмическом языке.\n
</item>
        <item>2.СТРУКТУРА ПРОГРАММЫ, ЭЛЕМЕНТЫ ЯЗЫКА С++. ПОНЯТИЕ ТИПА ДАННЫХ.\n\n\n\n
Структура программы на языке С++ \n
Программа на языке C++ состоит из функций, описаний и директив препроцессора.\n
(Препроцессор — это программа, которая выполняет обработку файла исходного кода перед началом компиляции).\n
Рассмотрим простейшую программу:\n
#include &lt;Ciostream>\n
using namespace std;\n
int main()\n
{\n
cout &lt;&lt; "Hello world!" &lt;&lt; end1;\n
return 0;\n
}\n
В первой строке с помощью директивы #include подключается заголовочный файл &lt;iostream>, который содержит необходимую информацию для управления вводом/выводом.\n
Следующая директива using открывает доступ к пространству имен (англ. namespace) std, в котором определяются средства стандартной библиотеки языка C++.\n
(Пространство имён — некоторое множество, созданное для логической группировки уникальных идентификаторов).\n
Отправной точкой выполнения любой С++-программы является функция main(). Функция содержит четыре элемента:\n
•	возвращаемый тип (в нашем случае int);\n
•	имя функции (main);\n
•	список параметров, заключенный в круглые скобки (в данном случае список пуст);\n
•	заключенное в фигурные скобки, тело функции, представляющее собой блок инструкций.\n\n
Инструкцией называется часть программы, определяющая действие и не являющаяся директивой препроцессора.\n
В нашей программе тело функции содержит две инструкции:\n
•	cout  "Hello, World!";\n
•	return 0;\n
Во-первых, выводится на экран строка Hello, World, а затем возвращается в точку вызова значение 0, которое означает, что программа выполнена успешно.\n
Обратим внимание на то, что каждая инструкция в языке С++ заканчивается точкой с запятой. Существуют следующие исключения:\n
•	директивы препроцессора, начинающиеся с символа # (например, #include);\n
•	составные операторы и блоки определения функций, которые обрамлены фигурными скобками — { }.\n\n

Элементы языка С++\n
Начнем изучение языка С++ с рассмотрения состава и основных конструкций необходимых для написания программ.\n
Алфавит языка\n
Алфавит языка программирования C++ включает:\n
•	прописные и строчные латинские буквы, и знак подчеркивания;\n
•	арабские цифры от 0 до 9;\n
•	специальные знаки: " { } , | [ ] ( ) + - / % * . \ ? &lt; = > ! &amp; # - ; ' '\n
•	пробельные символы: пробел, символы табуляции, символы перехода на новую строку.\n\n
Из символов алфавита формируются лексемы языка (минимальная единица языка, имеющая самостоятельный смысл):\n
o	идентификаторы;\n
o	ключевые слова;\n
o	знаки операций;\n
o	константы;\n
o	разделители (скобки, точка, запятая, пробельные символы).\n\n

Идентификаторы\n
Идентификатор — это имя программного объекта\n
Первым символом в идентификаторе может быть буква или знак подчеркивания. Внутри идентификаторов не допускается использование пробелов.\n
Например: v1, _sum\n\n

При выборе идентификатора следует иметь в виду следующее:\n
•	идентификатор не должен совпадать с ключевыми словами и именами используемых стандартных объектов языка;\n
•	не рекомендуется начинать идентификаторы с символа подчеркивания, т. к. в этом случае они могут совпасть с именами системных функций или переменных.\n\n

Ключевые слова\n
Ключевые слова — это зарезервированные идентификаторы, которые имеют специальное значение для компилятора.\n

Таблица1. Список ключевых слов C++\n
asm auto bool break case catch char class const\n
const_cast continue default delete do double\n
dynamic_cast else enum explicit export extern\n
false float for friend goto if inline int long\n
mutable namespace new operator private protected\n
public register reinterpret_cast return short\n
signed sizeof static static__cast struct switch\n
template this throw true try typedef typeid typename\n
union unsigned using virtual void volatile wchar_t while\n\n

Знаки операций\n
Знак операции — это один или более символов, определяющих действие над операндами.
Операции делятся на унарные, бинарные и тернарную по количеству участвующих в них операндов. Один и тот же знак может интерпретироваться по-разному в зависимости от контекста.\n\n

Константы\n
Константами называют неизменяемые величины.\n
Различаются целые, вещественные, символьные и строковые константы. Компилятор, выделив константу в качестве лексемы, относит ее к одному из типов по ее внешнему виду.\n\n

Комментарии\n
Комментарии используются для пояснения отдельных частей или всей программы. Отметим, что компилятор игнорирует комментарии.\n
В языке С++ используется две формы комментариев:\n
•	комментарий начинается с двух символов «прямая косая черта» // и заканчивается символом перехода на новую строку\n
•	комментарий заключается между символами-скобками /* ... */\n\n

Внимание! Вложенные комментарии-скобки стандартом не допускаются.\n
Внутри комментария можно использовать любые допустимые на данном компьютере символы.\n\n

Типы данных С++\n
Любая программа в ходе работы обрабатывает данные. Хранение и обработка данных зависит от их типа. Каждая константа, переменная, результат вычисления выражения или функции должны иметь определенный тип.\n\n

Тип данных определяет:\n
•	представление данных в памяти компьютера;\n
•	множество значений, которые могут принимать величины данного типа;\n
•	операции и функции, которые можно применять к величинам этого типа.\n\n

Все типы языка C++ можно разделить на основные и составные.\n
Основные типы данных используются для представления целых, вещественных, символьных и логических величин. К составным типам относятся массивы, перечисления, функции, структуры, ссылки, указатели, объединения и классы.\n\n

Основные типы данных\n
Для описания основных типов данных определены следующие ключевые слова:\n
•	int (целый);\n
•	char (символьный);\n
•	wchar_t (расширенный символьный);\n
•	bool (логический);\n
•	float (вещественный);\n
•	double (вещественный с двойной точностью).\n\n

Для уточнения диапазона значений и внутреннего представления стандартных типов применяются четыре спецификатора типа:\n
•	short (короткий);\n
•	long (длинный);\n
•	signed (знаковый);\n
•	unsigned (беззнаковый).\n\n

Типичные размеры значений и диапазоны представлений\n
Тип: bool\n
Размер (байт): 1\n
Диапазон значений: true, false\n
Замечания: Внутренняя форма представления значения false - 0. Любое другое значение интерпретируется как true.\n\n

Тип: signed char\n
Размер (байт): 1\n
Диапазон значений: -128 ... 127\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: unsigned char\n
Размер (байт): 1\n
Диапазон значений: 0 ... 255\n
Замечания: Используются для хранения 8-разрядных ASCII-символов либо любых других 8-разрядных значений.\n\n

Тип: signed short int\n
Размер (байт): 2\n
Диапазон значений: -32768 ... 32767\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned short int\n
Размер (байт): 2\n
Диапазон значений: 0 ... 65535\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: signed long int\n
Размер (байт): 4\n
Диапазон значений: -2 147 483 648 ... 2 147 483 647\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: unsigned long int\n
Размер (байт): 4\n
Диапазон значений: 0 ... 4 294 967 295\n
Замечания: Спецификатор signed указывает рассматривать старший бит числа как знаковый (0 - положительное число, 1 - отрицательное). По умолчанию целочисленные типы считаются знаковыми (спецификатор signed можно опускать). При использовании спецификатора unsigned старший разряд рассматривается как часть кода числа, поэтому представляются только положительные числа.\n\n

Тип: float\n
Размер (байт): 4\n
Диапазон значений: 3.4e-38 ... 3.4e+38\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: double\n
Размер (байт): 8\n
Диапазон значений: 1.7e-308 ... 1.7e+308\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Тип: long double\n
Размер (байт):8\n
Диапазон значений: 3.4e-4932 ... 3.4e+4932\n
Замечания: Типы данных с плавающей точкой. Эти типы хранятся в памяти компьютера иначе, чем целочисленные: представление вещественного числа состоит из двух частей — мантиссы и порядка. Константы с плавающей точкой имеют по умолчанию тип double.\n\n

Константам, встречающимся в программе, компилятор приписывает тот или иной тип в соответствии с их видом. Можно явно указать требуемый тип с помощью соответствующих суффиксов:\n
•	Для целых типов:\n
L, l (long) и u, U (unsigned). Например, 50L будет иметь тип long. Суффиксы L и U можно использовать одновременно, например: 105LU.\n
•	Для вещественных типов:\n
F, f (float) и L, l (long). Например, константа 3e+5L будет иметь тип long double, а константа 1.82f — тип float.\n\n

Тип void\n
К основным типам языка С++ относится также тип void. Множество значений этого типа пусто. Он применяется для определения функций, которые не возвращают значения, для указания пустого списка аргументов функции, как базовый тип для указателей и в операции приведения типов.
</item>
        <item>3.ОПЕРАЦИИ (АРИФМЕТИЧЕСКИЕ, ЛОГИЧЕСКИЕ) НА ТИПАХ. СТАНДАРТНЫЕ ФУНКЦИИ. ВЫРАЖЕНИЯ.\n\n
Операции. Арифметические операции\n
1. Какие арифметические операции используются в языке C/C++?\n
В языке C++ поддерживаются следующие арифметические операции:\n
+ – сложение;\n
- – вычитание;\n
* – умножение;\n
/ – деление;\n
% – остаток от деления.\n
Все эти операции являются бинарными. Это означает, что для получения результата, нужно 2 операнда. Общий вид арифметической операции:\n
операнд1 операция операнд2\n
где операция – одна из операций +, —, *, %, /.\n\n
            2. Для каких типов данных можно применять арифметические операции?\n
Арифметические операции можно применять для:\n
•  целочисленных типов: short int, unsigned short int, int, unsigned int, long, unsigned long;\n
•  типов с плавающей запятой (вещественных типов): float, double, long double;\n
•  типов (классов), которые содержат «перегруженные» арифметические операции.\n
В арифметических операциях один из операндов может иметь целочисленный тип, а второй быть типом с плавающей запятой. В этом случае результат имеет тип с плавающей запятой.\n\n
3. Как осуществляется приведение типов в операциях +, —, *?\n
В выражениях, где используются операции +, —, *, действуют следующие правила приведения типа результата:\n
•  если оба операнда имеют целый тип, то результат также будет целого типа;\n
•  если хотя бы один из операндов имеет вещественный (с плавающей запятой) тип а другой целый тип, то результат также будет вещественного типа;\n
•  если один из операндов имеет тип float, а другой тип double, то результат будет типа double. Это связано с тем, что тип double требует больше памяти чем тип float. В этом случае происходит расширение типа float к типу double.\n\n
4. Какой приоритет и ассоциативность арифметических операций?\n
Арифметические операции имеют приоритет и ассоциативность, как изображено в следующей таблице.
Знаки операций Наименование   Ассоциативность\n
*   /   %  Бинарные, мультипликативные    Слева направо\n
+   —  Бинарные, аддитивные   Слева направо\n\n
5. Какое отличие между бинарными и унарными операциями сложения (+) и вычитания (—)?\n
Операции сложения (+) и вычитания (—) могут быть как бинарными, так и унарными.\n
Бинарные операции + и — используются в выражениях при проведении вычислений.\n
Унарные операции + и — используются для обозначения знака числа (положительное число или отрицательное число).\n
Пример.\n
int a, b;\n
a = -8; // унарная операция \'-\', обозначает знак числа\n
b = +9; // унарная операция \'+\', b = 9\n
a = b-5; // бинарная операция \'-\', используется для вычисления выражения\n\n
6. Какие особенности использования операции % (остаток от деления)?\n
Операция % используется над целыми операндами. Операция % позволяет получить остаток от деления целых операндов.\n
Пример.\n
// Операция % - взятие остатка от деления\n
int a, b;\n
int c;\n
a = 3;\n
b = 5;\n
c = a % b;   // c = 3\n
a = 8;\n
b = 4;\n
c = a % b;   // c = 0\n
c = 12 % 35; // c = 12\n
c = 35 % 12; // c = 11\n
c = -5 % -3; // c = -2\n\n
7. Какие особенности использования операции / (деление)?\n
Операция деления имеет свои особенности, которые состоят в следующем:\n
•  если два операнда имеют целочисленный тип, то результат возвращается целого типа. В этом случае происходит деление нацело. Остаток от деления урезается;\n
•  если один из операндов имеет тип с плавающей запятой, тогда результат имеет также тип с плавающей запятой.\n
Пример.\n
// Операция деления \'/\'\n
int a, b;\n
int c;\n
float x;\n
a = 8;\n
b = 3;\n
c = a / b; // c = 2\n
x = a / b; // x = 2.0\n
x = a / (float)b; // x = 2.666667\n
x = 17.0 / 3; // x = 5.666667\n
x = 17 / 3;   // x = 5.0\n\n
C++. Логические операции. Поразрядные логические операции. Операции сдвига. Операция XOR\n
1. Для каких типов можно применять логические операции, поразрядные логические операции и операции сдвига?\n
Логические операции, поразрядные логические операции и операции сдвига можно использовать только для операндов целых типов.\n
2. Какие логические операции используются в C++?\n
В языке программирования C++ используются следующие логические операции:\n
•  &amp;&amp; – логическое «И»;\n
•  || – логическое «ИЛИ»;\n
•  ! – логическое «НЕТ».\n
Результатом логических операций есть значение false или true. В языке C++ принято, что значение false считается равным 0, а значение true считается равным 1.\n
Отсюда можно сделать вывод, что false &lt; true. Например:\n
// логические операции\n
bool res;\n
res = false &lt; true; // res = true\n\n
3. Таблица истинности логических операций\n
Таблица истинности логических операций &amp;&amp; (логическое «И»), || (логическое «ИЛИ»), ! (логическое «НЕТ») имеет следующий вид:\n
a b a&amp;&amp;b a||b !a !b\n
false false false false true true\n
false true false true true false\n
true false false true false true\n
true true true true false false\n

В языке C++ принимается, что значение false равно 0, а значение true не равно 0 (любое ненулевое целочисленное значение).\n\n
4. Примеры использования логических операций в C++\n
Пример 1. Логическая операция в сочетании с логическим выражением\n
// логические операции\n
bool res;\n
int a, b;\n
// операция &amp;&amp; (AND)\n
a = 8;\n
b = 5;\n
res = a &amp;&amp; b; // res = True\n
a = 0;\n
res = a &amp;&amp; b; // res = False\n
// операция || (OR)\n
a = 0;\n
b = 0;\n
res = a || b; // res = False\n
b = 7;\n
res = a || b; // res = True\n\n
// операция ! (логическое "НЕТ")\n
a = 0;\n
res = !a; // res = True\n
a = 15;\n
res = !a; // res = False\n\n
Пример 2. Логическая операция в условных выражениях. Приведен фрагмент кода, в котором логическая операция используется в операторе условного перехода if.\n
// логические операции в условных выражениях\n
int a, b;\n
bool res;\n
a = 0;\n
b = 3;\n
res = false;\n
if (a &amp;&amp; b)\n
res = true; // res = false\n
a = 0;\n
b = 7;\n
if (a || b)\n
res = true; // res = true\n\n
5. Какие поразрядные логические операции используются в C++?\n
Язык С++ поддерживает следующие поразрядные логические операции:\n
•  &amp; – поразрядное логическое И (AND);\n
•  ^ – поразрядное сложение по модулю 2 (XOR — исключающее ИЛИ);\n
•  | – поразрядное логическое ИЛИ (OR);\n
•  ~ – поразрядная инверсия (NOT).\n
Операции &amp;, ^, | есть бинарными. Это означает, что они требуют двух операндов. Биты любого операнда сравниваются между собой по следующему правилу: бит в позиции 0 первого операнда сравнивается с битом в позиции 0 второго операнда. Затем бит в позиции 1 первого операнда сравнивается с битом в позиции 1 второго операнда. Так сравниваются все биты целочисленных операндов.\n\n
6. Таблица истинности поразрядных логических операций\n
Каждый бит результата определяется на основе двух операндов, которые являются битами, так как показано в таблице.\n
бит1 бит2 &amp; || ^ ~бит1 ~бит2\n
0 0 0 0 0 1 1\n
0 1 0 1 1 1 0\n
1 0 0 1 1 0 1\n
1 1 1 1 0 0 0\n

Инверсия требует единого операнда справа от знака ~. Результат получается поразрядной инверсией всех битов операнда.\n\n
7. Пример работы с логическими побитовыми операциями\n
Пусть даны два числа 17 и 45 типа unsigned short int. Каждое из чисел занимает в памяти 1 байт или 8 бит. Ниже приведен пример того, как происходит вычисление для каждой побитовой операции\n
  128 64 32 16 8 4 2 1\n
17 =       0 0 0 1 0 0 0 1\n
45 =       0 0 1 0 1 1 0 1\n
17&amp;45 = 0 0 0 0 0 0 0 1 = 1\n
17|45 =  0 0 1 1 1 1 0 1 = 61\n
17^45 = 0 0 1 1 1 1 0 0 = 60\n
~17 =     1 1 1 0 1 1 1 0 = 238\n

Как видно из примера, происходит выполнение заданной операции над каждым битом.\n\n
8. Какие операции сдвига используются в C++?\n
Язык С++ включают две операции поразрядного сдвига:\n
•  &lt;&lt; – сдвиг влево значения операнда на заданное количество бит. Операнд размещается слева от знака операции. Число сдвигаемых бит указывается справа от знака операции;\n
•  >> – сдвиг вправо значения операнда на заданное количество бит. Операнд размещается слева от знака операции (&lt;&lt;). Количество сдвигаемых бит размещается справа от знака операции.\n
Выдвижные биты теряются, а «входят» нулевые биты. Сдвиг операндов влево на 1, 2, 3 и более разрядов – наиболее быстрый способ умножения на 2, 4, 8, … Сдвиг операндов вправо на 1, 2, 3 и более разрядов – наиболее быстрый способ деления на 2, 4, 8, …\n
Если в программе нужно, чтобы операция умножения целочисленных операндов на 2, 4, 8 и т.д. происходила максимально быстро, то целесообразно использовать операцию сдвига влево.\n
Это касается и случаев, когда нужно максимально быстро поделить целочисленный операнд на 2, 4, 8 и т.д. В этих случаях рекомендуется использовать сдвиг вправо.\n\n
9. Примеры использования операций сдвига в программе
\\// Операции сдвига\n
int a;\n
int b;\n
int c;\n
a = 15;\n
b = -5;\n

// сдвиг влево - умножение\n
c = a &lt;&lt; 1; // c = a * 2^1 = 30\n
c = b &lt;&lt; 2; // c = b * 2^2 = -20\n

// сдвиг вправо - деление\n
c = a >> 3; // c = a / 2^3 = 1\n
c = b >> 1; // c = b / 2^1 = -3\n\n
10. Какое отличие между логическими операциями и поразрядными логическими операциями?\n
В логических операциях сравнивается значение двух операндов целиком. Каждый из операндов может иметь значение true или false. Язык C++ допускает сравнение операндов, которые являются целыми числами. В этом случае целочисленное значение 0 соответствует значению false, а ненулевое (любое другое) значение соответствует значению true.\n
Поразрядные логические операции работают строго с битами любого операнда. Бит может иметь 2 значения: 0 или 1. Поэтому, вычислению подлежат соответствующие биты каждого операнда а не значение операнда в целом.\n\n
11. Как в C++ реализовать логическую операцию XOR?\n
Как известно, язык C++ не содержит встроенной логической операции XOR (исключающее «ИЛИ»).\n
Ниже приведен фрагмент кода, который реализует операцию XOR с помощью использования операций &amp;&amp; (AND), || (OR), ! (NOT).\n
// реализация операции XOR через операции &amp;&amp; (AND), || (OR), ! (NOT)\n
bool x, y;\n
bool res;\n

...\n

res = (x || y) &amp;&amp; !(x &amp;&amp; y);\n

...\n
В вышеприведенном программном коде:\n
•  x, y – переменные, для которых вычисляется операция XOR;\n
•  res – переменная, которая есть результатом вычисления.\n

</item>
        <item>4.УСЛОВНЫЙ ОПЕРАТОР. ОПЕРАТОР МНОЖЕСТВЕННОГО ВЕТВЛЕНИЯ (ВЫБОРА).\n\n\n
Условные операторы if и switch в C++\n
Одна из основных конструкций алгоритма — разветвляющийся процесс. Он реализован в языке C++ двумя условными операторами: if и switch. Рассмотрим каждый из них.\n\n

Условный оператор if\n
Для организации вычислений в зависимости от какого-либо условия в C++ предусмотрен условный оператор if, который в общем виде записывается следующим образом:\n
if (условие) оператор_1; else оператор_2;\n
Здесь условие — это логическое выражение, переменная или константа.\n
Работает условный оператор следующем образом. Сначала вычисляется значения выражения, записанного в виде условия. Если оно имеет значение истина (true), выполняется оператор_1. В противном случае (значение ложное (false) ) оператор_2.\n
Например, чтобы сравнить значения переменных a и b нужно написать следующую часть программного кода:\n

int a, b;\n
cin>>a;\n
cin>>b;\n
if (a==b) cout&lt;&lt;"a equal b";\n
else cout&lt;&lt;"a not equal b";\n
Не путайте знак проверки равенства == и оператор присваивания =\n
Если в задаче требуется, чтобы в зависимости от значения условия выполнялся не один оператор, а несколько, их необходимо заключить в фигурные скобки, как составной оператор.\n
if (условие) { оператор_1; оператор_2; … }\n
else { оператор_1; оператор_2; … }\n
Альтернативная ветвь else в условном операторе может отсутствовать, если в ней нет необходимости.\n\n
Оператор варианта switch\n
Он необходим в тех случаях, когда в зависимости от значений переменной надо выполнить те или иные операторы:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
default: операторы; break;\n
}\n
Оператор работает следующем образом. Вычисляется значение выражения. Затем выполняются операторы, помеченные значением, совпадающим со значением выражения. То есть если, выражение принимает значение_1, то выполняются операторы_1 и т.д.. Если выражение не принимает ни одного из значений, то выполняются операторы, расположенные после слова default.\n
Ветвь default может отсутствовать, тогда оператор имеет вид:\n
switch (выражение)\n
{\n
case значение_1: операторы_1; break;\n
case значение_2: операторы_2; break;\n
case значение_3: операторы_3; break;\n
…\n
case значение_n: операторы_n; break;\n
}\n
Оператор break необходим для того, чтобы осуществить выход из операторы switch. Если он не указан, то будут выполняться следующие операторы из списка, несмотря на то, что значение, которым они помечены, не совпадает со значением выражения.\n
Некоторые вещи могут быть непонятны, и поэтому для ясности давайте рассмотрим пример несложной задачи.\n\n
Задача\n
Необходимо вывести на название дня недели, соответствующее заданному числу D, при условии, что в месяце 31 день и 1-е число — понедельник.\n
Для решения задачи воспользуемся операцией %, позволяющей вычислить остаток от деления двух чисел. Программа будет выводить название дня недели в зависимости от заданного нами числа.\n

#include "stdafx.h"\n
#include &lt;iostream>\n
using namespace std;\n
int main ()\n
{\n
unsigned int D, R; //описанны целые положительные числа\n
cout&lt;&lt;"D=";\n
cin>>D;\n
R=D%7;\n
switch (R)\n
{\n
case 1: cout&lt;&lt;"Monday \n"; break;\n
case 2: cout&lt;&lt;"Theusday \n"; break;\n
case 3: cout&lt;&lt;"Wednesday \n"; break;\n
case 4: cout&lt;&lt;"Thursday \n"; break;\n
case 5: cout&lt;&lt;"Friday \n"; break;\n
case 6: cout&lt;&lt;"Saturday \n"; break;\n
case 0: cout&lt;&lt;"Sunday \n"; break;\n
}\n
system ("pause");\n
return 0;\n
}\n
</item>
        <item>5.ЦИКЛИЧЕСКИЕ ОПЕРАТОРЫ.\n\n\n\n\n
Циклы в C++\n
Иногда необходимо повторять одно и то же действие несколько раз подряд. Для этого используют циклы. В этом уроке мы научимся программировать циклы на C++, после чего посчитаем сумму всех чисел от 1 до 1000.\n
Цикл for\n
Если мы знаем точное количество действий (итераций) цикла, то можем использовать цикл for. Синтаксис его выглядит примерно так:\n
for (действие до начала цикла;\n
     условие продолжения цикла;\n
     действия в конце каждой итерации цикла) {\n
         инструкция цикла;\n
         инструкция цикла 2;\n
         инструкция цикла N;\n
}\n
Итерацией цикла называется один проход этого цикла\n
Существует частный случай этой записи, который мы сегодня и разберем:\n
for (счетчик = значение; счетчик &lt; значение; шаг цикла) {\n
    тело цикла;\n
}\n
Счетчик цикла — это переменная, в которой хранится количество проходов данного цикла.\n
Описание синтаксиса\n
•	Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.\n
•	Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.\n
•	Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.\n
Пример кода\n
Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    int i; // счетчик цикла\n
    int sum = 0; // сумма чисел от 1 до 1000.\n
    setlocale(0, "");\n
    for (i = 1; i &lt;= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.\n
    {\n
        sum = sum + i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится очень много времени и сил. Цикл выполнил всю рутинную работу за нас.\n
Заметьте, что конечное значение счетчика я задал нестрогим неравенством ( &lt;= — меньше либо равно), поскольку, если бы я поставил знак меньше, то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. Это довольно важный момент, т.к. здесь новички часто допускают ошибки, особенно при работе с массивами (о них будет рассказано в следующем уроке). Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1.\n
В теле цикла, при каждом проходе программа увеличивает значение переменной sum на i. Еще один очень важный момент — в начале программы я присвоил переменной sum значение нуля. Если бы я этого не сделал, программа вылетела вы в сегфолт. При объявлении переменной без ее инициализации что эта переменная будет хранить «мусор».\n
Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, такие как gcc, инициализирует переменную нулем при ее объявлении.\n
Цикл while\n
Когда мы не знаем, сколько итераций должен произвести цикл, нам понадобится цикл while или do...while. Синтаксис цикла while в C++ выглядит следующим образом.\n
while (Условие) {\n
    Тело цикла;\n
}\n
Данный цикл будет выполняться, пока условие, указанное в круглых скобках является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы точно знаем, сколько итераций должен выполнить цикл, очень часто бывают ситуации, когда это значение неизвестно.\n
Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000.\n
#include &lt;iostream>\n
using namespace std;\n

int main()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    while (i &lt; 1000)\n
    {\n
        i++;\n
        sum += i;\n
    }\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
После компиляции программа выдаст результат, аналогичный результату работы предыдущей программы. Но поясним несколько важных моментов. Я задал строгое неравенство в условии цикла и инициализировал счетчик i нулем, так как в цикле while происходит на одну итерацию больше, потому он будет выполняться, до тех пор, пока значение счетчика перестает удовлетворять условию, но данная итерация все равно выполнится. Если бы мы поставили нестрогое неравенство, то цикл бы закончился, когда переменная i стала бы равна 1001 и выполнилось бы на одну итерацию больше.\n
Теперь давайте рассмотрим по порядку исходный код нашей программы. Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел.
В данном случае мы обязательно должны присвоить счетчику цикла какое-либо значение, т.к. в предыдущей программе мы это значение присваивали внутри цикла for, здесь же, если мы не инициализируем счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае выдаст нам ошибку, а в худшем, если программа соберется — сегфолт практически неизбежен.\n
Затем мы описываем условие цикла — «пока переменная i меньше 1000 — выполняй цикл». При каждой итерации цикла значение переменной-счетчика i увеличивается на единицу внутри цикла.\n
Когда выполнится 1000 итераций цикла, счетчик станет равным 999 и следующая итерация уже не выполнится, поскольку 1000 не меньше 1000. Выражение sum += i является укороченной записью sum = sum + i.
После окончания выполнения цикла, выводим сообщение с ответом.\n
Цикл do while\n
Цикл do while очень похож на цикл while. Единственное их различие в том, что при выполнении цикла do while один проход цикла будет выполнен независимо от условия. Решение задачи на поиск суммы чисел от 1 до 1000, с применением цикла do while.\n
#include &lt;iostream>\n
using namespace std;\n

int main ()\n
{\n
    setlocale(0, "");\n
    int i = 0; // инициализируем счетчик цикла.\n
    int sum = 0; // инициализируем счетчик суммы.\n
    do {// выполняем цикл.\n
        i++;\n
        sum += i;\n
    } while (i &lt; 1000); // пока выполняется условие.\n
    cout &lt;&lt; "Сумма чисел от 1 до 1000 = " &lt;&lt; sum &lt;&lt; endl;\n
    return 0;\n
}\n
Принципиального отличия нет, но если присвоить переменной i значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход.
</item>
        <item>6.СИСТЕМЫ УПРАВЛЕНИЯ БАЗАМИ ДАННЫХ (СУБД).\n\n\n\n\n
Система управления базами данных сокр. СУБД (англ. Database Management System, сокр. DBMS) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.\n
СУБД — комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.\n\n
Основные функции СУБД\n
1.	управление данными во внешней памяти (на дисках);\n
2.	управление данными в оперативной памяти с использованием дискового кэша;\n
3.	журнализация изменений, резервное копирование и восстановление базы данных после сбоев;\n
4.	поддержка языков БД (язык определения данных, язык манипулирования данными).\n\n
Состав СУБД\n
Обычно современная СУБД содержит следующие компоненты:\n
•	ядро, которое отвечает за управление данными во внешней и оперативной памяти и журнализацию;\n
•	процессор языка базы данных, обеспечивающий оптимизацию запросов на извлечение и изменение данных и создание, как правило, машинно-независимого исполняемого внутреннего кода;\n
•	подсистему поддержки времени исполнения, которая интерпретирует программы манипуляции данными, создающие пользовательский интерфейс с СУБД;\n
•	сервисные программы (внешние утилиты), обеспечивающие ряд дополнительных возможностей по обслуживанию информационной системы.\n\n
Классификации СУБД\n
По модели данных\n
Примеры:\n
•	Иерархические\n
•	Сетевые\n
•	Реляционные\n
•	Объектно-ориентированные\n
•	Объектно-реляционные\n\n
По степени распределённости\n
•	Локальные СУБД (все части локальной СУБД размещаются на одном компьютере)\n
•	Распределённые СУБД (части СУБД могут размещаться не только на одном, но на двух и более компьютерах).\n
По способу доступа к БД\n
•	Файл-серверные\n
В файл-серверных СУБД файлы данных располагаются централизованно на файл-сервере. СУБД располагается на каждом клиентском компьютере (рабочей станции). Доступ СУБД к данным осуществляется через локальную сеть. Синхронизация чтений и обновлений осуществляется посредством файловых блокировок.\n
Преимуществом этой архитектуры является низкая нагрузка на процессор файлового сервера.\n
Недостатки: потенциально высокая загрузка локальной сети; затруднённость или невозможность централизованного управления; затруднённость или невозможность обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность. Применяются чаще всего в локальных приложениях, которые используют функции управления БД; в системах с низкой интенсивностью обработки данных и низкими пиковыми нагрузками на БД.\n
На данный момент файл-серверная технология считается устаревшей, а её использование в крупных информационных системах — недостатком.\n
Примеры: Microsoft Access, Paradox, dBase, FoxPro, Visual FoxPro.\n
•	Клиент-серверные\n
Клиент-серверная СУБД располагается на сервере вместе с БД и осуществляет доступ к БД непосредственно, в монопольном режиме. Все клиентские запросы на обработку данных обрабатываются клиент-серверной СУБД централизованно.\n
Недостаток клиент-серверных СУБД состоит в повышенных требованиях к серверу.\n
Достоинства: потенциально более низкая загрузка локальной сети; удобство централизованного управления; удобство обеспечения таких важных характеристик, как высокая надёжность, высокая доступность и высокая безопасность.\n
Примеры: Oracle Database, Firebird, Interbase, IBM DB2, Informix, MS SQL Server, Sybase Adaptive Server Enterprise, PostgreSQL, MySQL, Caché, ЛИНТЕР.\n
•	Встраиваемые\n
Встраиваемая СУБД — СУБД, которая может поставляться как составная часть некоторого программного продукта, не требуя процедуры самостоятельной установки. Встраиваемая СУБД предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети.\n
Физически встраиваемая СУБД чаще всего реализована в виде подключаемой библиотеки. Доступ к данным со стороны приложения может происходить через SQL либо через специальные программные интерфейсы.\n
Примеры: OpenEdge, SQLite, BerkeleyDB, Firebird Embedded, Microsoft SQL Server Compact, ЛИНТЕР.\n
Стратегии работы с внешней памятью\n
СУБД с непосредственной записью\n
В таких СУБД все изменённые блоки данных незамедлительно записываются во внешнюю память при поступлении сигнала подтверждения любой транзакции. Такая стратегия используется только при высокой эффективности внешней памяти.\n
СУБД с отложенной записью\n
В таких СУБД изменения аккумулируются в буферах внешней памяти до наступления любого из следующих событий:\n
•	Контрольная точка.\n
•	Нехватка пространства во внешней памяти, отведенного под журнал. СУБД создаёт контрольную точку и начинает писать журнал сначала, затирая предыдущую информацию.\n
•	Останов. СУБД ждёт, когда всё содержимое всех буферов внешней памяти будет перенесено во внешнюю память, после чего делает отметки, что останов базы данных выполнен корректно.\n
•	Нехватка оперативной памяти для буферов внешней памяти.\n
Такая стратегия позволяет избежать частого обмена с внешней памятью и значительно увеличить эффективность работы СУБД.\n

</item>
        <item>7.ПРОЕКТИРОВАНИЕ СТРУКТУРЫ БАЗЫ ДАННЫХ.\n\n\n\n
Проектирование баз данных — процесс создания схемы базы данных и определения необходимых ограничений целостности.\n

Основные задачи проектирования баз данных\n
Основные задачи:\n
•	Обеспечение хранения в БД всей необходимой информации.\n
•	Обеспечение возможности получения данных по всем необходимым запросам.\n
•	Сокращение избыточности и дублирования данных.\n
•	Обеспечение целостности базы данных.\n\n

Основные этапы проектирования баз данных\n
Концептуальное (инфологическое) проектирование\n

Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции. Такая модель создаётся без ориентации на какую-либо конкретную СУБД и модель данных. Термины «семантическая модель», «концептуальная модель» и «инфологическая модель» являются синонимами. Кроме того, в этом контексте равноправно могут использоваться слова «модель базы данных» и «модель предметной области» (например, «концептуальная модель базы данных» и «концептуальная модель предметной области»), поскольку такая модель является как образом реальности, так и образом проектируемой базы данных для этой реальности.\n
Конкретный вид и содержание концептуальной модели базы данных определяется выбранным для этого формальным аппаратом. Обычно используются графические нотации, подобные ER-диаграммам.\n
Чаще всего концептуальная модель базы данных включает в себя:\n
•	описание информационных объектов или понятий предметной области и связей между ними.\n
•	описание ограничений целостности, то есть требований к допустимым значениям данных и к связям между ними.\n
Логическое (даталогическое) проектирование\n
Логическое (даталогическое) проектирование — создание схемы базы данных на основе конкретной модели данных, например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.\n
Преобразование концептуальной модели в логическую модель, как правило, осуществляется по формальным правилам. Этот этап может быть в значительной степени автоматизирован.\n
На этапе логического проектирования учитывается специфика конкретной модели данных, но может не учитываться специфика конкретной СУБД.\n
Физическое проектирование\n
Физическое проектирование — создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т. п. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и т. д.\n
Результатом физического проектирования логической схемы выше на языке SQL может являться следующий скрипт:\n
CREATE TABLE IF NOT EXISTS Department ( -- Факультет\n
  id INT NOT NULL,\n
  name VARCHAR(45),\n
  PRIMARY KEY (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Group (\n
  id INT NOT NULL,\n
  name VARCHAR(45) ,\n
  depart_id INT NOT NULL,\n
  UNIQUE INDEX depart_id_UNIQUE (depart_id ASC),\n
  PRIMARY KEY (id, depart_id),\n
  CONSTRAINT depart_fk\n
    FOREIGN KEY (depart_id)\n
    REFERENCES Department (id)\n
);\n\n

CREATE TABLE IF NOT EXISTS Student (\n
  first_name VARCHAR(16) NOT NULL,\n
  last_name VARCHAR(45) NOT NULL,\n
  email VARCHAR(255),\n
  group_id INT NOT NULL,\n
  PRIMARY KEY (last_name, first_name, group_id),\n
  INDEX group_fk_idx (group_id ASC),\n
  CONSTRAINT group_fk\n
    FOREIGN KEY (group_id) REFERENCES Group (id)\n
);\n\n
Нормализация\n
При проектировании реляционных баз данных обычно выполняется так называемая нормализация.\n
Модели «сущность-связь»\n
Модель «сущность-связь» (англ. “Entity-Relationship model”), или ER-модель, предложенная П. Ченом в 1976 г., является наиболее известным представителем класса семантических (концептуальных, инфологических) моделей предметной области. ER-модель обычно представляется в графической форме, с использованием оригинальной нотации П. Чена, называемой ER-диаграмма, либо с использованием других графических нотаций (Crow’s Foot, Information Engineering и др.).\n
Основные преимущества ER-моделей:\n
•	наглядность;\n
•	модели позволяют проектировать базы данных с большим количеством объектов и атрибутов;\n
•	ER-модели реализованы во многих системах автоматизированного проектирования баз данных (например, ERWin).\n
Основные элементы ER-моделей:\n
•	объекты (сущности);\n
•	атрибуты объектов;\n
•	связи между объектами.\n
Сущность — объект предметной области, имеющий атрибуты.\n
Связь между сущностями характеризуется:\n
•	типом связи (1:1, 1:N, N:М);\n
•	классом принадлежности. Класс может быть обязательным и необязательным. Если каждый экземпляр сущности участвует в связи, то класс принадлежности — обязательный, иначе — необязательный.\n
Семантические модели\n
Семантическая модель (концептуальная модель, инфологическая модель) — модель предметной области, предназначенная для представления семантики предметной области на самом высоком уровне абстракции. Это означает, что устранена или минимизирована необходимость использовать понятия «низкого уровня», связанные со спецификой физического представления и хранения данных.\n
Семантическое моделирование стало предметом интенсивных исследований с конца 1970-х годов. Основным побудительным мотивом подобных исследований (то есть проблемой, которую пытались разрешить исследователи) был следующий факт. Дело в том, что системы баз данных обычно обладают весьма ограниченными сведениями о смысле хранящихся в них данных. Чаще всего они позволяют лишь манипулировать данными определенных простых типов и определяют некоторые простейшие ограничения целостности, наложенные на эти данные. Любая более сложная интерпретация возлагается на пользователя. Однако было бы замечательно, если бы системы могли обладать немного более широким объемом сведений и несколько интеллектуальнее отвечать на запросы пользователя, а также поддерживать более сложные (то есть более высокоуровневые) интерфейсы пользователя.\n
Идеи семантического моделирования могут быть полезны как средство проектирования базы данных даже при отсутствии их непосредственной поддержки в СУБД.\n
Наиболее известным представителем класса семантических моделей является модель «сущность-связь» (ER-модель).\n

</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
        <item>Уругвай</item>
    </string-array>
</resources>